[{"title":"ChatGPT","url":"/2023/05/17/ChatGPT/","content":"OpenAI模型\n\n\n模型\ntoken\n编码\n\n\n\ngpt-35-turbo\n\ncl100k_base\n\n\ntext-similarity-ada-001\n\n\n\n\nttext-davinci-003\n4097\np50k_base\n\n\ntext-davinci-002\n\n\n\n\ntext-embedding-ada-002\n\n\n\n\n可以像下面这样使用tiktoken.encoding_for_model()来查询某个模型使用的编码。\npip install --upgrade tiktokenimport tiktokenencoding = tiktoken.encoding_for_model(&#x27;gpt-3.5-turbo&#x27;)\n\n通过encoding.encode()将文本变成token\n    def num_tokens_from_string(self, string: str, encoding_name: str) -&gt; int:        &quot;&quot;&quot;Returns the number of tokens in a text string.&quot;&quot;&quot;        encoding = tiktoken.get_encoding(encoding_name)        num_tokens = len(encoding.encode(string))        return num_tokensnum_tokens_from_string(prompt, &quot;p50k_base&quot;)\n\n\n\n推荐：text-embedding-ada-002 (Version 2)\n\n若要使用不同的模型，请将 text-davinci-002 替换为另一个部署的 ID。 请记住，部署 ID 不一定与模型名称相同。 你是在 Azure OpenAI Studio 中创建部署时为其命名的。\n\n","categories":["项目"],"tags":["Python","ChatGPT"]},{"title":"Docker","url":"/2023/05/17/Docker/","content":"Docker利用容器化技术， 通过隔离机制，可以将服务器利用到极致。\n\n容器化技术不是模拟的一个完整的操作系统\n\nDocker 本质与安装镜像（image）：\ndocker 镜像好比一个模板，可以通过这个模板来创建容器服务，tomcat 镜像&#x3D;&#x3D;&gt;》run &#x3D;&#x3D;》 tomcat01 容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中）。\n容器（container）：\nDocker 利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。\n启动，停止，删除，基本命令！\n仓库（repository）：\n仓库就是存放镜像的地方！\nDocker 安装\n环境准备 CentOS 7\n\n\n环境查看\n\n# 系统内核是 3.10 以上的[root@Wang /]# uname -r3.10.0-957.21.3.el7.x86_64\n\n# 系统环境[root@Wang /]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\nCentOS 安装帮助文档：\n# 1、卸载旧的版本sudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine# 2、需要的安装包sudo yum install -y yum-utils# 3、设置镜像仓库sudo yum-config-manager \\    --add-repo \\    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐使用阿里云的# 更新yum软件包索引sudo yum makecache fast# 4、安装docker相关的内容 docker-ce 社区sudo yum install docker-ce docker-ce-cli containerd.io# 5、启动dockersystemctl start docker# 使用 docker version 是否安装成功！\n\n\n# 6、设置开机自启sudo systemctl enable docker --now# 7、更改docker镜像，定期寻找可用的镜像源sudo vim /etc/docker/daemon.json# 编辑 daemon.json 文件，输入：&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.1panel.live&quot;,    &quot;https://mirror.baidubce.com&quot;,    &quot;https://docker.nju.edu.cn&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://docker.m.daocloud.io&quot;,    &quot;https://ghcr.io&quot;  ]&#125;# 重启dockersudo systemctl daemon-reloadsudo systemctl restart docker# 通过检查是否镜像源已修改sudo docker info# 使用 hello-world 镜像测试docker run hello-world\n\n\n# 查看一下下载的这个hello-world镜像[root@Wang ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    feb5d9fea6a5   16 months ago   13.3kB\n\n了解：卸载 docker\n# 1、卸载依赖yum remove docker-ce docker-ce-cli containerd.io# 2、删除资源rm -rf /var/lib/docker\t# docker默认工作路径rm -rf /var/lib/containerd\n\nUbuntu 安装首先，更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源：\nsudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n\n使用下面的 curl 导入源仓库的 GPG key：\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n将 Docker APT 软件源添加到你的系统：\nsudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;\n\n安装 Docker 最新版本\nsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io\n\n一旦安装完成，Docker 服务将会自动启动。你可以输入下面的命令，验证它：\nsudo systemctl status docker# 结果如下：● docker.service - Docker Application Container Engine     Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)     Active: active (running) since Mon 2023-09-25 14:03:32 CST; 11s agoTriggeredBy: ● docker.socket       Docs: https://docs.docker.com   Main PID: 11678 (dockerd)      Tasks: 9     Memory: 26.4M     CGroup: /system.slice/docker.service             └─11678 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock\n\n阿里云镜像加速1、登录阿里云找到容器镜像服务 容器镜像服务 (aliyun.com)\n\n2、配置使用\nsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;粘贴自己的加速器地址&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker\n\n底层原理Docker 是怎么工作的？\nDocker 是一个 Client-Server 结构的系统，Docker 的守护进程运行在主机上，通过 Socket 从客户端访问！\nDockerServer 接受到 Docker-Client 的指令，就会执行这个命令！\nDocker-Compose# 1、下载docker-composesudo curl -SL \\https://gitee.com/smilezgy/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 \\-o /usr/local/bin/docker-compose# 2、添加可执行权限sudo chmod +x /usr/local/bin/docker-compose# 3、测试docker-compose --version\n\n删除：\nrm -rf /usr/local/bin/docker-compose\n\nDocker 基础命令设置开机自启并现在启动\nsudo systemctl enable docker --now\n\n帮助命令docker version\t\t# 显示docker版本信息docker info\t\t\t# 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help  # 帮助命令\n\n镜像命令**docker images ** 查看所有本地的主机上的镜像\n[root@Wang ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    feb5d9fea6a5   16 months ago   13.3kB# 解释REPOSITORY\t镜像的仓库源TAG\t\t\t镜像的标签IMAGE ID\t镜像的IDCREATED\t\t镜像的创建时间SIZE\t\t镜像的大小\n\ndocker search 搜索镜像\n[root@Wang ~]# docker search mysqlNAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql                           MySQL is a widely used, open-source relation…   13741     [OK]mariadb                         MariaDB Server is a high performing open sou…   5242      [OK]phpmyadmin                      phpMyAdmin - A web interface for MySQL and M…   727       [OK]percona                         Percona Server is a fork of the MySQL relati…   599       [OK]\n\ndocker pull 下载镜像\n# 下载镜像 docker pull 镜像名:tag[root@Wang ~]# docker pull mysql# 指定版本下载[root@Wang ~]# docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Pull complete93619dbc5b36: Pull complete99da31dd6142: Pull complete626033c43d70: Pull complete37d5d7efb64e: Pull completeac563158d721: Pull completed2ba16033dad: Pull complete0ceb82207cd7: Pull complete37f2405cae96: Pull completee2482e017e53: Pull complete70deed891d42: Pull completeDigest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7\n\ndocker rmi 删除镜像\ndocker rmi -f 镜像id\t\t# 删除指定的镜像docker rmi -f 镜像id 镜像id 镜像id 镜像id\t# 删除多个镜像[root@Wang ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEmysql         5.7       c20987f18b13   13 months ago   448MBhello-world   latest    feb5d9fea6a5   16 months ago   13.3kB# 删除hello-world 通过id删除[root@Wang ~]# docker rmi -f feb5d9fea6a5Untagged: hello-world:latestUntagged: hello-world@sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60fDeleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412\n\n容器命令说明：我们有了镜像才可以创建容器\ndocker pull centos\n\n新建镜像并启动\ndocker run [可选参数] image# 参数说明--name=&quot;Name&quot;\t容器名字 tomcat01 tomcat02，用来区分-d\t\t\t\t后台方式运行-it\t\t\t\t使用交互方式运行，进入容器查看内容-p\t\t\t\t指定容器的端口\t-p 8080:8080\t-p 主机端口:容器端口（常用）\t-p 容器端口-P\t\t\t\t随机指定端口# 测试，启动并进入容器[root@Wang ~]# docker run -it centos /bin/bash[root@a1afe9f99dd6 /]# ls\t# 查看容器内的centos，基本版本，很多命令不完善bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var# 从容器中退回主机[root@a1afe9f99dd6 /]# exitexit[root@Wang /]# lsbin   data  etc   lib    lost+found  mnt  patch  root  sbin  sys  usr  wwwboot  dev   home  lib64  media       opt  proc   run   srv   tmp  vardocker run -p 1234:1234 -it fed440038981 /bin/bashdocker exec -it 354e4cf9e32f /bin/bash\n\n列出所有的运行的容器\n# docker ps 命令-a\t# 列出当前正在运行的容器+带出历史运行过的容器[root@Wang ~]# docker ps -aCONTAINER ID   IMAGE          COMMAND       CREATED             STATUS                         PORTS     NAMESa1afe9f99dd6   centos         &quot;/bin/bash&quot;   About an hour ago   Exited (0) About an hour ago             flamboyant_booth904a45d59a92   feb5d9fea6a5   &quot;/hello&quot;      5 hours ago         Exited (0) 5 hours ago                   focused_lalande\n\n退出容器\nexit\t# 容器退出并停止Ctrl + P + Q\t# 容器不停止退出\n\n删除容器\ndocker rm 容器id\t# 删除指定的容器，不能删除正在运行的容器，如果强制删除 rm -fdocker rm -f $(docker ps -aq)\t# 删除所有的容器\n\n启动和停止容器的操作\ndocker start 容器id\t\t# 启动容器docker restart 容器id\t\t# 重启容器docker stop 容器id\t\t# 停止容器docker kill 容器id\t\t# 强制停止当前容器\n\n常用其他命令后台启动容器\n# 命令 docker run -d 镜像名[root@Wang ~]# docker run -d centos# 问题docker ps，发现centos停止了# 常见的坑，容器使用后台运行后，就必须要有一个前台进程，docker发现没有应用，就会自动停止# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了\n\n查看日志\ndocker logs -f -t --tail 容器\n\n查看容器中进程信息ps\ndocker top[root@Wang ~]# docker top 5cac1fea830f&#x27;UID\tPID\t\tPPID\tC\tSTIME\tTTY\t\tTIME\tCMDroot\t30121         30100         0          22:42               pts/0         00:00:00            /bin/bash\n\n查看镜像的元数据\n# 命令docker inspect 容器id[    &#123;        &quot;Id&quot;: &quot;88d23bcbe1f28e1f8ae5d2b63fa8d57d2abcbdacf193db05852f4f74a95b9ffe&quot;,        &quot;Created&quot;: &quot;2022-07-29T08:23:56.862239223Z&quot;,        &quot;Path&quot;: &quot;/bin/sh&quot;,        &quot;Args&quot;: [            &quot;-c&quot;,            &quot;while true;do echo kuangshen;sleep 1;done&quot;        ],        &quot;State&quot;: &#123;            &quot;Status&quot;: &quot;running&quot;,            &quot;Running&quot;: true,            &quot;Paused&quot;: false,            &quot;Restarting&quot;: false,            &quot;OOMKilled&quot;: false,            &quot;Dead&quot;: false,            &quot;Pid&quot;: 21212,            &quot;ExitCode&quot;: 0,            &quot;Error&quot;: &quot;&quot;,            &quot;StartedAt&quot;: &quot;2022-07-29T08:23:57.109766809Z&quot;,            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;        &#125;,        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/88d23bcbe1f28e1f8ae5d2b63fa8d57d2abcbdacf193db05852f4f74a95b9ffe/resolv.conf&quot;,        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/88d23bcbe1f28e1f8ae5d2b63fa8d57d2abcbdacf193db05852f4f74a95b9ffe/hostname&quot;,        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/88d23bcbe1f28e1f8ae5d2b63fa8d57d2abcbdacf193db05852f4f74a95b9ffe/hosts&quot;,        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/88d23bcbe1f28e1f8ae5d2b63fa8d57d2abcbdacf193db05852f4f74a95b9ffe/88d23bcbe1f28e1f8ae5d2b63fa8d57d2abcbdacf193db05852f4f74a95b9ffe-json.log&quot;,        &quot;Name&quot;: &quot;/silly_lichterman&quot;,        &quot;RestartCount&quot;: 0,        &quot;Driver&quot;: &quot;overlay2&quot;,        &quot;Platform&quot;: &quot;linux&quot;,        &quot;MountLabel&quot;: &quot;&quot;,        &quot;ProcessLabel&quot;: &quot;&quot;,        &quot;AppArmorProfile&quot;: &quot;&quot;,        &quot;ExecIDs&quot;: null,        &quot;HostConfig&quot;: &#123;            &quot;Binds&quot;: null,            &quot;ContainerIDFile&quot;: &quot;&quot;,            &quot;LogConfig&quot;: &#123;                &quot;Type&quot;: &quot;json-file&quot;,                &quot;Config&quot;: &#123;&#125;            &#125;,            &quot;NetworkMode&quot;: &quot;default&quot;,            &quot;PortBindings&quot;: &#123;&#125;,            &quot;RestartPolicy&quot;: &#123;                &quot;Name&quot;: &quot;no&quot;,                &quot;MaximumRetryCount&quot;: 0            &#125;,            &quot;AutoRemove&quot;: false,            &quot;VolumeDriver&quot;: &quot;&quot;,            &quot;VolumesFrom&quot;: null,            &quot;CapAdd&quot;: null,            &quot;CapDrop&quot;: null,            &quot;CgroupnsMode&quot;: &quot;host&quot;,            &quot;Dns&quot;: [],            &quot;DnsOptions&quot;: [],            &quot;DnsSearch&quot;: [],            &quot;ExtraHosts&quot;: null,            &quot;GroupAdd&quot;: null,            &quot;IpcMode&quot;: &quot;private&quot;,            &quot;Cgroup&quot;: &quot;&quot;,            &quot;Links&quot;: null,            &quot;OomScoreAdj&quot;: 0,            &quot;PidMode&quot;: &quot;&quot;,            &quot;Privileged&quot;: false,            &quot;PublishAllPorts&quot;: false,            &quot;ReadonlyRootfs&quot;: false,            &quot;SecurityOpt&quot;: null,            &quot;UTSMode&quot;: &quot;&quot;,            &quot;UsernsMode&quot;: &quot;&quot;,            &quot;ShmSize&quot;: 67108864,            &quot;Runtime&quot;: &quot;runc&quot;,            &quot;ConsoleSize&quot;: [                0,                0            ],            &quot;Isolation&quot;: &quot;&quot;,            &quot;CpuShares&quot;: 0,            &quot;Memory&quot;: 0,            &quot;NanoCpus&quot;: 0,            &quot;CgroupParent&quot;: &quot;&quot;,            &quot;BlkioWeight&quot;: 0,            &quot;BlkioWeightDevice&quot;: [],            &quot;BlkioDeviceReadBps&quot;: null,            &quot;BlkioDeviceWriteBps&quot;: null,            &quot;BlkioDeviceReadIOps&quot;: null,            &quot;BlkioDeviceWriteIOps&quot;: null,            &quot;CpuPeriod&quot;: 0,            &quot;CpuQuota&quot;: 0,            &quot;CpuRealtimePeriod&quot;: 0,            &quot;CpuRealtimeRuntime&quot;: 0,            &quot;CpusetCpus&quot;: &quot;&quot;,            &quot;CpusetMems&quot;: &quot;&quot;,            &quot;Devices&quot;: [],            &quot;DeviceCgroupRules&quot;: null,            &quot;DeviceRequests&quot;: null,            &quot;KernelMemory&quot;: 0,            &quot;KernelMemoryTCP&quot;: 0,            &quot;MemoryReservation&quot;: 0,            &quot;MemorySwap&quot;: 0,            &quot;MemorySwappiness&quot;: null,            &quot;OomKillDisable&quot;: false,            &quot;PidsLimit&quot;: null,            &quot;Ulimits&quot;: null,            &quot;CpuCount&quot;: 0,            &quot;CpuPercent&quot;: 0,            &quot;IOMaximumIOps&quot;: 0,            &quot;IOMaximumBandwidth&quot;: 0,            &quot;MaskedPaths&quot;: [                &quot;/proc/asound&quot;,                &quot;/proc/acpi&quot;,                &quot;/proc/kcore&quot;,                &quot;/proc/keys&quot;,                &quot;/proc/latency_stats&quot;,                &quot;/proc/timer_list&quot;,                &quot;/proc/timer_stats&quot;,                &quot;/proc/sched_debug&quot;,                &quot;/proc/scsi&quot;,                &quot;/sys/firmware&quot;            ],            &quot;ReadonlyPaths&quot;: [                &quot;/proc/bus&quot;,                &quot;/proc/fs&quot;,                &quot;/proc/irq&quot;,                &quot;/proc/sys&quot;,                &quot;/proc/sysrq-trigger&quot;            ]        &#125;,        &quot;GraphDriver&quot;: &#123;            &quot;Data&quot;: &#123;                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/59b088d44f6e67f4ed336de44d19a5784c1a13fa856760bd2b166c4a4d421e2b-init/diff:/var/lib/docker/overlay2/7fc43e24b63e4656ab7e7718d3e4ef5297fe82509452be305a01605a7cdc3b97/diff&quot;,                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/59b088d44f6e67f4ed336de44d19a5784c1a13fa856760bd2b166c4a4d421e2b/merged&quot;,                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/59b088d44f6e67f4ed336de44d19a5784c1a13fa856760bd2b166c4a4d421e2b/diff&quot;,                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/59b088d44f6e67f4ed336de44d19a5784c1a13fa856760bd2b166c4a4d421e2b/work&quot;            &#125;,            &quot;Name&quot;: &quot;overlay2&quot;        &#125;,        &quot;Mounts&quot;: [],        &quot;Config&quot;: &#123;            &quot;Hostname&quot;: &quot;88d23bcbe1f2&quot;,            &quot;Domainname&quot;: &quot;&quot;,            &quot;User&quot;: &quot;&quot;,            &quot;AttachStdin&quot;: false,            &quot;AttachStdout&quot;: false,            &quot;AttachStderr&quot;: false,            &quot;Tty&quot;: false,            &quot;OpenStdin&quot;: false,            &quot;StdinOnce&quot;: false,            &quot;Env&quot;: [                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;            ],            &quot;Cmd&quot;: [                &quot;/bin/sh&quot;,                &quot;-c&quot;,                &quot;while true;do echo kuangshen;sleep 1;done&quot;            ],            &quot;Image&quot;: &quot;centos&quot;,            &quot;Volumes&quot;: null,            &quot;WorkingDir&quot;: &quot;&quot;,            &quot;Entrypoint&quot;: null,            &quot;OnBuild&quot;: null,            &quot;Labels&quot;: &#123;                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;            &#125;        &#125;,        &quot;NetworkSettings&quot;: &#123;            &quot;Bridge&quot;: &quot;&quot;,            &quot;SandboxID&quot;: &quot;bfc28d2ba671adfe5c93325173b93c335d50d8b017eed4fdce2ab75410d6ac2e&quot;,            &quot;HairpinMode&quot;: false,            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,            &quot;LinkLocalIPv6PrefixLen&quot;: 0,            &quot;Ports&quot;: &#123;&#125;,            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/bfc28d2ba671&quot;,            &quot;SecondaryIPAddresses&quot;: null,            &quot;SecondaryIPv6Addresses&quot;: null,            &quot;EndpointID&quot;: &quot;ad0252d454e751e2c5ecef24e64c32b0884c53242925bd66e9e5dbf5542af179&quot;,            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,            &quot;GlobalIPv6Address&quot;: &quot;&quot;,            &quot;GlobalIPv6PrefixLen&quot;: 0,            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,            &quot;IPPrefixLen&quot;: 16,            &quot;IPv6Gateway&quot;: &quot;&quot;,            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,            &quot;Networks&quot;: &#123;                &quot;bridge&quot;: &#123;                    &quot;IPAMConfig&quot;: null,                    &quot;Links&quot;: null,                    &quot;Aliases&quot;: null,                    &quot;NetworkID&quot;: &quot;7254ffccbdf53e0c72c1d19252980f04fa65153ea3c7ca72af55cfac504cbe3f&quot;,                    &quot;EndpointID&quot;: &quot;ad0252d454e751e2c5ecef24e64c32b0884c53242925bd66e9e5dbf5542af179&quot;,                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,                    &quot;IPPrefixLen&quot;: 16,                    &quot;IPv6Gateway&quot;: &quot;&quot;,                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,                    &quot;GlobalIPv6PrefixLen&quot;: 0,                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,                    &quot;DriverOpts&quot;: null                &#125;            &#125;        &#125;    &#125;]\n\n进入当前正在运行的容器\n# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置# 命令# 方法一docker exec -it 容器id /bin/bash# 测试[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES88d23bcbe1f2   centos    &quot;/bin/sh -c &#x27;while t…&quot;   13 minutes ago   Up 13 minutes             silly_lichterman[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it 88d23bcbe1f2 /bin/bash[root@88d23bcbe1f2 /]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 08:23 ?        00:00:00 /bin/sh -c while true;do echo kuangshen;sleep 1;doneroot       841     0  0 08:37 pts/0    00:00:00 /bin/bashroot       858     1  0 08:37 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1root       859   841  0 08:37 pts/0    00:00:00 ps -ef# 方式二docker attach 容器id# 测试[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker attach 88d23bcbe1f2正在执行当前的代码...# docker exec        # 进入容器后开启一个新的终端，可以再里面操作（常用）# docker attach        # 进入容器正在执行的终端，不会启动新的进程。\n\n从容器内拷文件到主机上\ndocker cp 容器id:容器内路径 目的主机的路径# 进入到容器内部[root@iZbp13qr3mm4ucsjumrlgqZ home]# docker attach 6eda31ad7987[root@6eda31ad7987 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@6eda31ad7987 /]# cd /home/[root@6eda31ad7987 home]# ls# 在容器的/home路径下创建test.java文件[root@6eda31ad7987 home]# touch test.java[root@6eda31ad7987 home]# lstest.java[root@6eda31ad7987 home]# exitexit[root@iZbp13qr3mm4ucsjumrlgqZ home]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@iZbp13qr3mm4ucsjumrlgqZ home]# docker ps -aCONTAINER ID   IMAGE     COMMAND       CREATED              STATUS                      PORTS     NAMES6eda31ad7987   centos    &quot;/bin/bash&quot;   About a minute ago   Exited (0) 28 seconds ago             stoic_kepler# 将文件拷贝出来到主机上（在主机上执行该命令）[root@iZbp13qr3mm4ucsjumrlgqZ home]# docker cp 6eda31ad7987:/home/test.java /home[root@iZbp13qr3mm4ucsjumrlgqZ home]# lstest.java# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现，自动同步（容器内的/home路径和主机上的/home路径打通）\n\nDocker 进阶数据卷 Volume为容器提供持久化的数据存储，并实现容器之间的数据共享。数据卷独立于容器的生命周期，即使删除容器，数据卷依然会保留，其内容不会丢失。因此，数据卷为容器提供了稳定的数据存储解决方案，有助于实现数据的持久化和跨容器共享。绑定方式有：匿名绑定，具名绑定，Bind Mount。\n匿名绑定docker run -d -p 80:80 --name nginx_volume -v /usr/share/nginx/html nginx\n\n我们通过-v来绑定数据，但没有写本次的位置，所以想要查看，使用docker inspect nginx_volume，查看容器信息，在信息中，找到Mounts：\n\n但是，当我们删除容器后，文件消失\n具名绑定docker run -d -p 80:80 --name nginx_volume -v 绑定名:容器内的位置 nginx例如：docker run -d -p 80:80 --name nginx_volume -v nginx:/usr/share/nginx/html nginx\n\nBind Mount（推荐）绑定并加载主机的某个文件目录到容器中，这种也是最常见用的，在容器启动时使用：-v host dir:container_dir\ndocker run -d -p 80:80 --name nginx_volume -v /workspace/nginx:/usr/share/nginx/html nginx\n\n网络 Networkbridge(桥接) [默认]在主机中创建一个Docker0的虚拟网桥，在Docker0创建一对虚拟网卡，一半在主机上vethxxx，一半在容器内eth0\n\nHost 模式host 模式，也称为NAT 模式，允许 Docker 容器直接访问宿主机的网络，包括 IP 地址和端口。\nNone 模式Docker 会拥有自己的网络区间，不与主机共享，在这个网络模式下的容器，不会分配网卡、ip、路由等相关信息。\n特点：完全隔离，与外部任何机器都无网络访问，只有自己的本地网络：127.0.0.1\n自定义模式（推荐）不使用 docker 自带的网络模式，而是自己去定制化自己特有的网络模式\n命令： docker network COMMAND，例如：\n# 创建一个容器docker network create my_network#运行一个容器并连接到新创建的网络docker run --name my_ngingx --network my_network -d nginx:latest# 列出 Docker 网络docker network ls# 检查容器已连接到哪个网络docker network inspect my_network# 删除 Docker 网络docker network rm my_network\n\nDockerfileDocker 为我们创建一个自定义构建镜像的一个配置文件：描述如何创建一个对象\n首先需要介绍两个命令：commit、build\nDocker 的commit命令用于从容器创建一个新的镜像。当你对容器进行了一些更改（例如安装了新的软件包、修改了文件等），并希望将这些更改保存为一个新的镜像时，可以使用commit命令。\n# 格式docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]# 例如：docker commit -a &quot;wang&quot; -m &quot;my nginx container&quot; nginx_commit my_nginx:1\n\n\n-a：作者名\n-m：指定新镜像的提交消息\nnginx_commit my_nginx:1 ：nginx_commit 是正在运行的容器，my_nginx 为镜像名，：后面为版本号\n\n\n常用指令包括：FROM ,MAINTAINER,LABEL,ENV,RUN,ADD,WORKDIR, VOLUME,EXPOSE,CMD, ENTRYPOINT\n# 1. 先指定当前镜像的基础镜像是什么FROM openjdk:8# 2. 描述这个镜像的作者，以及联系方式（可选）MAINTAINER wangweijun&lt;wangweijun2001@qq.com&gt;# 3. 镜像的标签信息（可选）LABEL version=&quot;1.0&quot;LABEL description=&quot;这是一个Dockerfile&quot;# 4. 环境变量配置（2种写法）ENV JAVA_ENV devENV APP_NAME test-dockerfile# ENV JAVA_ENV=dev APP_NAME=test-dockerfile# 5. 在构建镜像时，需要执行的shell命令RUN ls -alRUN mkdir /www/dockerfile/test# 6. 将主机的指定文件复制到容器的目标位置（两种写法）# ADD /workspace/index.html /www/serverADD [&quot;/workspace/index.html&quot;, &quot;/www/server&quot;]# 7. 设置容器中的工作目录，如果该目录不存在，会自己创建WORKDIR /workspace# 8. 镜像数据卷绑定，将主机中的指定目录挂在到容器中VOLUME [&quot;/workspace&quot;]# 9. 设置容器启动后要暴露的端口EXPOSE 8080# CMD 和 ENTRYPOINT 选择其一即可，作用是描述镜像构建完成后，启动容器时默认执行的脚本# CMD ping 127.0.0.1#CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;ping 127.0.0.1&quot;]# ENTRYPOINT ping 127.0.0.1ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;ping 127.0.0.1&quot;]\n\n扩展指令\nARG：设置变量，格式 &gt; ARG &lt;name&gt;&#x3D;[defualt value]\nARG jdk=8FROM openjdk:$jdk\n\nUSER：设置容器的用户，可以使用用户名或 UID\nUSER &lt;username&gt;# 提前添加用户RUN adminUSER admin\n\nONBUILD：指令会在子镜像的构建过程中执行。\nSTOPSIGNAL：指令设置将发送到容器的系统调用信号以退出。\nHEALTHCHECK：容器健康检查，可以定期检查容器当前的健康状况。\n安装软件安装 nginx下载镜像：pull\ndocker pull ngin\n\n启动 nginx\n# -d 后台运行# --name=&quot;ngin&quot;    给容器命名# -p 宿主机端口:容器内部端口[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker run -d --name nginx -p 3344:80 nginx6e02190a50bc8d79653ffa88f6b5c143d79c5ac3257d5d5ed6a01247980fb48a[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES6e02190a50bc   nginx     &quot;/docker-entrypoint.…&quot;   18 seconds ago   Up 17 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx-1# 进入容器[root@iZbp13qr3mm4ucsjumrlgqZ ~]# docker exec -it a1e130aa184d /bin/bashroot@a1e130aa184d:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@a1e130aa184d:/# cd /etc/nginx/root@a1e130aa184d:/etc/nginx# lsconf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params\n\n本机测试\n[root@Wang ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n安装 MySQL本次安装为 MySQL:5.7，先拉取 5.7 版本的镜像\ndocker pull mysql:5.7\n\n运行镜像，暴露端口，并且设置root用户的密码：\ndocker run -d --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7\n\n这样 MySQL 就安装好了，但是当我们远程连接时，会报错，需要设置root用户可以远程访问：\n\n进入容器内部\n\ndocker exec -it mysql /bin/bash\n\n\n切换到 root 用户\n\nmysql -u root -p\n\n\n为 root 用户创建一个远程访问的授权\n\nGRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;your_password&#x27; WITH GRANT OPTION;\n\n其中，**%表示允许任何远程主机访问，你也可以将其替换为特定的 IP 地址或主机名。your_password是root 用户**的密码，请将其替换为实际的密码。\n\n刷新权限\n\nFLUSH PRIVILEGES;\n\n\nMySQL 命令行\n\nexit\n\n\n这个时候就可以成功了：\n\n安装 Redis首先拉取 Redis 的镜像\ndocker pull redis\n\n然后创建Redis外部配置文件\n# 创建目录mkdir -p /mydata/redis/conf# 创建文件touch /mydata/redis/conf/redis.conf\n\n创建redis容器并启动\ndocker run -d --name redis -p 6379:6379 --restart unless-stopped -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf redis redis-server /etc/redis/redis.conf\n\n\n\n\n命令\n描述\n\n\n\n–name redis\n启动容器的名字\n\n\n-d\n后台运行\n\n\n-p 6379:6379\n将容器的 6379(后面那个) 端口映射到主机的 6379(前面那个) 端口\n\n\n–restart unless-stopped\n容器重启策略\n\n\n-v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data\n将 Redis 储存文件夹挂在到主机\n\n\n-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf\n将配置文件夹挂在到主机\n\n\nredis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf\nRedis 容器中设置 redis-server 每次启动读取 &#x2F;etc&#x2F;redis&#x2F;redis.conf 这个配置为准\n\n\n–restart unless-stopped : 在 docker 重启时重启当前容器。但不包含 docker 重启时已停止的容器。\nRedis 配置文件修改\n修改 &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf\n","categories":["技术栈"],"tags":["Docker"]},{"title":"Electron框架","url":"/2023/10/10/Electron/","content":"Electron官方地址：Electron (electronjs.org)\nElectron介绍Electron是GitHub开发的一个开源框架。它通过使用Node.js和Chromium的渲染引擎完成跨平台的桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端与后端的开发，著名项目包括GitHub的Atom和微软的Visual Studio Code。\n安装Electronnpm install electron  # 国内可能会失败，推荐下面的cnpm install electron# 建议全局安装npm install -g electroncnpm install -g electron # 推荐# 查看electron版本electron -v\n\n\n\n初始化项目\n官方的快速开始\n通过使用Electron创建一个极简的 Hello World 应用一步步的带你了解，该应用与electron/electron-quick-start类似。\n# Clone this repositorygit clone https://github.com/electron/electron-quick-start# Go into the repositorycd electron-quick-start# Install dependenciesnpm installcnpm install # 推荐# Run the appnpm start\n\n启动后，就可以看到初始的GUI了\n\n\n自建项目\n在空文件夹中，使用npm初始化项目npm init，流程如下：\nnpm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help init` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (electron) electronversion: (1.0.0) 1.0.0description: electron初始化项目entry point: (index.js) main.jstest command:git repository:keywords:author: wjwanglicense: (ISC)About to write to C:\\Users\\Admin\\Desktop\\electron\\package.json:&#123;  &quot;name&quot;: &quot;electron&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;electron初始化项目&quot;,  &quot;main&quot;: &quot;main.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;author&quot;: &quot;wjwang&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;Is this OK? (yes) yes\n\n进入项目，安装electron：\nnpm install electron# 如果报错，使用cnpmcnpm install electron\n\n安装成功后，在package.json中，编写electron启动命令electron .：\n&#123;  &quot;name&quot;: &quot;electron&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;electron初始化项目&quot;,  &quot;main&quot;: &quot;main.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;electron .&quot;  &#125;,  &quot;author&quot;: &quot;wjwang&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: &#123;    &quot;electron&quot;: &quot;^27.0.0&quot;  &#125;&#125;\n\n新建main.js，编写一个简单的Hello World\nconst &#123;app, BrowserWindow&#125; = require(&#x27;electron&#x27;)// 创建窗口function createWindow() &#123;    let mainWin = new BrowserWindow(&#123;        show: false,        width: 800,        height: 600,        title: &quot;Hello World&quot;,    &#125;);    mainWin.loadFile(&#x27;index.html&#x27;);    mainWin.on(&#x27;close&#x27;, () =&gt; &#123;        console.log(&#x27;close&#x27;)        mainWin = null    &#125;)&#125;app.on(&#x27;ready&#x27;, createWindow);app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123;    app.quit()&#125;);\n\n还需要创建一个index.html,\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;a href=&quot;https://junyyds.top/2023/10/10/Electron/&quot;&gt;跳转到Electron学习小站&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\n\n之后就可以启动了，使用npm start。\n\n\n初级教程设置窗口new BrowserWindow([options])\noptions 浏览器窗口构造函数选项（可选）\n\nwidth 整数（可选）- 窗口的宽度（以像素为单位）。 默认为 800。\n\nheight 整数（可选）- 窗口的高度（以像素为单位）。 默认为 600。\n\nx 整数（可选）-（如果使用 y，则为 required）窗口距屏幕的左侧偏移量。 默认是将窗口居中。\n\ny 整数（可选）-（如果使用 x，则为 required）窗口距屏幕的顶部偏移量。 默认是将窗口居中。\n\nuseContentSize 布尔值（可选）- width 和 height 将用作网页大小，这意味着实际窗口的大小将包括窗口框架的大小并稍大一些。 默认为 false。\n\ncenter 布尔值（可选）- 在屏幕中央显示窗口。 默认为 false。\n\nminWidth 整数（可选）- 窗口的最小宽度。 默认为 0。\n\nminHeight 整数（可选）- 窗口的最小高度。 默认为 0。\n\nmaxWidth 整数（可选）- 窗口的最大宽度。 默认没有限制。\n\nmaxHeight 整数（可选）- 窗口的最大高度。 默认没有限制。\n\nresizable 布尔值（可选）- 窗口是否可调整大小。 默认为 true。\n\nmovable 布尔值（可选） macOS Windows - 窗口是否可移动。 这在 Linux 上没有实现。 默认为 true。\n\nminimizable 布尔值（可选） macOS Windows - 窗口是否可最小化。 这在 Linux 上没有实现。 默认为 true。\n\nmaximizable 布尔值（可选） macOS Windows - 窗口是否可最大化。 这在 Linux 上没有实现。 默认为 true。\n\nclosable 布尔值（可选） macOS Windows - 窗口是否可关闭。 这在 Linux 上没有实现。 默认为 true。\n\nfocusable 布尔值（可选）- 窗口是否可以聚焦。 默认为 true。 在 Windows 上，设置 focusable: false 也意味着设置 skipTaskbar: true。 在 Linux 上，设置 focusable: false 使窗口停止与 wm 交互，因此窗口将始终位于所有工作区的顶部。\n\nalwaysOnTop 布尔值（可选）- 窗口是否应始终位于其他窗口之上。 默认为 false。\n\nfullscreen 布尔值（可选）- 窗口是否应全屏显示。 当明确设置为 false 时，全屏按钮将在 macOS 上隐藏或禁用。 默认为 false。\n\nfullscreenable 布尔值（可选）- 窗口是否可以进入全屏模式。 在 macOS 上，还包括最大化&#x2F;缩放按钮是否应切换全屏模式或最大化窗口。 默认为 true。\n\nsimpleFullscreen 布尔值（可选） macOS - 在 macOS 上使用 pre-Lion 全屏。 默认为 false。\n\nskipTaskbar 布尔值（可选） macOS Windows - 是否在任务栏中显示窗口。 默认为 false。\n\nhiddenInMissionControl 布尔值（可选） macOS - 当用户切换到任务控制时是否应隐藏窗口。\n\nkiosk 布尔值（可选）- 窗口是否处于 kiosk 模式。 默认为 false。\n\ntitle 字符串（可选）- 默认窗口标题。 默认为 &quot;Electron&quot;。 如果 loadURL() 加载的 HTML 文件中定义了 HTML 标签 &lt;title&gt;，则该属性将被忽略。\n\nicon（NativeImage） | string) (可选) - 窗口图标。 在 Windows 上，建议使用 ICO 图标以获得最佳视觉效果，你也可以将其保留为未定义，以便使用可执行文件的图标。\n\nshow 布尔值（可选）- 创建窗口时是否应显示。 默认为 true。\n\npaintWhenInitiallyHidden 布尔值（可选）- 当 show 为 false 并且刚刚创建时，渲染器是否应处于活动状态。 为了使 document.visibilityState 在第一次加载 show: false 时能够正常工作，你应该将其设置为 false。 将其设置为 false 将导致 ready-to-show 事件不触发。 默认为 true。\n\nframe 布尔值（可选）- 指定 false 以创建 无框窗。 默认为 true。\n\nparent BrowserWindow（可选）- 指定父窗口。 默认为 null。\n\nmodal 布尔值（可选）- 这是否是模式窗口。 仅当窗口是子窗口时才有效。 默认为 false。\n\nacceptFirstMouse 布尔值（可选） macOS - 单击非活动窗口是否也会单击进入 Web 内容。 macOS 上的默认值为 false。 此选项在其他平台上不可配置。\n\ndisableAutoHideCursor 布尔值（可选）- 键入时是否隐藏光标。 默认为 false。\n\nautoHideMenuBar 布尔值（可选）- 自动隐藏菜单栏，除非按下 Alt 键。 默认为 false。\n\nenableLargerThanScreen 布尔值（可选） macOS - 允许将窗口大小调整为大于屏幕。 仅与 macOS 相关，因为其他操作系统默认允许大于屏幕的窗口。 默认为 false。\n\nbackgroundColor 字符串（可选）- 窗口的背景颜色，采用 Hex、RGB、RGBA、HSL、HSLA 或命名的 CSS 颜色格式。 如果 transparent 设置为 true，则支持 #AARRGGBB 格式的 Alpha。 默认为 #FFF（白色）。 请参阅 win.setBackgroundColor 了解更多信息。\n\nhasShadow 布尔值（可选）- 窗口是否应该有阴影。 默认为 true。\n\nopacity 数字（可选） macOS Windows - 设置窗口的初始不透明度，介于 0.0（完全透明）和 1.0（完全不透明）之间。 这仅在 Windows 和 macOS 上实现。\n\ndarkTheme 布尔值（可选）- 强制窗口使用深色主题，仅适用于某些 GTK+3 桌面环境。 默认为 false。\n\ntransparent 布尔值（可选）- 使窗口为 transparent。 默认为 false。 在 Windows 上，除非窗口是无框的，否则不起作用。\n\ntype string (可选) - 窗口类型，默认为普通窗口。 请参阅下文了解更多相关信息。\n\nvisualEffectState字符串（可选）macOS - 指定材质外观应如何反映 macOS 上的窗口活动状态。 必需vibrancy\n 属性一起使用。 可能的值为：\n\nfollowWindow - 当窗口处于活动状态时，背景应自动显示为活动状态，而当窗口处于非活动状态时，背景应自动显示为非活动状态。 这是默认设置。\nactive - 背景应该始终显示为活动状态。\ninactive - 背景应该始终显示为非活动状态。\n\n\ntitleBarStyle字符串（可选） macOS Windows - 窗口标题栏的样式。 默认为 default。 可能的值为：\n\ndefault - 分别产生 macOS 或 Windows 的标准标题栏。\nhidden - 结果是隐藏的标题栏和全尺寸的内容窗口。 在 macOS 上，窗口的左上角仍具有标准窗口控件 (“红绿灯”)。 在 Windows 上，当与 titleBarOverlay: true 结合使用时，它将激活窗口控件覆盖（有关详细信息，请参阅 titleBarOverlay），否则将不会显示任何窗口控件。\nhiddenInset macOS - 仅在 macOS 上，会导致隐藏的标题栏具有另一种外观，其中交通灯按钮从窗口边缘稍微内嵌。\ncustomButtonsOnHover macOS - 仅在 macOS 上，导致隐藏标题栏和全尺寸内容窗口，将鼠标悬停在窗口左上角时将显示交通灯按钮。 注意： 此选项目前处于实验阶段。\n\n\ntrafficLightPosition 观点（可选）macOS - 在无框窗口中设置交通灯按钮的自定义位置。\n\nroundedCorners 布尔值（可选） macOS - 无框窗口在 macOS 上是否应具有圆角。 默认为 true。 将此属性设置为 false 将阻止窗口全屏显示。\n\nfullscreenWindowTitle 布尔值（可选） macOS 已弃用 - 在 macOS 上以全屏模式在标题栏中显示 hiddenInset titleBarStyle 的标题。 默认为 false。\n\nthickFrame 布尔值（可选）- 在 Windows 上为无框窗口使用 WS_THICKFRAME 样式，这会添加标准窗框。 将其设置为 false 将删除窗口阴影和窗口动画。 默认为 true。\n\nvibrancy 字符串（可选） macOS - 向窗口添加一种活力效果，仅在 macOS 上。 可以是 appearance-based、titlebar、selection、menu、popover、sidebar、header、sheet、window、hud、fullscreen-ui、tooltip、content、under-window 或 under-page。\n\nbackgroundMaterial 字符串（可选） Windows - 设置窗口的系统绘制背景材料，包括非客户区后面。 可以是 auto、none、mica、acrylic 或 tabbed。 请参阅 win.setBackgroundMaterial 了解更多信息。\n\nzoomToPageWidth 布尔值（可选） macOS - 控制按住 Option 键单击工具栏上的绿色红绿灯按钮或单击“窗口”&gt;“缩放”菜单项时 macOS 上的行为。 如果是 true，则窗口在缩放时将增长到网页的首选宽度，false 将使其缩放到屏幕的宽度。 这也会影响直接调用 maximize() 时的行为。 默认为 false。\n\ntabbingIdentifier 字符串（可选）macOS - 选项卡组名称，允许将窗口作为原生选项卡打开。 具有相同选项卡标识符的窗口将被分组在一起。 这还会向窗口的选项卡栏添加一个原生新选项卡按钮，并允许 app 和窗口接收 new-window-for-tab 事件。\n\nwebPreferences（可选）- 网页功能设置。\n\ndevTools 布尔值（可选）- 是否启用 DevTools。 如果设置为 false，则无法使用 BrowserWindow.webContents.openDevTools() 打开 DevTools。 默认为 true。\nnodeIntegration 布尔值（可选）- 是否启用节点集成。 默认为 false。\nnodeIntegrationInWorker 布尔值（可选）- 是否在 Web Worker 中启用节点集成。 默认为 false。 有关此内容的更多信息，请参阅 多线程。\nnodeIntegrationInSubFrames 布尔值（可选）- 在 iframe 和子窗口等子框架中启用 Node.js 支持的实验选项。 你的所有预加载将为每个 iframe 加载，你可以使用 process.isMainFrame 来确定你是否在主框架中。\npreload 字符串（可选）- 指定将在页面中运行其他脚本之前加载的脚本。 无论节点集成是打开还是关闭，该脚本始终可以访问 Node API。 该值应该是脚本的绝对文件路径。 当节点集成关闭时，预加载脚本可以将节点全局符号重新引入全局作用域。 参见示例 here。\nsandbox 布尔值（可选）- 如果设置，这将沙箱与窗口关联的渲染器，使其与 Chromium 操作系统级沙箱兼容并禁用 Node.js 引擎。 这与 nodeIntegration 选项不同，预加载脚本可用的 API 更加有限。 了解有关选项 here 的更多信息。\nsession 会议（可选）- 设置页面使用的会话。 你还可以选择使用接受分区字符串的 partition 选项，而不是直接传递 Session 对象。 当同时提供 session 和 partition 时，优先选择 session。 默认是默认会话。\npartition 字符串（可选）- 根据会话的分区字符串设置页面使用的会话。 如果 partition 以 persist: 开头，则页面将使用可用于应用中具有相同 partition 的所有页面的持久会话。 如果没有 persist: 前缀，页面将使用内存中会话。 通过分配相同的 partition，多个页面可以共享同一个会话。 默认是默认会话。\nzoomFactor 数字（可选）-页面的默认缩放系数，3.0 代表 300%。 默认为 1.0。\njavascript 布尔值（可选）- 启用 JavaScript 支持。 默认为 true。\nwebSecurity boolean (可选) - 当 false 时，它将禁用同源策略（通常由人们使用测试网站），如果用户未设置此选项，则将 allowRunningInsecureContent 设置为 true。 默认为 true。\nallowRunningInsecureContent 布尔值（可选）- 允许 https 页面从 http URL 运行 JavaScript、CSS 或插件。 默认为 false。\nimages 布尔值（可选）- 启用图片支持。 默认为 true。\nimageAnimationPolicy 字符串（可选）- 指定如何运行图片动画（例如 GIF）。 可以是 animate、animateOnce 或 noAnimation。 默认为 animate。\ntextAreasAreResizable 布尔值（可选）- 使 TextArea 元素可调整大小。 默认为 true。\nwebgl 布尔值（可选）- 启用 WebGL 支持。 默认为 true。\nplugins 布尔值（可选）- 是否应启用插件。 默认为 false。\nexperimentalFeatures 布尔值（可选）- 启用 Chromium 的实验性功能。 默认为 false。\nscrollBounce 布尔值（可选）macOS - 在 macOS 上启用滚动弹跳（橡皮筋）效果。 默认为 false。\nenableBlinkFeatures 字符串（可选）- 由 , 分隔的功能字符串列表，如要启用的 CSSVariables,KeyboardEventKey。 支持的功能字符串的完整列表可以在 RuntimeEnabledFeatures.json5 文件中找到。\ndisableBlinkFeatures 字符串（可选）- 由 , 分隔的功能字符串列表，例如要禁用的 CSSVariables,KeyboardEventKey。 支持的功能字符串的完整列表可以在 RuntimeEnabledFeatures.json5 文件中找到。\ndefaultFontFamily对象（可选）- 设置字体系列的默认字体。\nstandard 字符串（可选）- 默认为 Times New Roman。\nserif 字符串（可选）- 默认为 Times New Roman。\nsansSerif 字符串（可选）- 默认为 Arial。\nmonospace 字符串（可选）- 默认为 Courier New。\ncursive 字符串（可选）- 默认为 Script。\nfantasy 字符串（可选）- 默认为 Impact。\nmath 字符串（可选）- 默认为 Latin Modern Math。\n\n\ndefaultFontSize 整数（可选）- 默认为 16。\ndefaultMonospaceFontSize 整数（可选）- 默认为 13。\nminimumFontSize 整数（可选）- 默认为 0。\ndefaultEncoding 字符串（可选）- 默认为 ISO-8859-1。\nbackgroundThrottling 布尔值（可选）- 当页面变为背景时是否限制动画和计时器。 这也影响了 页面可见性 API。 默认为 true。\noffscreen 布尔值（可选）- 是否为浏览器窗口启用离屏渲染。 默认为 false。 有关详细信息，请参阅 离屏渲染教程。\ncontextIsolation 布尔值（可选）- 是否在单独的 JavaScript 上下文中运行 Electron API 和指定的 preload 脚本。 默认为 true。 preload 脚本运行的上下文只能访问其自己专用的 document 和 window 全局变量，以及其自己的一组 JavaScript 内置函数（Array、Object、JSON 等），这些对加载的内容都是不可见的。 Electron API 仅在 preload 脚本中可用，在加载的页面中不可用。 加载潜在不受信任的远程内容时应使用此选项，以确保加载的内容不会篡改 preload 脚本和正在使用的任何 Electron API。 此选项使用与 Chrome 内容脚本 使用的技术相同的技术。 你可以通过在控制台选项卡顶部的组合框中选择 ‘Electron Isolated Context’ 条目来在开发工具中访问此上下文。\nwebviewTag 布尔值（可选）- 是否启用 **&lt;webview&gt;标签**默认为 false。 注意： 为 &lt;webview&gt; 配置的 preload 脚本在执行时将启用节点集成，因此你应确保远程&#x2F;不受信任的内容无法使用可能是恶意的 preload 脚本创建 &lt;webview&gt; 标记。 你可以使用 webContents 上的 will-attach-webview 事件来删除 preload 脚本并验证或更改 &lt;webview&gt; 的初始设置。\nadditionalArguments string[]（可选）- 将在此应用的渲染器进程中附加到 process.argv 的字符串列表。 对于将少量数据传递到渲染器进程预加载脚本非常有用。\nsafeDialogs boolean (可选) - 是否启用浏览器风格的连续对话框保护。 默认为 false。\nsafeDialogsMessage 字符串（可选）- 触发连续对话保护时显示的消息。 如果未定义，将使用默认消息，请注意，当前默认消息是英文且未本地化。\ndisableDialogs 布尔值（可选）- 是否完全禁用对话框。 覆盖 safeDialogs。 默认为 false。\nnavigateOnDragDrop 布尔值（可选）- 将文件或链接拖放到页面上是否会导致导航。 默认为 false。\nautoplayPolicy 字符串（可选）- 应用于窗口中内容的自动播放策略，可以是 no-user-gesture-required、user-gesture-required、document-user-activation-required。 默认为 no-user-gesture-required。\ndisableHtmlFullscreenWindowResize 布尔值（可选）- 进入 HTML 全屏时是否阻止窗口调整大小。 默认为 false。\naccessibleTitle 字符串（可选）- 仅提供给屏幕阅读器等辅助工具的替代标题字符串。 用户不能直接看到该字符串。\nspellcheck 布尔值（可选）- 是否启用内置拼写检查器。 默认为 true。\nenableWebSQL 布尔值（可选）- 是否启用 WebSQL API。 默认为 true。\nv8CacheOptions 字符串（可选）- 强制执行 Blink 使用的 v8 代码缓存策略。 接受的值为\nnone - 禁用代码缓存\ncode - 基于启发式的代码缓存\nbypassHeatCheck - 绕过代码缓存启发式但使用惰性编译\nbypassHeatCheckAndEagerCompile - 与上面相同，只是编译是预先的。 默认策略是 code。\n\n\nenablePreferredSizeMode 布尔值（可选）- 是否启用首选尺寸模式。 首选尺寸是包含文档布局所需的最小尺寸—无需滚动。 启用此选项将导致当首选大小更改时在 WebContents 上发出 preferred-size-changed 事件。 默认为 false。\n\n\ntitleBarOverlay目的 | 布尔值（可选）- 当在 macOS 上将无框窗口win.setWindowButtonVisibility(true)结合使用或使用titleBarStyle以使标准窗口控件（macOS 上的 “红绿灯”）可见时，此属性将启用窗口控件覆盖JavaScript API和CSS 环境变量。 指定true将导致使用默认系统颜色进行叠加。 默认为false。\n\ncolor 字符串（可选） Windows - 启用时窗口控件覆盖的 CSS 颜色。 默认为系统颜色。\nsymbolColor 字符串（可选） Windows - 启用后窗口控件覆盖上符号的 CSS 颜色。 默认为系统颜色。\nheight 整数（可选） macOS Windows - 标题栏和窗口控件叠加层的高度（以像素为单位）。 默认为系统高度。\n\n\n\n","categories":["高级语言"],"tags":["electron","nodejs"]},{"title":"Flask框架","url":"/2023/05/23/Flask%E6%A1%86%E6%9E%B6/","content":"Flask 框架安装pip install Flask\n\nHello World\nfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello_world():    return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n路由跳转路由变量规则 &lt;&gt;：提取参数\nfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def hello_world():    return &quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;@app.route(&quot;/chat/&lt;int:id&gt;&quot;)def chat(id):    if id == 1:        return &#x27;python&#x27;    if id == 2:        return &#x27;JAVA&#x27;    return &#x27;chat&#x27;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n当访问http://127.0.0.1:5000/chat/1会返回python，http://127.0.0.1:5000/chat/2会返回JAVA\n**&lt;int:id&gt;**可接收不同类型参数\n\nint：接收整型\nstring：接收任何不包括斜杠的文本\nfloat：接收浮点数\npath：接收包含斜杠的文本\n\n请求与响应现在当前文件夹创建一个文件夹templates，在里面新建 index.html，结构如下：\n\nfrom flask import Flask, render_templateapp = Flask(__name__)@app.route(&#x27;/index&#x27;)def index():    return render_template(&#x27;index.html&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run()\n\n进入：http://127.0.0.1:5000/index，可访问\n表单采用 post 提交index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;登录&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;      用户名：      &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; /&gt;&lt;br /&gt;      密码：      &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot; /&gt;&lt;br /&gt;      &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n\napp.py\nfrom flask import Flask, render_template, requestapp = Flask(__name__)@app.route(&#x27;/index&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index():    # 如果是GET请求，则渲染index.html模板    if request.method == &#x27;GET&#x27;:        return render_template(&#x27;index.html&#x27;)    # 如果是POST请求，则获取表单数据，计算结果并返回    elif request.method == &#x27;POST&#x27;:        # 获取表单数据        name = request.form.get(&#x27;username&#x27;)        password = request.form.get(&#x27;password&#x27;)        # 返回结果        return &#x27;hello %s,your password is: %s!&#x27; % (name, password)if __name__ == &#x27;__main__&#x27;:    app.run()\n\n重定向 302使用redirect重定向到百度\nfrom flask import Flask, redirectapp = Flask(__name__)@app.route(&#x27;/index&#x27;)def index():    return redirect(&#x27;http://www.baidu.com&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run()\n\n重定向到本地路由\nfrom flask import Flask, redirect, url_forapp = Flask(__name__)@app.route(&#x27;/index&#x27;)def index():    return redirect(url_for(&#x27;hello&#x27;))@app.route(&#x27;/&#x27;)def hello():    return &#x27;Hello, World!&#x27;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n使用 JSON 返回from flask import Flask, make_response, jsonifyapp = Flask(__name__)@app.route(&#x27;/index&#x27;)def index():    data = &#123;        &#x27;name&#x27;: &#x27;你好呀&#x27;,    &#125;    # return make_response(data)    return jsonify(data)if __name__ == &#x27;__main__&#x27;:    app.run()\n\njsonify返回 json 格式\nabort 函数（抛异常）abort 的常见异常值：401、403、404\nfrom flask import Flask, abort, request, make_response, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index():    if request.method == &#x27;GET&#x27;:        return render_template(&#x27;index.html&#x27;)    if request.method == &#x27;POST&#x27;:        name = request.form.get(&#x27;username&#x27;)        password = request.form.get(&#x27;password&#x27;)        if name == &#x27;admin&#x27; and password == &#x27;123456&#x27;:            return &#x27;Login success&#x27;        else:            abort(404)            return Noneif __name__ == &#x27;__main__&#x27;:    app.run()\n\n自定义异常捕捉页面 404 异常\nfrom flask import Flask, abort, request, make_response, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index():    if request.method == &#x27;GET&#x27;:        return render_template(&#x27;index.html&#x27;)    if request.method == &#x27;POST&#x27;:        name = request.form.get(&#x27;username&#x27;)        password = request.form.get(&#x27;password&#x27;)        if name == &#x27;admin&#x27; and password == &#x27;123456&#x27;:            return &#x27;Login success&#x27;        else:            abort(404)            return None@app.errorhandler(404)def handle_404_error(error):    return render_template(&#x27;404.html&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run()\n\n模板使用（jinja2）@app.route(&#x27;/index&#x27;)def index():    data = &#123;        &#x27;title&#x27;: &#x27;Home&#x27;,        &#x27;heading&#x27;: &#x27;Welcome to my Flask app!&#x27;,        &#x27;mylist&#x27;: [1, 2, 3, 4, 5]    &#125;    return render_template(&#x27;index2.html&#x27;, data=data) # 将data传入html中\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;index2&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &#123;&#123; data[&#x27;title&#x27;] &#125;&#125; 使用&#123;&#123;&#125;&#125;拿去数据    &lt;br /&gt;    &#123;&#123; data.title &#125;&#125;    &lt;br /&gt;    mylist：&#123;&#123; data.mylist &#125;&#125; count:&#123;&#123; data.mylist[1] + data.mylist[2] &#125;&#125;    在&#123;&#123;&#125;&#125;中可以运算  &lt;/body&gt;&lt;/html&gt;\n\n过滤器&#123;&#123; &#x27;hello_world&#x27; | upper &#125;&#125; 使用&#x27;&#x27;表示显示一个字符换 upper将前面的字母转为大写\n\n\n\n\n过滤器\n描述\n\n\n\nabs(value)\n返回一个数值的绝对值。 例如：-1\n\n\ndefault(value,default_value,boolean&#x3D;false)\n判断变量的值\n\n\nescape(value) 或 e\n转义字符，会将&lt;、&gt;等符号转义成 HTML 中的符号。\n\n\nfirst(value)\n返回一个序列的第一个元素。names\n\n\nformat(value,*arags,**kwargs)\n格式化字符串。\n\n\nlength(value)\n返回一个序列或者字典的长度。\n\n\njoin(value,d&#x3D;’+’)\n将一个序列用 d 这个参数的值拼接成字符串。\n\n\nupper(value)\n将字符串转换为大写。\n\n\nlower(value)\n将字符串转换为小写。\n\n\nstring(value)\n将变量转换成字符串。\n\n\nwordcount(s)\n计算一个长字符串中单词的个数。\n\n\n也可以自定义过滤器，自定义过滤器\n后端表单验证from flask import Flask, render_template, requestfrom wtforms import StringField, PasswordField, SubmitField # 类型from flask_wtf import FlaskFormfrom wtforms.validators import DataRequired, EqualTo # 验证数据app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = &#x27;12345678&#x27;# 定义表单的模型类class RegisterForm(FlaskForm):    &quot;&quot;&quot;自定义的注册表单模型类&quot;&quot;&quot;    #                                  名字     验证器    user_name = StringField(label=&#x27;用户名&#x27;, validators=[DataRequired(&#x27;用户名不能为空&#x27;)])    password = PasswordField(label=&#x27;密码&#x27;, validators=[DataRequired(&#x27;密码不能为空&#x27;)])    password2 = PasswordField(label=&#x27;确认密码&#x27;, validators=[DataRequired(), EqualTo(&#x27;password&#x27;)])    submit = SubmitField(label=&#x27;提交&#x27;)@app.route(&#x27;/register&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def register():    form = RegisterForm()    if request.method == &#x27;GET&#x27;:        return render_template(&#x27;register.html&#x27;, form=form)    if request.method == &#x27;POST&#x27;:        username = form.user_name.data        password = form.password.data        return &#x27;success&#x27;+&#x27;\\t&#x27;+username+&#x27;\\t&#x27;+passwordif __name__ == &#x27;__main__&#x27;:    app.run()\n\nregister.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;      &#123;&#123; form.user_name.label &#125;&#125; &#123;&#123; form.user_name &#125;&#125; &lt;br /&gt;      &#123;&#123; form.password.label &#125;&#125; &#123;&#123; form.password &#125;&#125; &lt;br /&gt;      &#123;&#123; form.password2.label &#125;&#125; &#123;&#123; form.password2 &#125;&#125; &lt;br /&gt;      &#123;&#123; form.submit &#125;&#125;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n","categories":["高级语言"],"tags":["Python"]},{"title":"GPT大模型部署及应用","url":"/2025/02/12/GPT%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%BA%94%E7%94%A8/","content":"Ollama部署DS私有化部署Deepseek，使用ollama运行，使用Cherry Studio最为客户端 UI 使用\n可以搭配Page Assist浏览器插件在浏览器中使用\n安装 ollama前往Ollama官网进行下载：Download Ollama on Windows\n配置 ollamaollama 默认会将模型下载到C盘，对 ollama 进行配置\n打开系统环节变量，添加如下：\n更改模型存放位置：\n\n\n\n变量名\n变量值\n\n\n\nOLLAMA_MODELS\nD:\\ollama\\models\n\n\n更改 ollama 启动ip（当需要外部访问时）与端口：不建议更改 ollama 默认端口 11434\n\n\n\n变量名\n变量值\n\n\n\nOLLAMA_HOST\n0.0.0.0:11434\n\n\nollama 常见命令启动 ollma：要启动 Ollama 服务，可以使用以下命令：\n\nollama serve\n\n创建模型：从模型文件创建模型：\n\nollama create -f .&#x2F;modelfile\n\n运行模型：要运行一个模型，可以使用以下命令：\n\nollama run 模型名称\n例如运行谷歌 gemma 模型：ollama run gemma\n\n列出所有模型：要列出所有可用的模型，可以使用以下命令：\n\nollama list\n\n查看模型具体输出tokens&#x2F;s数值\n\nollama run 模型名称 –verbose\n例如：ollama run deepseek-r1:32b –verbose\n\n输出结果如下：\nadministrator@win11&gt; ollama run deepseek-r1:32b --verbosetotal duration:       1m31.2075255sload duration:        30.2214msprompt eval count:    19 token(s)prompt eval duration: 595.6157msprompt eval rate:     31.90 tokens/seval count:           469 token(s)eval duration:        1m30.5816884seval rate:            5.18 tokens/s\n\n\ntotal duration: 1m31.2075255s (91.2075255 秒)\n含义: 从开始处理请求到完成整个过程的总时间，包括加载模型、评估提示和生成响应的所有阶段。\n分析: 总时长约为 1 分 31 秒，表明这是一个相对耗时的操作。结合日志，模型在  阶段进行了详细的推理（约 1 分钟），这显著延长了总时长。实际生成响应的时间（eval duration）占主导，提示处理和加载时间较短。\n\n\nload duration: 30.2214ms (0.0302214 秒)\n含义: 模型加载到内存中的时间，单位为毫秒。\n分析: 加载时间仅约 30 毫秒，表明模型可能已预加载到内存中，或者 qwen3:32b（20 GB）的初始加载开销在之前的运行中已完成。此阶段开销极小。\n\n\nprompt eval count: 19 token(s)\n含义: 输入提示（prompt）中处理的 token 总数，即 “Hello, I’m doing great! How about you?” 被分割成的语言单元数。\n分析: 提示被拆分为 19 个 token，这与输入文本的长度和分词方式（如空格、标点）一致。较长的提示可能增加初始处理复杂度。\n\n\nprompt eval duration: 595.6157ms (0.5956157 秒)\n含义: 处理输入提示所需的时间，单位为毫秒。\n分析: 约 596 毫秒用于处理 19 个 token，反映了输入阶段的计算开销。结合  阶段的推理，这部分时间可能包括部分预处理。\n\n\nprompt eval rate: 31.90 tokens&#x2F;s\n含义: 每秒处理的提示 token 数，计算方式为 prompt eval count &#x2F; (prompt eval duration &#x2F; 1000) &#x3D; 19 &#x2F; (595.6157 &#x2F; 1000) ≈ 31.90 tokens&#x2F;s。\n分析: 处理提示的效率较高（31.90 tokens&#x2F;s），表明输入阶段优化良好，但这仅占总流程的很小部分（&lt;1 秒）。\n\n\neval count: 469 token(s)\n含义: 模型生成响应的 token 总数，即最终输出的 “Hi there! � Thank you for the cheerful greeting! …” 等内容的 token 数。\n分析: 生成了 469 个 token，结合日志可见输出较长（包含  和最终响应）。这表明模型在推理和生成上进行了较多的扩展。\n\n\neval duration: 1m30.5816884s (90.5816884 秒)\n含义: 生成响应所需的时间，单位为秒。\n分析: 约 1 分 30 秒用于生成，占总时长的绝大部分（91.2075255s - 0.5956157s - 0.0302214s ≈ 90.58s）。 阶段的详细推理（约 1 分钟）是主要耗时来源，反映了模型在规划响应时的计算密集型工作。\n\n\neval rate: 5.18 tokens&#x2F;s\n含义: 每秒生成的 token 数，计算方式为 eval count &#x2F; eval duration &#x3D; 469 &#x2F; 90.5816884 ≈ 5.18 tokens&#x2F;s。\n分析: 生成速率较低（5.18 tokens&#x2F;s），这是因为 qwen3:32b 是一个大型模型（20 GB），在单次推理中结合了复杂的  逻辑。较低的速率与硬件性能（可能仅使用 CPU）或模型优化程度有关。\n\n\n\ndeepseek使用 ollama 下载deepseek-R1离线模型：\n进入 ollama 官网搜索对应模型：deepseek-r1\n例如我们下载 deepseek-r1:32b 模型：ollama run deepseek-r1:32b\n\n打开 ollama，在命令行输入：ollama serve\n然后运行 deepseek-r1:32b，ollama run deepseek-r1:32b，当没有这个模型时则自动下载\n下载完成后，继续运行ollama run deepseek-r1:32b，就启动了：\n\n模型使用R1 提示词\n提示词的本质：\n\nPrompt -&gt; 表达\n\n共识 1：DeepSeek-R1 的提示词技巧，就是没有技巧：\n\n不需要结构设定\n不需要结构化提示词\n不需要给示例\n\n共识 2：仍需要告诉 AI足够多的背景信息\n\n干什么？\n\n\n给谁干？\n\n\n目的是？（要什么）\n\n\n是约束？（不要什么）\n\n举例：我要写一个“如何理解爱因斯坦的相对论”的科普文章，给中小学生看，希望能通俗易懂、内容充实、幽默，且觉得非常实用，不要太 AI 或枯燥。\n技巧 1：要求明确\n万能提示词模板：你是谁 + （背景信息）+ 你的目标\n\n你是谁：非常的有用\n\n背景信息：告诉他你为什么做这件事，你面临的现实背景是什么或问题是什么\n\n你的目标：说清楚它帮你做什么，做到什么程度\n\n\n可视化软件当我们安装好了ollama 与 Deepseek-R1 模型，我们还需要一个方便美观的 UI 界面\nWindows 软件方面推荐：\n\nCherry Studio：Cherry Studio 官网\nChat Box：Chatbox AI 官网\n\n浏览器 Web UI 插件：\nPage Assist:Page Assis | Chrome 扩展\n使用方法：\n\n选择Ollama设置，填入 ollama 地址，默认为：http://localhost:11434，添加模型\n\nRAGflow 知识库我们可以使用 ollama 与 RAGflow 结合搭建个人知识库\n我们开始安装RAGflow，需要使用 docker 进行安装，我们从头开始：\n首先，我们需要一台 Linux 服务器，我这里使用 CentOS 7 为例\n1.先决条件\nCPU ≥ 4 核；\nRAM ≥ 16 GB；\n磁盘 ≥ 50 GB；\nDocker ≥ 24.0.0 &amp; Docker Compose ≥ v2.26.1。\n\n安装 docker 及 docker-compose安装 docker:\n# 1、卸载旧的版本sudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine# 2、需要的安装包sudo yum install -y yum-utils# 3、设置镜像仓库sudo yum-config-manager \\    --add-repo \\    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 推荐使用阿里云的# 更新yum软件包索引sudo yum makecache fast# 4、安装docker相关的内容 docker-ce 社区sudo yum install docker-ce docker-ce-cli containerd.io# 5、启动dockersudo systemctl start docker# 测试docker是否正常sudo docker version# 6、设置开机自启sudo systemctl enable docker --now# 7、更改docker镜像，定期寻找可用的镜像源sudo vim /etc/docker/daemon.json# 编辑 daemon.json 文件，输入：&#123;  &quot;registry-mirrors&quot;: [    &quot;https://docker.1ms.run&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;https://reg-mirror.qiniu.com&quot;  ]&#125;# 重启dockersudo systemctl daemon-reloadsudo systemctl restart docker# 通过检查是否镜像源已修改sudo docker info\n\n安装 docker-compose# 1、下载docker-composesudo curl -SL \\https://gitee.com/smilezgy/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 \\-o /usr/local/bin/docker-compose# 2、添加可执行权限sudo chmod +x /usr/local/bin/docker-compose# 3、测试docker-compose --version\n\n2.启动服务器提供了在 Linux 上设置 RAGFlow 服务器的说明\n确保 vm.max_map_count ≥ 262144:vm.max_map_count此值设置进程可能拥有的内存映射区域的最大数量。它的默认值是65530。虽然大多数应用程序需要少于一千个映射，但减少此值可能会导致异常行为，当进程达到限制时，系统会抛出内存不足错误。\nRAGFlow v0.10.0 使用 Elasticsearch 进行多次调用。正确设置 vm.max_map_count 的值对于 Elasticsearch 组件的正常运行至关重要。\nLinux：\n检查vm.max_map_count的值：\n$ sysctl vm.max_map_count\n\n重置vm.max_map_count到一个值至少大于等于262144。\n$ sudo sysctl -w vm.max_map_count=262144\n\n\n警告\n\n此更改将在系统重新启动后重置。如果下次启动服务器时忘记更新该值，您可能会收到Can&#39;t connect to ES cluster异常。\n为确保您的更改保持永久，请相应地添加或更新 /etc/sysctl.conf 中的vm.max_map_count值：\nvm.max_map_count=262144\n\n克隆存储库：# 拉取仓库git clone https://github.com/infiniflow/ragflow.git# 如果没有git，使用下面命令：sudo yum install -y git\n\n构建预构建的 Docker 映像并启动服务器：运行以下命令会自动下载开发版本 RAGFlow Docker 映像。要下载并运行指定的 Docker 版本，请在运行以下命令之前将 docker/.env 中的RAGFLOW_VERSION更新到预期版本，例如RAGFLOW_VERSION=v0.10.0。\n\n如果需要修改默认镜像配置，在 ragflow&#x2F;docker&#x2F;.env\n查看隐藏文件：ls -al，进行编辑\nsudo vim .env\n在.env中，找到 RAGFLOW_IMAGE\n注销掉：RAGFLOW_IMAGE&#x3D;infiniflow&#x2F;ragflow:v0.17.0-slim\n在下面取消注销：RAGFLOW_IMAGE&#x3D;infiniflow&#x2F;ragflow:v0.17.0\n\n\n$ cd ragflow/docker$ chmod +x ./entrypoint.sh$ docker compose up -d\n\n核心映像的大小约为 9 GB，可能需要一段时间才能加载。\n\n服务器启动并运行后检查服务器状态这一步一定要做\n$ docker logs -f ragflow-server\n\n以下输出确认系统成功启动：\n    ____                 ______ __   / __ \\ ____ _ ____ _ / ____// /____  _      __  / /_/ // __ `// __ `// /_   / // __ \\| | /| / / / _, _// /_/ // /_/ // __/  / // /_/ /| |/ |/ //_/ |_| \\__,_/ \\__, //_/    /_/ \\____/ |__/|__/              /____/ * Running on all addresses (0.0.0.0) * Running on http://127.0.0.1:9380 * Running on http://x.x.x.x:9380 INFO:werkzeug:Press CTRL+C to quit\n\n如果您跳过此确认步骤并直接登录 RAGFlow，您的浏览器可能会提示network anomaly错误，因为此时您的 RAGFlow 可能尚未完全初始化。\n\n如果日志中出现警告可以不用管，例如： WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n\n登录网站在您的 Web 浏览器中，输入服务器的 IP 地址并登录 RAGFlow。\n警告：使用默认设置，您只需要输入http://IP_OF_YOUR_MACHINE（无端口号），因为使用默认配置时可以省略默认 HTTP 服务端口80。\n3.配置 LLMRAGFlow 是一个 RAG 引擎，它需要与 LLM 一起工作以提供接地气、无幻觉的问答功能。目前，RAGFlow 支持以下 LLM，并且列表正在扩展：\n\nOpenAI\nAzure-OpenAI\nGemini\nGroq\nMistral\nBedrock\nTongyi-Qianwen\nZHIPU-AI\nMiniMax\nMoonshot\nDeepSeek\nBaichuan\nVolcEngine\nJina\nOpenRouter\nStepFun\n\n注意：RAGFlow 还支持使用 Ollama、XINETH 或 LocalAI 在本地部署 LLM，但本文指南未涵盖这部分。\n我们可以将本地搭建的ollama配置到 RAGflow，点击右上角人物头像进入设置 -》 选择模型供应商 -》添加 ollama 模型\n我们还可以前往阿里云百炼，获取 APP Key，添加通义千问大模型：\n\nDify实现工作流Dify的特点\n\n开源，可本地部署、数据安全\n插件国际化，需要魔法\n\n官网：Dify.AI\t\t在线应用网站：cloud.dify.ai\n说明：开源的 LLM 应用开发平台。提供从 Agent 构建到 AI workflow 编排、RAG 检索、模型管理等能力，轻松构建和运营生成式 AI 原生应用。比 LangChain 更易用。\n\nDify本地部署先决条件：确保已安装Docker、docker-compose\n如未安装可前往安装教程：Docker - Phils的杂货铺\n拉取Dify代码github仓库：langgenius&#x2F;dify\n快速启动，如需修改配置，在.env中进行修改：\ncd difycd dockercp .env.example .envdocker compose up -d\n\n全部拉取成功后，访问 localhost:80 即可访问，进行管理员账户注册登录。\n更新Dify先在Docker中停止Dify\ndocker compose down\n\n进行备份，并重新在Github拉取新代码：\n# 备份docker compose数据，位置在dify/docker/cp docker-compose.yaml docker-compose.yaml.$(date +%Y.%m.%d).bak# 拉取git pull origin main# 如有冲突解决（ymal文件）vim docker-compose.yaml# 更新拉取并启动docker compose up -d\n\n配置LLM点击右上角的设置 -》选择安装模型供应商-》安装ollama-》配置ollama接口\n\n配置好ollama后，在系统模型设置中，系统推理模型选择ollama的模型，点击保存\n\n","categories":["大模型"],"tags":["ollama","RAGFlow","Dify"]},{"title":"Git","url":"/2023/05/17/Git/","content":"\ngit init 初始化本地库\n\n\ngit status 本地库状态\n\n$ git status\t本地库状态On branch masterNo commits yetnothing to commit (create/copy files and use &quot;git add&quot; to track)\t# 还没有文件$ git statusOn branch masterNo commits yetUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        test.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track)\n\n\ngit config –list #查看 git 配置信息\n\n\n查看用户名，密码和邮箱命令：\ngit config user.namegit config user.passwordgit config user.email\n\n设置或修改用户名，密码和邮箱命令：\ngit config --global user.name &quot;freedom&quot;git config --global user.password &quot;123456&quot;git config --global user.email &quot;12345678@qq.com&quot;\n\ngit 强制提交本地分支覆盖远程分支\ngit push origin 分支名 --force\n\nGit 分支\n切换分支\n\ngit checkout branchName\n\n\n查看分支\n\ngit branch -a\n\ngitignore 模板*.class*.log*.lock# Package Files #*.jar*.war*.eartarget/# idea.idea/*.iml/*velocity.log*### STS ###.apt_generated.factorypath.springBeans### IntelliJ IDEA ###*.iml*.ipr*.iws.idea.classpath.project.settings/bin/*.log*.log/tem/#rebel*rebel.xml**.gitignore\n\n使用码云\n注册登录，完善信息\n设置本机绑定 SSH 密钥，实现免密码登录\n\n# 进入C:\\Users\\Admin\\.ssh# 生成公钥ssh-keygen -t rsa\n\n\n\n添加密钥到码云\n\n\n\n使用码云创建自己的仓库\n\n许可证：开源是否可以随意转载，开源但不能商业使用、不能转载，…限制\n\n克隆自己的仓库\n\n\n","categories":["技术栈"],"tags":["Git"]},{"title":"基于GitBook搭建个人博客","url":"/2023/11/15/GitBook/","content":"基于 GitBook 搭建个人博客为什么选择使用 GitBook\nGitBook 更加方便管理且支持搜索，可以在有想要记录的时候，打开编辑器记录下，然后合适的时间分享（发布）下\nGitBook 可以自己管理文章，想写什么想发什么看自己心情，不用考虑平台限制等因素\nGitBook 是有md静态文件渲染出来的，基础文件可迁移性强。\n\n搭建方式\n线上直接搭建\n线上网址搭建地址 传送门 具体搭建教程可网上自行搜索，这里就不做过多记录。原因如下：\n\n\n国内网络环境问题，导致 GitBook 网站经常打不开，需要使用代理才能访问。\n修改提交后，更新显示有时间延迟。\n\n\n\n基于 Node.js 的命令工具开发\n推荐使用这种方式，方便管理，配合自己的代码管理工具。简直不要太完美。\n\n\n基于 Node.js 本地搭建安装 GitBook 工具打开 CMD 终端，输入npm install gitbook-cli -g命令进行全局安装安装完成后，输入 gitbook –version 来查看是否安装成功 第一次使用，cli 会自动安装 gitbook,安装时间视网络环境而定，请耐心等待，若要卸载，就执行 npm uninstall gitbook-cli -g来删除\n\n创建目录首先需要创建项目跟文件夹，步骤如下：\nmkdir GitBookcd GitBookgitbook init\n\n\ngitbook init 命令是用于初始化项目的，会创建 README.md 和 SUMMARY.md 两个项目必须的文件\n\nREADME.md 是项目介绍文件，在运行后会固定展示在目录头部，tips:可以通过某种手动进行隐藏\nSUMMARY.md 是项目的目录菜单\n\n本地启动本地启动命令gitbook serve\n执行该命令，会生成 _book 文件夹，这个文件夹是最终需要发布的文件夹。请自行在管理工具中忽略。\n运行启动后，可直接访问http://localhost:4000,打开的第一个页面,将是 README.md 页面。\n打包发行执行gitbook build 命令即可打包，打包后，在根目录有一个 _book 文件夹，\n将该文件夹发布至 Nginx 或者 存储云 或 服务器 都可以。\nGitBook 配置文件说明如果想要对项目做单独的项目配置和使用其它插件，就需要使用配置文件进行配置。在项目根目录创建book.json文件，文件内容如下：\n&#123;  &quot;author&quot;: &quot;Phils&quot;,  &quot;description&quot;: &quot;This is record sharing by Phils.&quot;,  &quot;extension&quot;: null,  &quot;generator&quot;: &quot;site&quot;,  &quot;isbn&quot;: &quot;&quot;,  &quot;links&quot;: &#123;    &quot;sharing&quot;: &#123;      &quot;all&quot;: null,      &quot;facebook&quot;: null,      &quot;google&quot;: null,      &quot;twitter&quot;: null,      &quot;weibo&quot;: null    &#125;,    &quot;sidebar&quot;: &#123;      &quot;谷歌&quot;: &quot;https://www.google.com&quot;    &#125;  &#125;,  &quot;output&quot;: null,  &quot;pdf&quot;: &#123;    &quot;fontSize&quot;: 12,    &quot;footerTemplate&quot;: null,    &quot;headerTemplate&quot;: null,    &quot;margin&quot;: &#123;      &quot;bottom&quot;: 36,      &quot;left&quot;: 62,      &quot;right&quot;: 62,      &quot;top&quot;: 36    &#125;,    &quot;pageNumbers&quot;: true,    &quot;paperSize&quot;: &quot;a4&quot;  &#125;,  &quot;plugins&quot;: [],  &quot;pluginsConfig&quot;: &#123;&#125;,  &quot;language&quot;: &quot;zh-hans&quot;,  &quot;title&quot;: &quot;Levy&quot;,  &quot;variables&quot;: &#123;&#125;,  &quot;styles&quot;: &#123;    &quot;website&quot;: &quot;assets/styles/website.css&quot;  &#125;&#125;\n\n更多参数配置请参考：https://github.com/GitbookIO/gitbook/blob/master/docs/config.md\n在SUMMARY.md中，可以编写文章结构，例如：\n- [简介](README.md)- [目录](SUMMARY.md)- [毕设](毕设/任务书.md)\n\n效果图：\n\n","categories":["博客"],"tags":["GitBook"]},{"title":"IDE优化","url":"/2023/06/26/IDE%E4%BC%98%E5%8C%96/","content":"IDEA设置 Maven 国内阿里镜像\n右键项目，选择 Maven→Open ‘settings.xml’\n\n\n\n在 settings.xml 文件中增加阿里云镜像地址，代码如下：\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;    &lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;alimaven&lt;/id&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;name&gt;aliyun maven&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;    &lt;/mirror&gt;    &lt;/mirrors&gt;&lt;/settings&gt;\n\n\n在 pom.xml 文件上右击，选择 Maven→Reimport\n\n\n\ntips\n\n\nmaven 的的全局配置默认路径是 C:\\Users[当前用户].m2\\settings.xml\nmaven 的配置路径可以在 settings 中的 maven 中修改\n\n设置类注释例如下面的样式：\n/** * @Author: wjwang * @description: * @date: 2023-09-08 21:54 */\n\n进入IDEA在 File &#x3D;&gt; Settings &#x3D;&gt; Editor &#x3D;&gt; File and Code Templates，选择includes，加入一下内容：\n\n/** * @author $&#123;USER&#125; * @description $&#123;description&#125; * @date $&#123;DATE&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;:$&#123;SECOND&#125; */\n\nVScode导入设置管理 → 设置 → 打开设置\n&#123;  &quot;files.autoSave&quot;: &quot;afterDelay&quot;,  &quot;files.autoGuessEncoding&quot;: true,  &quot;workbench.list.smoothScrolling&quot;: true,  &quot;editor.cursorSmoothCaretAnimation&quot;: &quot;on&quot;,  &quot;editor.smoothScrolling&quot;: true,  &quot;editor.cursorBlinking&quot;: &quot;smooth&quot;,  &quot;editor.mouseWheelZoom&quot;: true,  &quot;editor.formatOnPaste&quot;: true,  &quot;editor.formatOnType&quot;: true,  &quot;editor.formatOnSave&quot;: true,  &quot;editor.wordWrap&quot;: &quot;on&quot;,  &quot;editor.guides.bracketPairs&quot;: true,  //&quot;editor.bracketPairColorization.enabled&quot;: true, (此设置vscode在较新版本已默认开启)  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,  &quot;editor.acceptSuggestionOnEnter&quot;: &quot;smart&quot;,  &quot;editor.suggestSelection&quot;: &quot;recentlyUsed&quot;,  &quot;window.dialogStyle&quot;: &quot;custom&quot;,  &quot;debug.showBreakpointsInOverviewRuler&quot;: true,  &quot;editor.fontSize&quot;: 18,  &quot;liveServer.settings.donotShowInfoMsg&quot;: true,  &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,  &quot;explorer.confirmDelete&quot;: false,  &quot;workbench.startupEditor&quot;: &quot;none&quot;&#125;\n","categories":["技术栈"],"tags":["IDE"]},{"title":"Jarvis助手","url":"/2023/05/17/Jarvis%E5%8A%A9%E6%89%8B/","content":"ChatGPT使用Azure的Azure OpenAI服务，可以选择openai库或者使用API的方式\npython调用openai库导入库并列出模型\nimport openaiimport osimport reimport requestsimport sysfrom num2words import num2wordsimport osimport pandas as pdimport numpy as npfrom openai.embeddings_utils import get_embedding, cosine_similarityimport tiktokenAPI_KEY = os.getenv(&quot;AZURE_OPENAI_API_KEY&quot;) RESOURCE_ENDPOINT = os.getenv(&quot;AZURE_OPENAI_ENDPOINT&quot;) openai.api_type = &quot;azure&quot;openai.api_key = API_KEYopenai.api_base = RESOURCE_ENDPOINTopenai.api_version = &quot;2023-05-15&quot;url = openai.api_base + &quot;/openai/deployments?api-version=2023-05-15&quot; r = requests.get(url, headers=&#123;&quot;api-key&quot;: API_KEY&#125;)print(r.text)\n\n封装成类，新建chat.py\nimport osimport openaiimport tiktokenclass Chat_service:    prompt = &quot;&quot;    template = &quot;&quot;&quot;            person: &#123;&#125;            AI:&quot;&quot;&quot;    def __init__(self):        # OpenAI API        openai.api_type = &quot;azure&quot;        openai.api_key = API_KEY        openai.api_base = RESOURCE_ENDPOINT        openai.api_version = &quot;2023-05-15&quot;    def num_tokens_from_string(self, string: str, encoding_name: str) -&gt; int:        &quot;&quot;&quot;Returns the number of tokens in a text string.&quot;&quot;&quot;        encoding = tiktoken.get_encoding(encoding_name)        num_tokens = len(encoding.encode(string))        return num_tokens    def receive(self, question, choose=0):        filedir = os.path.dirname(os.path.realpath(__file__))        list = &#123;0: &#x27;/prompts/prompts.txt&#x27;,                1: &#x27;/prompts/开发者模式.txt&#x27;,                2: &#x27;/prompts/派蒙.txt&#x27;,                3: &#x27;/prompts/深度学习.txt&#x27;,                4: &#x27;/prompts/文字探险.txt&#x27;                &#125;        # 加入提示词        file_url = filedir + list[choose]        if os.path.exists(file_url):            with open(file_url, &quot;r&quot;, encoding=&#x27;utf-8&#x27;) as f:                self.prompt = f.read()        prompt_local = self.prompt + self.template.format(question)        result = openai.Completion.create(            engine=&quot;text-davinci-003&quot;,  # “text-davinci-003” 模型用于文本生成，“code-davinci-002”模型用于代码生成            prompt=prompt_local,            temperature=0.9,            max_tokens=1000,  # 4097是openai的限制，            stop=[&quot;person&quot;, &quot;AI&quot;, &quot;\\n&quot;],            top_p=1.0,            frequency_penalty=0.0,            presence_penalty=-0.6        )        text = result.choices[0][&#x27;text&#x27;]        return textif __name__ == &#x27;__main__&#x27;:    cs = Chat_service()    n = int(input(&quot;请输入模式（0:默认、1:开发者模式、2:派蒙、3:深度学习、4:文字探险）：&quot;))    while True:        q = input(&quot;Person：&quot;)        if q == &#x27;退出&#x27;:            break        print(cs.receive(q, n))\n\n字节流返回（stream&#x3D;True）\nimport openaiopenai.api_type = &quot;azure&quot;openai.api_base = &#123;终结点&#125;openai.api_version = &quot;2023-05-15&quot;openai.api_key = &#123;密钥&#125;template = &quot;&quot;&quot;        person: &#123;什么是resnet18&#125;        AI:&quot;&quot;&quot;response = openai.Completion.create(    engine=&quot;text-davinci-003&quot;,    prompt=template,    temperature=0.9,    max_tokens=256,    top_p=1,    frequency_penalty=0,    presence_penalty=0,    best_of=1,    stream=True,    stop=[&quot;Human:&quot;, &quot;AI:&quot;])collected_events = []completion_text = &#x27;&#x27;# iterate through the stream of eventsfor event in response:    collected_events.append(event)  # save the event response    event_text = event[&#x27;choices&#x27;][0][&#x27;text&#x27;]  # extract the text    completion_text += event_text  # append the text    print(f&quot;Text received: &#123;event_text&#125;&quot;)print(f&quot;Full text received: &#123;completion_text&#125;&quot;)\n\n结果演示：\n\nxxxxxxxxxx Object massage &#x3D; redisUtil.lGetIndex(“sensor”, 0);JSONObject jsonObject &#x3D; JSON.parseObject(massage.toString());String sn &#x3D; jsonObject.getString(“SN”);BigDecimal temp &#x3D; jsonObject.getBigDecimal(“Temp”);BigDecimal humidity &#x3D; jsonObject.getBigDecimal(“Humidity”);String time &#x3D; jsonObject.getString(“time”);java\n也可以使用openai的密钥，在腾讯云上创建云函数，挂载到美国，可直连接口。:arrow_down:\n云函数app.py\nfrom flask import Flask,requestopeailoaded=&quot;0&quot;try:   import openai   openai.api_key = &#x27;sk-xxxxxxxxxxxxxxxxxxxx&#x27;   opeailoaded=&quot;1&quot;except Exception as e:   opeailoaded=&quot;0&quot;app = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():   if opeailoaded==&quot;1&quot;:      return &#x27;opeailoaded&#x27;   else:      return &quot;openai not loaded&quot;@app.route(&#x27;/ask&#x27;)def ask():   try:      query=request.args.get(&quot;query&quot;)      response=openai.ChatCompletion.create(         model=&quot;gpt-3.5-turbo&quot;,         messages=[            &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;,            &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: query&#125;         ]      )      return response [&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;]   except Exception as e:      print(str(e))      return &quot;无法获取结果&quot;if __name__ == &#x27;__main__&#x27;:   app.run(host=&#x27;0.0.0.0&#x27;,port=9000)\n\n点击查看-终端\n\n输入安装 openai 库\ncd src # 进入源代码库pip3 install openai -t. # 安装到源代码路径下\n\n点击部署\n加入语音服务使用Azure的认知语音服务，可文字转语音，语音转文字，也可以选择不同的声音。\n封装成类，新建voice_service.py\nimport azure.cognitiveservices.speech as speechsdkimport keyboardimport timeclass VoiceService:    text = &#x27;&#x27;    def __init__(self):        speech_key = &#123;密钥&#125;        service_region = &#123;新建服务时的地区&#125;        speech_config = speechsdk.SpeechConfig(subscription=speech_key, region=service_region)        audio_config = speechsdk.audio.AudioOutputConfig(use_default_speaker=True)        speech_config.speech_synthesis_language = &quot;zh-CN&quot;        speech_config.speech_synthesis_voice_name =&quot;zh-CN-XiaoyanNeural&quot; # 女：zh-CN-XiaomoNeural 男：zh-CN-XiaoyanNeural        self.speech_synthesizer = speechsdk.SpeechSynthesizer(speech_config=speech_config, audio_config=audio_config)        speech_config = speechsdk.SpeechConfig(subscription=speech_key, region=service_region)        self.speech_recognizer = speechsdk.SpeechRecognizer(speech_config=speech_config, language=&quot;zh-CN&quot;)    def speak_text(self, text):        self.text = text        if text != &#x27;&#x27;:            self.speech_synthesizer.speak_text_async(text).get()        else:            self.speech_synthesizer.speak_text_async(&#x27;我好像出错了，你能再说一遍吗？&#x27;).get()    def speak(self, text):        self.speak_text(text)    def listen(self):        print(&quot;按下空格键开始监听&quot;)        keyboard.wait(&#x27;space&#x27;)  # 等待空格键按下        result = self.speech_recognizer.recognize_once_async().get()        return result.text    def listen_and_speak(self):        text = self.listen()        print(f&#x27;问： &#123;text&#125;&#x27;)        if &#x27;再见&#x27; in text:            text = &#x27;再见，祝您生活愉快&#x27;            self.speak_text(text)            return False        else:            self.speak_text(text)            print(f&#x27;答： &#123;text&#125;&#x27;)            return True\n\n语音交互首先将上面两个类保存下来，导入。\nimport refrom chat import Chat_servicefrom voice_service import VoiceServicevs = VoiceService()cs = Chat_service()n = 0def text_chat(n):    print(&#x27;有什么需要我帮助的吗？&#x27;)    while True:        try:            q = input(&#x27;问：&#x27;)            if q == &#x27;退出&#x27;:                break            response = cs.receive(q, n)            print(&#x27;AI：&#x27; + response)            response = re.sub(r&#x27;\\(.*?\\)&#x27;, &#x27;&#x27;, response)            vs.speak(response)        except Exception as e:            print(e)def voice_chat(n):    print(&#x27;我是一个智能机器人，我可以回答你的问题。&#x27;)    vs.speak(&#x27;有什么需要我帮助的吗？&#x27;)    while True:        try:            q = vs.listen()            if q in &#x27;退出&#x27;:                break            response = cs.receive(q, n)            print(&#x27;AI：&#x27; + response)            response = re.sub(r&#x27;\\(.*?\\)&#x27;, &#x27;&#x27;, response)            vs.speak(response)        except Exception as e:            print(e)if __name__ == &#x27;__main__&#x27;:    choose = int(input(&#x27;选择模式(1.文字聊天，2.语音聊天)：&#x27;))    n = int(input(&#x27;选择模式(0.默认，1.开发者模式，2.派蒙，3.深度学习，4.文字探险)：&#x27;))    if choose == 1:        text_chat(n)    else:        voice_chat(n)\n\n\n\n人脸识别本文内容1.使用基于Haar特征的Cascade级联分类器进行人脸识别（听起来好高大上，但其实原理很简单）2.用人脸识别同样的道理，扩展到人眼识别上3.用opencv自带的Harr级联分类器进行人脸、人眼与微笑识别\n什么是Harr特征\nHaar特征包含三种：边缘特征、线性特征、中心特征和对角线特征。每种分类器都从图片中提取出对应的特征。\n什么是Cascade级联分类器基于Haar特征的cascade级联分类器是Paul Viola和 Michael Jone在2001年的论文”Rapid Object Detection using a Boosted Cascade of Simple Features”中提出的一种有效的物体检测方法。\nCascade级联分类器的训练方法：Adaboost级联分类器的函数是通过大量带人脸和不带人脸的图片通过机器学习得到的。对于人脸识别来说，需要几万个特征，通过机器学习找出人脸分类效果最好、错误率最小的特征。训练开始时，所有训练集中的图片具有相同的权重，对于被分类错误的图片，提升权重，重新计算出新的错误率和新的权重。直到错误率或迭代次数达到要求。这种方法叫做Adaboost。\n在Opencv中可以直接调用级联分类器函数。\n将弱分类器聚合成强分类器最终的分类器是这些弱分类器的加权和。之所以称之为弱分类器是因为每个分类器不能单独分类图片，但是将他们聚集起来就形成了强分类器。论文表明，只需要200个特征的分类器在检测中的精确度达到了95%。最终的分类器大约有6000个特征。(将超过160000个特征减小到6000个，这是非常大的进步了） 。\n级联的含义：需过五关斩六将才能被提取出来事实上，一张图片绝大部分的区域都不是人脸。如果对一张图片的每个角落都提取6000个特征，将会浪费巨量的计算资源。\n如果能找到一个简单的方法能够检测某个窗口是不是人脸区域，如果该窗口不是人脸区域，那么就只看一眼便直接跳过，也就不用进行后续处理了，这样就能集中精力判别那些可能是人脸的区域。 为此，有人引入了Cascade 分类器。它不是将6000个特征都用在一个窗口，而是将特征分为不同的阶段，然后一个阶段一个阶段的应用这些特征(通常情况下，前几个阶段只有很少量的特征)。如果窗口在第一个阶段就检测失败了，那么就直接舍弃它，无需考虑剩下的特征。如果检测通过，则考虑第二阶段的特征并继续处理。如果所有阶段的都通过了，那么这个窗口就是人脸区域。 作者的检测器将6000+的特征分为了38个阶段，前五个阶段分别有1，10，25，25，50个特征(前文图中提到的识别眼睛和鼻梁的两个特征实际上是Adaboost中得到的最好的两个特征)。根据作者所述，平均每个子窗口只需要使用6000+个特征中的10个左右。\nOpenCV中的Haar-cascade检测OpenCV 既可以作为检测器也可以进行机器学习训练。如果你打算训练自己的分类器识别任意的物品，比如车，飞机，咖啡杯等。你可以用OpenCV 创造一个。完整的细节在:Cascade Classifier Training中。\n# 人脸识别# 导入opencv-pythonimport cv2# 读入一张图片，引号里为图片的路径，需要你自己手动设置img = cv2.imread(&#x27;image1.jpg&#x27;,1)# 导入人脸级联分类器引擎，&#x27;.xml&#x27;文件里包含训练出来的人脸特征face_engine = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_frontalface_default.xml&#x27;)# 用人脸级联分类器引擎进行人脸识别，返回的faces为人脸坐标列表，1.3是放大比例，5是重复识别次数faces = face_engine.detectMultiScale(img,scaleFactor=1.3,minNeighbors=5)# 对每一张脸，进行如下操作for (x,y,w,h) in faces:    # 画出人脸框，蓝色（BGR色彩体系），画笔宽度为2    img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)# 在&quot;img2&quot;窗口中展示效果图cv2.imshow(&#x27;img2&#x27;,img)# 监听键盘上任何按键，如有按键即退出并关闭窗口，并将图片保存为output.jpgcv2.waitKey(0)cv2.destroyAllWindows()cv2.imwrite(&#x27;output.jpg&#x27;,img)\n\n\n对单个图片识别# 单张图片人脸+眼睛识别#导入opencvimport cv2# 导入人脸级联分类器引擎，&#x27;.xml&#x27;文件里包含训练出来的人脸特征，cv2.data.haarcascades即为存放所有级联分类器模型文件的目录face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_frontalface_default.xml&#x27;)# 导入人眼级联分类器引擎吗，&#x27;.xml&#x27;文件里包含训练出来的人眼特征eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_eye.xml&#x27;)# 读入一张图片，引号里为图片的路径，需要你自己手动设置img = cv2.imread(&#x27;image3.png&#x27;)# 用人脸级联分类器引擎进行人脸识别，返回的faces为人脸坐标列表，1.3是放大比例，5是重复识别次数faces = face_cascade.detectMultiScale(img, 1.3, 5)# 对每一张脸，进行如下操作for (x,y,w,h) in faces:    # 画出人脸框，蓝色（BGR色彩体系），画笔宽度为2    img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)    # 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源    face_area = img[y:y+h, x:x+w]    eyes = eye_cascade.detectMultiScale(face_area)    # 用人眼级联分类器引擎在人脸区域进行人眼识别，返回的eyes为眼睛坐标列表    for (ex,ey,ew,eh) in eyes:        #画出人眼框，绿色，画笔宽度为1        cv2.rectangle(face_area,(ex,ey),(ex+ew,ey+eh),(0,255,0),1)        # 在&quot;img2&quot;窗口中展示效果图cv2.imshow(&#x27;img2&#x27;,img)# 监听键盘上任何按键，如有案件即退出并关闭窗口，并将图片保存为output.jpgcv2.waitKey(0)cv2.destroyAllWindows()cv2.imwrite(&#x27;output.jpg&#x27;,img)\n\n\n调用电脑摄像头识别# 调用电脑摄像头进行实时人脸+眼睛识别import cv2face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_frontalface_default.xml&#x27;)eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_eye.xml&#x27;)# 调用摄像头摄像头cap = cv2.VideoCapture(0)while(True):    # 获取摄像头拍摄到的画面    ret, frame = cap.read()    faces = face_cascade.detectMultiScale(frame, 1.3, 5)    img = frame    for (x,y,w,h) in faces:    \t# 画出人脸框，蓝色，画笔宽度微        img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)    \t# 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源        face_area = img[y:y+h, x:x+w]        eyes = eye_cascade.detectMultiScale(face_area)    \t# 用人眼级联分类器引擎在人脸区域进行人眼识别，返回的eyes为眼睛坐标列表        for (ex,ey,ew,eh) in eyes:            #画出人眼框，绿色，画笔宽度为1            cv2.rectangle(face_area,(ex,ey),(ex+ew,ey+eh),(0,255,0),1)        \t# 实时展示效果画面    cv2.imshow(&#x27;frame2&#x27;,img)    # 每5毫秒监听一次键盘动作    if cv2.waitKey(5) &amp; 0xFF == ord(&#x27;q&#x27;):        break# 最后，关闭所有窗口cap.release()cv2.destroyAllWindows()\n\n摄像头实时微笑识别# 调用电脑摄像头进行实时人脸+眼睛+微笑识别import cv2face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_frontalface_default.xml&#x27;)eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_eye.xml&#x27;)smile_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+&#x27;haarcascade_smile.xml&#x27;)# 调用摄像头摄像头cap = cv2.VideoCapture(0)while(True):    # 获取摄像头拍摄到的画面    ret, frame = cap.read()    faces = face_cascade.detectMultiScale(frame, 1.3, 2)    img = frame    for (x,y,w,h) in faces:    \t# 画出人脸框，蓝色，画笔宽度微        img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)    \t# 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源        face_area = img[y:y+h, x:x+w]                ## 人眼检测        # 用人眼级联分类器引擎在人脸区域进行人眼识别，返回的eyes为眼睛坐标列表        eyes = eye_cascade.detectMultiScale(face_area,1.3,10)        for (ex,ey,ew,eh) in eyes:            #画出人眼框，绿色，画笔宽度为1            cv2.rectangle(face_area,(ex,ey),(ex+ew,ey+eh),(0,255,0),1)                ## 微笑检测        # 用微笑级联分类器引擎在人脸区域进行人眼识别，返回的eyes为眼睛坐标列表        smiles = smile_cascade.detectMultiScale(face_area,scaleFactor= 1.16,minNeighbors=65,minSize=(25, 25),flags=cv2.CASCADE_SCALE_IMAGE)        for (ex,ey,ew,eh) in smiles:            #画出微笑框，红色（BGR色彩体系），画笔宽度为1            cv2.rectangle(face_area,(ex,ey),(ex+ew,ey+eh),(0,0,255),1)            cv2.putText(img,&#x27;Smile&#x27;,(x,y-7), 3, 1.2, (0, 0, 255), 2, cv2.LINE_AA)        \t# 实时展示效果画面    cv2.imshow(&#x27;frame2&#x27;,img)    # 每5毫秒监听一次键盘动作    if cv2.waitKey(5) &amp; 0xFF == ord(&#x27;q&#x27;):        break# 最后，关闭所有窗口cap.release()cv2.destroyAllWindows()\n\n\n局限性1.仅为人脸检测，非人脸“辩识”，即只能框出人脸的位置，看不出人脸是谁。2.仅能标出静态图片和视频帧上的人脸、人眼和微笑，不能进行“活体识别”，即不能看出这张脸是真人还是手机上的照片，如果用于人脸打卡签到、人脸支付的话会带来潜在的安全风险。3.仅为普通的机器学习方法，没有用到深度学习和深层神经网络。\n","categories":["项目"],"tags":["Python"]},{"title":"JavaWeb","url":"/2023/06/26/JavaWeb/","content":"一、JDBC 原理及访问数据库1. JDBCJDBC：Java DataBase Connectivity 可以为多种关系型数据库 DBMS 提供统一的访问方式，用 Java 操作数据库\nJDBC 实现原理：Java 通过 JDBC 操作 JDBC DriverManager 管理不同数据驱动。通过 JDBC 的API（包括接口、方法、类）\n2.JDBC API 主要功能：三件事，具体是通过以下类&#x2F;接口实现：\nDriverManager：管理 jdbc 驱动\nConnection：连接（通过 DriverManager 产生）\nStatement （PreparedStatement）：增删改查 （通过 Connection 产生）\nCallableStatement：调用数据库中的 存储过程&#x2F; 存储函数 （通过 Connection 产生）\nStatement、PreparedStatement、CallableStatement 都是由 Connection 产生的\nResult：返回的结果集 （上面的 Statement 等产生）\nResultSet：保存结果集 select * from xxx\nnext ()：光标下移，判断是否有下一条数据；true&#x2F;false\nprevious ()：true&#x2F;false\ngetXxx (字段值|位置)：获取具体的字段值\n2.1 Connection 产生操作数据库的对象：Connection 产生 Statement 对象：createStatement ()\nConnection 产生 PreparedStatement 对象：prepareStatement ()\nConnection 产生 CallableStatement 对象：prepareCall ()；\n2.2 Statement 操作数据库：增删改：executeUpdate（）\n查询：executeQuery（）；\n2.3 PreparedStatement 操作数据库：public interface PreparedStatement extends Statement\n因此\n增删改：executeUpdate（）\n查询：executeQuery（）；\n赋值操作 setXxx（）；\n2.4 PreparedStatement 与 Statement 在使用时的区别：\nStatement：\nsql\nexecuteUpdate（sql）\n\nPreparedStatement:\nsql（可能存在占位符 ? ）\n在创建 PreparedStatement 对象时，将 sql 预编译 prepareStatement(sql)\nexecuteUpdate（）\nsetXxx（）替换占位符\n\n\n推荐使用 prepareStatement ：原因如下：\n\n编码更加简便（避免了字符串的拼接）\n\n提高性能（因为有预编译操作，预编译只执行一次）\n\n安全（可以有效防止 sql 注入）\nsql 注入：将客户端输入的内容 和 开发人员的 SQL 语句 混为一体\n\n\n2.5 CallableStatement：调用 存储过程、存储函数connection.prepareCall（存储过程或存储函数名）\n参数格式：\n存储过程（无返回值 return，用 Out 参数代替）：\n {call 存储过程名（参数列表）}\n存储函数（有返回值）：\n { ? &#x3D; call 存储函数名（参数列表）}\n2.5.1 存储过程构造数据库存储过程\ncreate or replace procedure addTwoNum ( num1 in number, num2 in number, result out number)\nas\nbegin\n​        result:&#x3D;num1+num2;\nend;\n&#x2F;\ncstmt = connection.prepareCall(&quot;call addTwoNum(?,?,?)&quot;);cstmt.setInt(1, 10);cstmt.setInt(2, 10);cstmt.execute(); // num1 + num2,execute（）之前处理输入参数，之后处理输出参数// 设置输出参数的类型cstmt.registerOutParameter(3, Types.INTEGER);int result = cstmt.getInt(3);// 获取计算结果System.out.println(result);\n\nJDBC 调用存储过程的步骤：\na. 产生 调用存储过程的对象（CallableStatement） cstmt &#x3D; connection.prepareCall(“call addTwoNum(?,?,?)”);\nb. 通过 setXxx（）处理 输出参数值 cstmt.setInt（1，..）;\nc. 通过 registerOutParameter（）;处理输出参数类型\nd. cstmt.execute（）执行\ne. 接收输出值（返回值）getXxx（）\n2.5.2 存储函数调用存储函数\ncreate or replace function addTwoNumfunction ( num1 in number, num2 in number, result reutnr number)\nreturn number\nas\n result number;\nbegin\n result:&#x3D;num1+num2;\n return result;\nend;\n&#x2F;\nJDBC 调用存储函数与调用存储过程的区别：\n在调用时，注意参数 “? &#x3D; call addTwoNumfunction(?,?)”\n3. JDBC 访问数据库的具体步骤：a. 导入驱动，加载具体的驱动类\nb. 与数据库建立连接\nc. 发送 sql，执行\nd. 处理结果集（查询）\n4. 数据库驱动\n\n\n数据库驱动\n驱动 jar\n具体驱动类\n连接字符串\n\n\n\nMySQL\nmysql-connector-java-x.jar\ncom.mysql.jdbc.Driver\njdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库实例名\n\n\n使用 jdbc 操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连续字符串、用户名、密码\n5. 用 java 实现对数据库的增删改、查public class JDBCDemo &#123;    private static final String URL = &quot;jdbc:mysql://localhost:3306/bookdb&quot;;    private static final String USERNAME = &quot;root&quot;;    private static final String PWD = &quot;159357&quot;;    public static void update() &#123; // 增删改        Connection connection = null;        Statement stmt = null;        try &#123;            //        a.  导入驱动，加载具体的驱动类            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 加载具体的驱动类//        b. 与数据库建立连接            connection = DriverManager.getConnection(URL, USERNAME, PWD);//        c. 发送sql，执行（增删改、查）            stmt = connection.createStatement();//            String sql = &quot;insert into user values(4,&#x27;df&#x27;,&#x27;26262&#x27;)&quot;;//            String sql = &quot;update user set username=&#x27;low&#x27; where id=3&quot;;            String sql = &quot;delete from user where id=4&quot;;            // 执行SQL语句            int count = stmt.executeUpdate(sql);// 返回值表示 增删改 几条数据            // d.处理结果            if (count &gt; 0) &#123;                System.out.println(&quot;操作成功！&quot;);            &#125;        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;            if (stmt != null) stmt.close();                if (connection != null) connection.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void query() &#123; // 查        Connection connection = null;        Statement stmt = null;        ResultSet rs = null;        try &#123;            //        a.  导入驱动，加载具体的驱动类            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 加载具体的驱动类//        b. 与数据库建立连接            connection = DriverManager.getConnection(URL, USERNAME, PWD);//        c. 发送sql，执行（查）            stmt = connection.createStatement();            String sql = &quot;select * from user&quot;;            // 执行SQL语句(增删改executeUpdate（），查executeQuery（）)             rs = stmt.executeQuery(sql);            // d.处理结果            while (rs.next()) &#123;                int id = rs.getInt(&quot;id&quot;);                String username = rs.getString(&quot;username&quot;);                String pwd = rs.getString(&quot;pwd&quot;);//                int id = rs.getInt(1);    下标：从1开始计数//                String username = rs.getString(2);//                String pwd = rs.getString(3);                System.out.println(id+&quot;--&quot;+username+&quot;--&quot;+pwd+&quot;--&quot;);            &#125;        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (rs != null) rs.close();                if (stmt != null) stmt.close();                if (connection != null) connection.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;//        update();        query();    &#125;&#125;\n\n6. 总结 JDBC（模板、八股文）try{\na. 导入驱动包、加载具体驱动类 Class.forName（“具体驱动类”）\nb. 与数据库建立连接 connection &#x3D; DriverManager.getConnection(…);\nc. 通过 connection，获取操作数据库的对象（Statement\\preparedStatement\\callablestatement）\nd.（查询）处理结果集 rs &#x3D; pstmt.executeQuery（）\n while(rs.next()) { rs.getXxx(…) };\n} catch (ClassNotFoundException e) {\n} catch（SQLException e）{\n} catch（Exception e）{\n} finally {\n &#x2F;&#x2F; 打开顺序与关闭顺序相反\n if (rs!&#x3D; null) rs.close();\n if (stmt !&#x3D; null) stmt.close();\n if (connection!&#x3D; null) connection.close();\n}\n–jdbc 中，除了 Class.forName（）抛出 ClassNotFoundException，其余方法全部抛 SQLException\n7. 处理 CLUB[Text]&#x2F;BLOB 类型处理稍大型数据：\na. 存储路径 E:\\\n 通过 JDBC 存储文件路径，然后根据 IO 操作处理\nb.\nCLOB：大文本类型 （小说-&gt; 数据）\nBLOB：二进制\nclob:\n存\n\n先通过 pstmt 的 ? 代替小说内容（占位符）\n再通过 pstmt.setCharacterStream（2, reader , (int) file.length() ）;将上一步的 ? 替换为小说流，注意第三个参数需要是 Int 类型\n\n取\n\n通过 Reader reader &#x3D; rs.getCharacterStream(“NOVEL”); 将 cloc 类型的数据保存到 Reader 对象中\n将 Reader 通过 Writer 输出即可。\n\nblob 与 clob 操作类似\n把 CharacterStream 变为 BinaryStream\n二、JSP 访问数据库JSP 就是在 html 中嵌套 java 代码，因此 java 代码可以写在 jsp 中（&lt;%……%&gt;）\n导包操作：java 项目：1. Jar 复制到工程中 2. 右键该 Jar ：build path\n Web 项目：jar 复制到 WEB-INF 的 lib 里面\n核心：将 java 代码中的 JDBC 代码，复制到 JSP 中的 &lt;% … %&gt;\n注意：如果 jsp 出现错误：The import Xxx cannot be resolved…\n尝试解决步骤：\n a. （可能是 JDK、tomcat 版本不一样）\n b. 清空各种缓存\n c. 删除之前的 tomcat，重新配置 tomcat、重启电脑等\n d. 如果类之前没有包，则将该类加入包中\n1. JavaBean我们将 jsp 中登录操作的代码 转移到了 LoginDao.java；其中 LoginDao 类 就称之为 JavaBean。\nJavaBean 的作用：\n a. 减轻了 jsp 的复杂度\n b. 提高了代码的复用率（以后任何地方的 登录操作，都可以通过调用 LoginDao 实现）\nJavaBean（就是一个类）的定义：满足以下两点，就可以称为 JavaBean\n a. public 修饰的类，public 无参构造\n b. 所有属性（如果有）都是 private，提供 set&#x2F;get （如果 boolean 则 get 可以替换 is）\n使用层面，Java 分为 2 大类：\n a. 封装业务逻辑的 JavaBean (Login.java 封装了登录逻辑) —逻辑\n 可以将 jsp 中的 JDBC 代码，封装到 Login.java 中（Login.java）\n b. 封装数据的 JavaBean （实体类，Student.java Person.java） —数据\n 对应于数据库中的一张表\n Login login &#x3D; new Login(username , upwd); 即用 Login 对象 封装了 2 个数据（用户名 和 密码）\n封装数据的 JavaBean 对应于数据库一张表（Login(name, pwd)）\n封装业务逻辑的 JavaBean 用于操作 一个封装数据的 JavaBean\n可以发现使用，JavaBean 可以简化 代码 （jsp-&gt;jsp+java）、提供代码复用（LoginDao.java）\n三、MVC 设计模式：M：Model 模型：一个功能。用 JavaBean 实现。\nV：View 视图：用于请求，以及与用户交互。使用 html js css jsp jquery 等前端\nC：Controller 控制器：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果返回给 请求处。可以用 jsp 实现，但一般建议使用 Servlet 实现控制器。\nJSP-&gt;Java(Servlet)-&gt;JSP\n四、ServletJava 类必须符合一定的 规范：a. 必须继承 javax.servlet.http.HttpServlet\n b. 重写其中的 doGet()或 doPost()方法\ndoGet(): 接受 并处 所有 get 提交方式的请求\ndoPost(): 接受 并处 所有 post 提交方式的请求\nServlet 要想使用，必须配置\nServlet2.5: web.xml\nServlet3.0: @WebServlet\nServlet2.5: web.xml\n项目的根目录：web、src\n&lt;a href=&quot;WelcomeServlet&quot;&gt;WelcomeServlet&lt;/a&gt; 所在的jsp是在web目录中\n\n因此 发出的请求 WelcomeServlet 是去请求项目的根目录。\nServlet 流程：\n请求 -&gt;  -&gt; 根据  中的  去匹配  中的  ，然后寻找到 ，最终将请求交由该  执行\n&lt;servlet&gt;    &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;servlet.WelcomeServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/WelcomeServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\nServlet3.0 与 Servlet2.5 的区别：\nServlet3.0 不需要在 web.xml 中配置，但需要在 Servlet 类的定义处之上编写\n注释 @WebServlet(“url-pattern 的值”)\n匹配流程：请求地址 与 @WebServlet 中的值 进行匹配，如果匹配成功，则说明请求的就是该注解所对应的类\n根路径：&#x2F;：项目根目录：web src（所有的构建路径）\n例如：在 web 中有一个文件 index.jsp\nsrc 中有一个 Servlet.java\n如果：index.jsp 中请求 &lt;a href&#x3D;”abc” &gt;…，则 寻找范围：既会在 src 根目录中寻找 也会在 web 中寻找\n如果：index.jsp 中请求 &lt;a href&#x3D;”a&#x2F;abc” &gt;…，寻找范围：现在 src 或 web 中找 a 目录，然后再在 a 目录中找 abc\n&#x2F;:\nweb.xml 中的 &#x2F; ：代表的是项目路径 http://localhost:8888/Servlet4Project_war_exploded/\njsp 中的 &#x2F; ：代表服务器根路径 http://localhost:8888/\n构建路径、web：根目录\nServlet 生命周期：5 个阶段加载\n初始化：init()，该方法会在 Servlet 被加载并实例化的以后 执行\n服务：service() -&gt;doGet() doPost\n销毁：destroy()，Servlet 被系统回收时执行\n卸载\ninit()：\n a. 默认第一次访问 Servlet 时会被执行 （只执行一次）\n b. 可以修改为 Tomcat 启动时自动执行\n Ⅰ.Servlet2.5: web.xml 中\n&lt;servlet&gt;    &lt;servlet-name&gt;a&lt;/servlet-name&gt;    &lt;servlet-class&gt;servlet.WelcomeServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  其中&#x27;1&#x27;代表第一次&lt;/servlet&gt;\n\n Ⅱ.Servlet3.0\n @WebServlet(value&#x3D;”&#x2F;WebcomeServlet” , loadOnStartup&#x3D;1 )\nservice() -&gt; doGet（） doPost（）：调用几次，则执行几次\ndestroy()：关闭 tomcat 服务时，执行一次。\nServlet API：由两个软件包组成：对应于 HPPT 协议的软件包、对应于除了 HPPT 协议以外的其他软件包即 Servlet API 可以适用于 任何 通信协议\n我们学习的 Servlet，是位于 javax.servlet.http 包中的类和接口，是基础 HTTP 协议。\nServlet 继承关系：ServletConfig：接口\ngetServletContext（）：获取 Servlet 上下文对象 applicatio\nString getInitParameter（String name）：在当前 Servlet 范围内，获取名为 name 的参数值（初始化参数）\na. ServletContext 中的常见方法（application）：\ngetContextPath()：相对路径\ngetRealPath()：绝对路径\nsetAttribute（）、getAttribute（）\n—&gt;\nString getInitParameter（String name）：在当前 web 范围内，获取名为 name 的参数值（初始化参数）\nHttpServletRequest 中的方法：（同 request），例如 setAttrite()、getCookies()、getMethod()\nHttpServletResponse 中的方法：同 response\n使用建议：Servlet：一个 Servlet 对应一个功能，因此 如果有增删改查 4 个功能，则需要创建 4 个 Servlet\n五、三层架构：与 MVC 设计模式的目标一致：都是为了 解耦合、提高代码复用；\n区别：二者对项目理解的角度不同。\n三层组成：\n表示层（USL，User Show Layer；视图层）\n -前台：对应于 MVC 中的 View：用于和用户交互、界面的显示\n jsp js html css jquery 等 web 前端技术\n 代码位置：web\n -后台：对应于 MVC 中 Controller，用于 控制跳转、调用业务逻辑层\n Servlet（SpringMVC Struts2）\n 代码位置：一般位于 xxx.servlet 包中\n业务逻辑层（BLL，Business Logic Layer；Service 层）\n -接受表示层的请求，调用\n -组装数据访问层，逻辑性的操作（增删改查，删：查+删）\n 一般位于 xxx.service 包（也可以成为： xxx.manager，xxx.bll）\n数据访问层（DAL，Data Access Layer；Dao 层）\n -直接访问数据库的操作，原子性的操作（增删改查）\n 一般位于 xxx.dao 包\n三层间的关系：\n 上层 将请求传递给下层，下层处理后返回给上层\n 上层依赖于下层，依赖：代码的理解，就是持有成员变量\n数据库是由数据访问层去访问的。\n六、MVC 与三层架构的区别\n七、Servlet 中使用 jsp 功能outout 对象在 servlet 中使用\nPrintWriter out = response.getWriter();\n\nsessionrequest.getSession();\n\napplicationrequest.getServletContext();\n\n八、分页 SQL1、分页要实现分页，必须要知道 某一页的 数据 从哪里开始 到哪里结束\n页面大小：每页显示的数据量\n假设每页显示 10 条数据\nsqlserver&#x2F;oracle：从 1 开始计数\n第 n 页 开始 结束\n1 1 10\n2 11 20\n3 21 30\nn (n-1)×10+1 n×10\nmysql：从 0 开始计数\n0 0 9\n1 10 19\n2 20 29\nn n×10 （n+1）×10-1\n结论：\n分页： 第 n 页的数据： 第(n-1)×10+1 条 – 第 n×10 条\nMySQL 实现分页的 sql：\nlimit 从第几页开始，每页显示多少条\n第 0 页\nselect * from student limit 0, 10;\n第 1 页\nselect * from student limit 10, 10;\n第 2 页\nselect * from student limit 20, 10;\n第 n 页\nselect * from student limit n×10, 10;\nMySQL 的分页语句\nselect * from Student limit 页数 × 页面大小,页面大小;\noracle 分页：\nsqlserver&#x2F;oracle：从 1 开始计数\n第 n 页 开始 结束\n1 1 10\n2 11 20\n3 21 30\nn (n-1)×10+1 n×10\nselect * from student where sno &gt;&#x3D;(n-1)×10+1 and sno &lt;&#x3D; n×10; –此种写法的前提：必须是 Id 值连续，否则无法显示\noracle 分页查询语句：\nselect * from\n(\nselect rownum r, t._ from (select s._ from student s order by sno asc) t\n)\nwhere r &gt;(n-1)×10+1 and r &lt;&#x3D; n×10;\n优化：\nselect * from\n(\nselect rownum r, t._ from (select s._ from student s order by sno asc) t\nwhere rownum &lt;&#x3D; n×10\n)\nwhere r &gt;(n-1)×10+1 and r &lt;&#x3D; n×10;\nSQLServer 分页：\nrow_number() over(字段)\nselect * from\n(\nselect row_number() over (sno order by sno asc) as r, * from student\nwhere r &lt;&#x3D; n×10\n)\nwhere r &gt;(n-1)×10+1 and r &lt;&#x3D; n×10;\nSQLServer 分页 sql 与 oralce 分页 sql 的区别：1.rownum, row_number() 2.oracle 需要排序\n分页实现：5 个变量（属性）\n1.数据总数 100 103 （查数据库，select count(*)…）\n2.页面大小（每页显示的数据条数）20 （用户自定义）\n3.总页数\n 总页数 &#x3D; 100 &#x2F; 20 &#x3D; 数据总数 &#x2F; 页面大小\n 页面数 &#x3D; 103 &#x2F; 20 &#x3D; 数据总数 &#x2F; 页面大小 + 1\n –&gt;\n 总页数 &#x3D; 数据总数 % 页面大小 &#x3D;&#x3D; 0 ？ 数据总数 &#x2F; 页面大小：数据总数 &#x2F; 页面大小+1；\n4.当前页（页码） （用户自定义）\n5.当前页的对象集合（实体类集合）：每页所显示的所有数据（10 个人信息）\nList （查数据库，分页 sql）\n// 分页帮助类public class Page &#123;    // 当前页 currentPage    private int currentPage;    // 页面大小 pageSize    private int pageSize;    // 总数据 totalCount    private int totalCount;    // 总页数 totalPage    private int totalPage;    // 当前页的数据集合 students    private List&lt;Student&gt; students;    &#125;\n\n九、文件上传1.上传apache：从 https://mvnrepository.com 下载\ncommons-fileupload.jar 组件\ncommons-fileupload.jar 组件 依赖于 commons-io.jar\na.引入两个 jar 包\nb.\n代码：\n前台 jsp：\n&lt;form action=&quot;UploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;上传照片：&lt;input type=&quot;file&quot; name=&quot;spicture&quot;/&gt;\n\n 表单提交方式必须是 post\n 在表单中必须增加一个属性 enctype&#x3D;”multipart&#x2F;form-data”\n后台 servlet：\n注意的问题：\n 上传到目录 upload;\n 1.如果修改代码，则在 tomcat 重新启动时 会被删除\n 原因：当修改代码的时候，tomcat 会重新编译一份 class 并且重新部署（重新创建各种目录）\n 2.如果不修改代码，则不会删除\n 原因：没有修改代码，class 仍然是之前的 class\n因此，为了防止 上传目录丢失：a.虚拟路径 b.直接更换上传目录 到非 tomcat 目录\n限制上传：类型、大小\n类型：\nString fileName = item.getName(); // a.txt  a.docx  a.pngString ext = fileName.substring(fileName.indexOf(&quot;.&quot;)+1);if (!(ext.equals(&quot;png&quot;)||ext.equals(&quot;gif&quot;)||ext.equals(&quot;jpg&quot;))) &#123;    System.out.println(&quot;图片类型有误！ 格式只能是png gif jpg&quot;);    return; // 终止&#125;\n\n进行判断文件后缀名，如果不是指定照片格式，则终止。\n大小：\nDiskFileItemFactory factory = new DiskFileItemFactory();ServletFileUpload upload = new ServletFileUpload(factory);// 设置文件上传时 用到的临时文件的大小（缓冲区）DiskFileItemFactory设置factory.setSizeThreshold(10240); // 设置临时的缓存文件大小为10KBfactory.setRepository(new File(&quot;C:\\\\Users\\\\Wang\\\\Desktop\\\\uploadtemp&quot;)); // 设置临时文件的目录// 控制上传单个文件的大小 20KB ServletFileUploadupload.setSizeMax(20480); // 字节B// 通过parseRequest解析form中的所有请求字段，并保存到item集合中（即前台传递到的sno sname spicture此时就保存在了item中）                List&lt;FileItem&gt; items = upload.parseRequest(request);\n\n注意：对文件的限制条件 写在 parseRequest 之前\n2.下载不需要依赖任何 jar 包\na.请求（地址 a form），请求 Servlet b.Servlet 通过文件的地址 将文件转为输入流 读到 Servlet 中\nc.通过输出流 将 刚才 已经转为输入流的文件 输出给用户\n注意：下载文件 需要设置 两个响应头\n// 下载文件：需要设置  消息头response.addHeader(&quot;contentType&quot;, &quot;application/octet-stream&quot;); // MIME类型：二进制文件response.addHeader(&quot;content-Disposition&quot;, &quot;attachement;filename=&quot;+fileName); // fileName包含了文件后缀：abc.txt\n\n下载时，文件名乱码问题：\nEdge 解决方法\nURLEncoder.encode(fileName,&quot;UTF-8&quot;)\n\nFireFox、等其他浏览器需用 if 判断处理\n// 对于不同浏览器，进行不同的处理// 获取客户端的User-Agent信息String agent = request.getHeader(&quot;User-Agent&quot;);if (agent.toLowerCase().indexOf(&quot;edge&quot;) != -1) &#123;    // Edge下载 文件乱码问题    response.addHeader(&quot;content-Disposition&quot;, &quot;attachment;filename=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;)); // fileName包含了文件后缀：abc.txt&#125;\n\n十、EL 表达式语言EL：Expression Language，可以替代 JSP 页面中的 JAVA 代码\nservlet（增加数据）-》jsp（显示数据）\n传统的 在 JSP 中用 java 代码显示数据的弊端：类型转化、需要处理 null、代码参杂 -》EL\nEL 操作符：点操作符 . —使用方便\n$&#123;requestScope.student.sno&#125;$&#123;域对象.域对象中的属性.属性.级联属性&#125;\n\n中括号操作符 [“ “] 或 **[‘ ‘] ** —功能强大：可以包含特殊字符（. 、-），获取变量值，获取数组的元素\n$&#123;requestScope[&quot;student&quot;][&quot;sno&quot;]&#125;$&#123;requestScope[&#x27;student&#x27;][&#x27;sno&#x27;]&#125;\n\n当获取变量值时，不加引号，例如存在变量 name，则可以用\n$&#123;requestScope[name]&#125;\n\n可以获取数组的元素，例如定义一个数组 String[] hobbies &#x3D; new String[] {“football”,”pingpang”,”basketball”};\n$&#123;requestScope.hobbies[0]&#125;$&#123;requestScope.hobbies[2]&#125;\n\n获取 map 属性\nMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;cn&quot;, &quot;中国&quot;);map.put(&quot;us&quot;, &quot;美国&quot;);request.setAttribute(&quot;map&quot;, map);\n\n关系运算符 逻辑运算符\n$&#123;3&gt;2&#125;、$&#123;3 gt 2&#125;&lt;br/&gt;\t\t\t\t// 输出结果 true、true$&#123;3&gt;2 || 3&lt;2 &#125;、$&#123;3&gt;2 or 3&lt;2 &#125;\t\t// 输出结果 true、true\n\nEmpty 运算符：判断一个值 null、不存在 –&gt; true\n$&#123;empty requestScope[&quot;my-name&quot;]&#125;&lt;br/&gt;\t\t\t\t\t //输出结果\tfalse不存在的值：$&#123;empty requestScope[&quot;helloworld&quot;]&#125;&lt;br/&gt;\t\t// 输出结果 true为空的值：$&#123;empty requestScope.nullVal&#125;&lt;br/&gt;\t\t\t\t// 输出结果 true\n\nEL 表达式的隐式对象：隐式对象：（不需要 new 就能使用的对象，自带的对象）\na. 作用域的访问对象（EL 域对象）：\npageScope、requestScope、sessionScope、applicationScope\n如果不指定域对象，则会默认根据 从小到大的顺序 依次取值\nb. 参数访问对象：获取表单数据（超链接中传的值、地址栏的值）\n（request.getParameter()、 request.getParamterValues() ）\n ${param} ${paramValues}\nc. JSP 隐式对象：pageContext\n在 JSP 中可以通过 pageContext 获取其他的 jsp 隐式对象；\n因此如果要在 EL 中使用 JSP 隐式对象，就可以通过 pageCount 间接获取\n可以使用此方法，级联获取对象\n$&#123;pageContext.request.serverPort&#125;\n\n使用方法： ${pageContext.方法名去掉() 和 get 并且将首字母小写}\n例如要拿 getRequset( ) ${pageContext.request}\n十一、JSTL：比 EL 更加强大，但需要两个 jar 包：jstl-1.2.jar、standard-1.1.2. jar\n引入 tablib:\n&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;\n\n其中 prefix&#x3D;”c” ：前缀\n核心标签库：通用标签库、条件标签库、迭代标签库\na. 通用标签库：&lt; c:set&gt; 赋值\n\n在某个作用域之中（4 个范围对象），给某个变量赋值\n\n&lt;%--    request.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;);--%&gt;&lt;c:set var=&quot;name&quot; value=&quot;zhangsan&quot; scope=&quot;request&quot; /&gt;$&#123;requestScope.name&#125;\n\n&lt;c:set var&#x3D;”变量名” value&#x3D;”变量值” scope&#x3D;”4 个范围对象的作用域” &#x2F;&gt;\n\n给普通对象赋值\n在某个作用域之中（4 个范围对象），给某个对象的属性赋值（此种方法，不能指定 scope 属性）\n\n\n &lt;c:set target&#x3D;”${requestScope.student}” property&#x3D;”sname” value&#x3D;”zxs” &#x2F;&gt;\n 给 map 对象赋值\n &lt;c:set target&#x3D;”${requestScope.map}” property&#x3D;”cn” value&#x3D;”China” &#x2F;&gt;\n&lt;c:set target&#x3D;”对象” property&#x3D;”对象的属性” value&#x3D;”赋值” &#x2F;&gt;\n注意 &lt; c:set&gt; 可以给不存在的变量赋值（但不能给不存在的对象赋值）\n&lt; c:out&gt;\n\n显示（default&#x3D;”当 value 为空时，显示的默认值”）\n\n传统EL：$&#123;requestScope.student&#125; &lt;br/&gt;c:out方式&lt;c:out value=&quot;$&#123;requestScope.student&#125;&quot; /&gt;  &lt;br/&gt;c:out显示不存在的数据：&lt;c:out value=&quot;$&#123;requestScope.stu&#125;&quot; default=&quot;不存在&quot; /&gt;  &lt;br/&gt;\n\n\n根据 escapexml 选择显示超链接方式\n\ntrue:&lt;c:out value=&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27; escapeXml=&quot;true&quot; /&gt;false:&lt;c:out value=&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27; escapeXml=&quot;false&quot; /&gt;\n\n&lt; c:remove&gt; 删除属性\n&lt;c:remove var=&quot;a&quot; scope=&quot;request&quot; /&gt;\n\nb. 条件标签库：选择if（boolean）\n单重选择\n&lt; c:if test&#x3D;”” &gt;\n&lt;c:if test=&quot;$&#123;10&gt;2&#125;&quot; var=&quot;result&quot; scope=&quot;request&quot; &gt;    真    $&#123;requestScope.result&#125;&lt;/c:if&gt;\n\n多重选择\nif else if… esle if ….\n&lt; c:choose &gt;\n &lt; c:when test&#x3D;”…”&gt; &lt; &#x2F;c:when&gt;\n &lt; c:when test&#x3D;”…”&gt; &lt; &#x2F;c:when&gt;\n &lt; c:otherwise&gt; &lt; &#x2F;c:otherwise&gt;\n&lt; &#x2F;c:choose &gt;\n注意：在使用 test&#x3D;“” 一定要注意是否有空格\n例如：test&#x3D;“${10&gt;2}” true\n test&#x3D;“${10&gt;2} ” 非 true\nc. 迭代标签库：循环for（int i&#x3D;0; i&lt;5; i++ ）\n&lt;c:forEach begin=&quot;0&quot; end=&quot;5&quot; step=&quot;1&quot; varStatus=&quot;status&quot;&gt;\t// 0-5，varStatus显示下标次数    $&#123;status.index&#125;    test...&lt;/c:forEach&gt;\n\nfor（String str : names）\n&lt;c:forEach var=&quot;name&quot; items=&quot;$&#123;requestScope.names&#125;&quot; &gt;    $&#123;name&#125;-&lt;/c:forEach&gt;\n\n十二、过滤器与监听器过滤器：实现一个 Filter 接口\ninit（）、destroy（）原理、执行时机同 Servlet\n配置过滤器，类似 Servlet\n通过 doFilter（）处理拦截，并且通过 chain.doFilter(request, response); 放行请求\npublic class MyFilter implements Filter &#123; // 过滤器    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;filter...init...&quot;);    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        System.out.println(&quot;拦截请求。。。。。。&quot;);        chain.doFilter(request, response); // 放行        System.out.println(&quot;拦截响应。。。。。。&quot;);    &#125;    @Override    public void destroy() &#123;        System.out.println(&quot;filter...destroy...&quot;);    &#125;&#125;\n\nfilter 映射\n只拦截 访问 Myservlet 的请求\n&lt;url-pattern&gt;/MyServlet&lt;/url-pattern&gt;\n\n拦截一切请求（每一次访问，都会被拦截）\n&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n\n通配符\ndispatcher 请求方式：\nREQUEST：拦截 HTTP 请求 get post 常用\nFORWARD：只拦截 通过 请求转发方式的请求 常用\nINCLUDE：只拦截通过 request.getRequestDispatcher(“”).include()、通过&lt; jsp:include page&#x3D;”…”&#x2F;&gt;发出的请求\nERROR：只拦截&lt; error-page&gt;发出的请求\n过滤器中 doFilter 方法参数：ServletRequest\n在 Servlet 中的方法参数：HttpServletRequest\n过滤器链\n可以配置多个过滤器，过滤器的先后顺序 是由 web.xml 中的位置决定的\n监听器：开发步骤：\n\n编写监听器，实现接口\n配置 web.xml\n\n监听对象：request session application\na. 监听对象的创建和销毁\nrequest：ServletRequestListener\nsession：HttpSessionListener\napplication：ServletContextListener\n每个监听器 各自提供了 2 个方法：监听开始、监听结束的方法\nb. 监听对象中属性的变更\nrequest：ServletRequestAttributeListener\nsession：HttpSessionAttributeListener\napplication：ServletContextAttributeListener\n每个监听器 各自提供了 3 个方法：新增、替换、删除属性\n例如：ServletRequest\n@Overridepublic void attributeAdded(ServletRequestAttributeEvent srae) &#123;    String attrName = srae.getName(); // 目前正在操作的属性名    Object attrValue = srae.getServletRequest().getAttribute(attrName);    System.out.println(&quot;ServletRequest【增加】属性：属性名&quot;+attrName+&quot;,属性值：&quot;+attrValue);&#125;@Overridepublic void attributeRemoved(ServletRequestAttributeEvent srae) &#123;    System.out.println(&quot;ServletRequest【删除】属性：属性名&quot;+srae.getName());&#125;@Overridepublic void attributeReplaced(ServletRequestAttributeEvent srae) &#123;    String attrName = srae.getName();    Object attrValue = srae.getServletRequest().getAttribute(attrName);    System.out.println(&quot;ServletRequest【替换】属性：属性名&quot;+attrName+&quot;,属性值：&quot;+attrValue);&#125;\n\nsession 对象的四种状态：绑定解绑、钝化活化监听绑定与解绑：HttpSessionBindingListener 不需要配置 web.xml\na. session.setAttribute（“a”,xxx） 对象 a【绑定】到 sesssion 中\nb. session.removeAttribute（“a”）将对象 a 从 session 中【解绑】\n监听 session 对象的钝化、活化：HttpSessionActivationListener 不需要配置 web.xml\nc. 钝化：内存-》硬盘\nd. 活化：硬盘-》活化\n如何钝化、活化：配置 tomcat 安装目录&#x2F;conf&#x2F;context.xml\n钝化、活化的本质 就是序列化、反序列化：序列化、反序列化需要实现 Serializable\n总结：钝化、活化 实际执行 是通过 context.xml 中进行配置 而进行。\n 活化：session 中获取某一个对象时，如果该对象不存在，则直接尝试从之前钝化的文件中获取（活化）\n HttpSessionActivationListener 只是负责 在 session 钝化和活化时 予以监听.\n 需要实现 Serializable\n十三、Ajax，JQuery 与 JSONAjax：异步 js 和 xml\n异步刷新:如果网页中某个地方需要修改，异步刷新可以使:只刷新需要修改的地方，而页面中其他地方保持不变。\n例如：百度搜索框、视频的点赞\n实现：\njs：XMLHttpReques 对象XMLHttpReques 对象的方法：\nopen（方法名（提交方式 get|post），服务器地址，true）：与服务端建立连接\nsend（）：\n get：send（null）\n post：send（参数值）\nsetRequestHeader（header,value）：\n get：不需要设置此方法\n post：需要设置：\n a. 如果请求元素中包含了 文件上传：\n setRequestHeader（”Content-Type”,”multiparty&#x2F;form-data”）;\n b. 不包含了 文件上传\n setRequestHeader（”Content-Type”,”application&#x2F;x-www-form-urlencoded”）;\nXMLHttpReques 对象的属性：\nreadyState：请求状态 只有状态为 4 代表请求完毕\nstatus：响应状态 只有 200 代表响应正常\nonreadystatechange：回调函数\nresponseTest：响应格式为 String\nresponseXML：响应格式为 XML\njquery：推荐$.ajax（{\nurl：服务器地址，\n请求方式：get|post\ndata：请求数据，\nsuccess：function（result,testStatus）\n{\n}，\nerror：function(xhr,errorMessage,e) {\n}\n}）;\n&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;    function register() &#123;        var $mobile = $(&quot;#mobile&quot;).val();        $.ajax(&#123;            url:&quot;MobileServlet&quot;,            请求方式:&quot;post&quot;,            data:&quot;mobile=&quot;+$mobile,            success:function (result,testStatus) &#123;                if (result == &quot;true&quot;) &#123;                    alert(&quot;已存在!注册失败！&quot;);                &#125; else &#123;                    alert(&quot;注册成功！&quot;);                &#125;            &#125;,            error:function (xhr,errorMessage,e) &#123;                alert(&quot;系统异常！&quot;);            &#125;        &#125;)    &#125;&lt;/script&gt;\n\n$.get（\n服务器地址，\n请求数据，\nfunction(result) {},\n预期返回值类型（string\\xml）\n）；\n$.post（\n服务器地址，\n请求数据，\nfunction(result) {},\n“xml” 或 “json” 或 “text”\n）；\n十四、JNDI 与 tomcat 连接池1. JNDI：java 命名与目录接口\n范围对象：4 大作用域对象、4 大范围对象\npageContext &lt; request &lt; session &lt; application\npageContext：定义的变量有效期为当前页面，页面跳转后失效\nrequest：一次请求有效\nsession：一次会话有效\napplication：一次项目运行期间都有效（项目打开后，只有不关闭，永远有效）\n当我们需要多个项目都有效，除了数据库等，还可以使用 JDNI\nJNDI：将某一个资源（对象），以配置文件（tomcat &#x2F; conf &#x2F; context.xml ）的形式写入；\n在配置文件（tomcat &#x2F; conf &#x2F; context.xml ）中加入：\n\n\nString jndiName = &quot;jndiValue&quot;;\n\nString：写在 type 中，需要写包，java.lang.String\njndiName：元素名写在 name 中\njndiValue：赋的值写在 value 中\n2. JNDI 实现步骤：tomcat &#x2F; conf &#x2F; context.xml 配置：\n\n\njsp 中使用：\n&lt;%    Context ctx = new InitialContext();    String textJndi = (String)ctx.lookup(&quot;java:comp/env/jndiName&quot;);    out.print(textJndi);%&gt;\n\n注意：java:comp&#x2F;env&#x2F;… （固定格式）\n3. 连接池常见的连接池：Tomcat-dbcp、dbcp、c3p0、druid\n可以用 数据源 （javax.sql.DataSource）管理连接池 （数据源包含数据库连接池）\n连接池：怎么用？\n不用连接池\nClass.forName();\nConnection connection &#x3D; DriverManager.getConnection();\n使用连接池的核心：将连接的指向改了，现在指向的是数据源 而不是数据库\n… -&gt; DataSource ds &#x3D; …..\nConnection connection &#x3D; ds.getConnection; &#x2F;&#x2F; 指向的是数据源的连接\nTomcat-dbcp 连接池：a. 类似 jndi，在 context.xml 中配置数据库，加入以下代码\n&lt;Resource name=&quot;student&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot;      maxActive=&quot;400&quot; maxIdle=&quot;20&quot; maxWait=&quot;5000&quot; username=&quot;root&quot; password=&quot;159357&quot;      driverClassName=&quot;com.mysql.cj.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/login&quot; /&gt;\n\nb. 在项目 web.xml 中配置：\n&lt;resource-ref&gt;    &lt;res-ref-name&gt;student&lt;/res-ref-name&gt;    &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;    &lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt;\n\nc. 使用数据源\n 更改 连接对象 Connection 的获取方式：\n 传统 JDBC 方式：\n connection = DriverManager.getConnection(URL, USER, PWD);\n 数据源方式：\nContext ctx = new InitialContext(); // context.xmlds = (DataSource)ctx.lookup(&quot;java:comp/env/student&quot;);connection = ds.getConnection();\n\nTomcat - dbcp 数据源总结：\n\n配置数据源（context.xml）\n指定数据源（web.xml）\n用数据源：通过数据源获取 Connection\n\ndbcp 连接池：需要引入 jar 包：commons-dbcp-1.4.jar、commons-pool-1.6.jar\n BasicDataSource、BasicDataSourceFactory\nBasicDataSource 方式：硬编码方式 BasicDataSource 对象设置各种属性\n\n// 获取dbcp方式的ds对象public static DataSource getDataSourceWithDBCP() &#123;    BasicDataSource dbcp = new BasicDataSource();    dbcp.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);    dbcp.setUrl(&quot;jdbc:mysql://localhost:3306/login&quot;);    dbcp.setUsername(&quot;root&quot;);    dbcp.setPassword(&quot;159357&quot;);    dbcp.setInitialSize(20);    dbcp.setMaxActive(10);    return dbcp;&#125;\n\nBasicDataSourceFactory 方式：配置方式（.properties 文件，编写方式 key &#x3D; value ） 常用这种dbcpconfig.properties\npublic static DataSource getDataSourceWithDBCPByProperties() throws Exception &#123;        DataSource dbcp = null;        Properties props = new Properties();        // 将文件变为数据流        InputStream input = new DBCPDemo().getClass().getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;);        props.load(input); // 需要传入数据流        // 只需要记住该行代码        dbcp = BasicDataSourceFactory.createDataSource(props);        return dbcp;    &#125;\n\nDataSource 是所有 sql 是所有数据源的上级类。 BasicDataSource 是 dbcp 类型的数据源\nComboPooledDataSource 是 c3p0 的数据源；\nc3p0 连接池：核心类：ComboPooledDataSource\n\n两种方式：硬编码与配置文件\n-》合二为一，通过 ComboPooledDataSource 的构造方法参数区分：如果无参——硬编码；有参——配置文件\njar 包：c3p0.jar\n如果无参——硬编码\npublic static DataSource getDataSourceWithC3P0() throws PropertyVetoException &#123;    ComboPooledDataSource c3p0 = new ComboPooledDataSource();    c3p0.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);    c3p0.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/login&quot;);    c3p0.setUser(&quot;root&quot;);    c3p0.setPassword(&quot;159357&quot;);    return c3p0;&#125;\n\n有参——配置文件（c3p0-config.xml）文件\n先写配置文件：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt;    &lt;!-- 默认 --&gt;    &lt;default-comfig&gt;        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;password&quot;&gt;159357&lt;/property&gt;        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/login&lt;/property&gt;        &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt;    &lt;/default-comfig&gt;    &lt;named-config name=&quot;jun&quot;&gt;        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;password&quot;&gt;159357&lt;/property&gt;        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/login&lt;/property&gt;    &lt;/named-config&gt;&lt;/c3p0-config&gt;\n\n在代码中传入参数，参数为中的 name:\npublic static DataSource getDataSourceWithC3P0ByXml() &#123;    ComboPooledDataSource c3p0 = new ComboPooledDataSource(&quot;jun&quot;);    return c3p0;&#125;\n\n总结：所有连接池的思路：\n\n硬编码，某个连接池数据源的 对象 ds &#x3D; new XxxDataSource();\nds.setXxx();\nreturn ds;\n\n配置文件， ds &#x3D; new XxxDataSource(); 加载配置文件，return ds;\n\n\n数据源工具类：\n 可将 dbcp、c3p0 整合到一个类中，方便使用。\n// 连接池帮助类public class DataSourceUtil &#123;    // dbcp连接池    public static DataSource getDataSourceWithDBCP() &#123;        BasicDataSource dbcp = new BasicDataSource();        dbcp.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dbcp.setUrl(&quot;jdbc:mysql://localhost:3306/login&quot;);        dbcp.setUsername(&quot;root&quot;);        dbcp.setPassword(&quot;159357&quot;);        dbcp.setInitialSize(20);        dbcp.setMaxActive(10);        return dbcp;    &#125;    public static DataSource getDataSourceWithDBCPByProperties() throws Exception &#123;        DataSource dbcp = null;        Properties props = new Properties();        // 将文件变为数据流        InputStream input = new DBCPDemo().getClass().getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;);        props.load(input); // 需要传入数据流        // 只需要记住该行代码        dbcp = BasicDataSourceFactory.createDataSource(props);        return dbcp;    &#125;    // c3p0连接池    public static DataSource getDataSourceWithC3P0() throws PropertyVetoException &#123;        ComboPooledDataSource c3p0 = new ComboPooledDataSource();        c3p0.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);        c3p0.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/login&quot;);        c3p0.setUser(&quot;root&quot;);        c3p0.setPassword(&quot;159357&quot;);        return c3p0;    &#125;    public static DataSource getDataSourceWithC3P0ByXml() &#123;        ComboPooledDataSource c3p0 = new ComboPooledDataSource(&quot;jun&quot;);        return c3p0;    &#125;&#125;\n\n使用方法：\n\n十五、ApacheDBUtil下载 commons-dbutils-1.7.jar，其中包含以下几个重点类：\nDbUtils、QueryRunner、ResultSetHandler\n1. DbUtils：辅助包含了关闭连接、关闭结果、关闭提交、提交事务、传入驱动名，加载并注册 JDBC 驱动程序\n2. QueryRunner：增删改、查 update()\n query()\n3. ResultSetHandler 的实现类如果是查询，则需要 ResultSetHandler 接口，有很多实现类，一个实现类对应于一种 不同的查询结果类型\n ——Object[] {1，zs}\n 实现类ArrayHandler：返回结果集中的第一行数据，并用 Object[] 接收\n 实现类ArrayListHandler：返回结果集中的多行数据，List&lt;Object[]&gt;\n ——Student (1，zs)\n BeanHandler：返回结果集中的第一行数据，用对象（Student）接收\n// 查询单行数据（放入对象中）public static void testBeanHandler() throws SQLException &#123;    QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());    Student Student = runner.query(&quot;select * from student where sno &gt; ?&quot;, new BeanHandler&lt;Student&gt;(Student.class), 1);    System.out.println(Student.getSno() + &quot;,&quot; + Student.getSname());&#125;\n\n反射会通过无参构造来创建对象\n BeanListHandler：返回结果集中的多行数据，List students 接收\n// 查询多行数据（放入对象中）public static void testBeanListHandler() throws SQLException &#123;    QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());    List&lt;Student&gt; students = runner.query(&quot;select * from student where sno &gt; ?&quot;, new BeanListHandler&lt;Student&gt;(Student.class), 1);    for (Student student:students) &#123;        System.out.println(student.getSno() + &quot;,&quot; + student.getSname());    &#125;&#125;\n\n BeanMapHandler：可以给每个数据加个 key 1：stu , 2：stu12 ， 3：stu3\n// 查询单行数据（放入map对象中）public static void testBeanMapHandler() throws SQLException &#123;    QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0ByXml());    Map&lt;Integer, Student&gt; studentMap = runner.query(&quot;select * from student where sno &gt; ?&quot;, new BeanMapHandler&lt;Integer, Student&gt;(Student.class, &quot;sno&quot;), 1);    Student student = studentMap.get(5);    System.out.println(student.getSno() + &quot;,&quot; + student.getSname());&#125;\n\n ——Map 查询的结果为 {sno&#x3D;1，sname&#x3D;zs }\n\nMapHandler：返回结果集中的第一行数据\n{sno&#x3D;1，sname&#x3D;zs}\n\nMapListHandler：返回结果集中的多行数据\nsno&#x3D;1，sname&#x3D;zs sno&#x3D;2，sname&#x3D;ls\n\nKeyedHandler：zs&#x3D;sno&#x3D;1，sname&#x3D;zs,ls&#x3D;sno&#x3D;2,sname&#x3D;ls\n\n\n ——\n ColumListHandler：把结果集中的某一列 保存到 List 中\n例如： 2，ls 3，ww\n结果 {ls，ww}\n ScalarHandler：单值结果集\n问题：查询实现类的参数问题\nquery（…，Object…params ）\n其中 Object…params 代表可变参数：既可以写单值，也可以写数组\n4. apache dbutil 增删改增：\npublic static void add() throws PropertyVetoException, SQLException &#123;    QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0());    int count = runner.update(&quot;insert into student values(?,?,?,?)&quot;, new Object[]&#123;11, &quot;天天&quot;, 18, &quot;北京&quot;&#125;);    System.out.println(count);&#125;\n\n删：\npublic static void delete() throws PropertyVetoException, SQLException &#123;    QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0());    int count = runner.update(&quot;delete from student where sno = ? &quot;, 10);    System.out.println(count);&#125;\n\n改：\npublic static void update() throws PropertyVetoException, SQLException &#123;    QueryRunner runner = new QueryRunner(DataSourceUtil.getDataSourceWithC3P0());    int count = runner.update(&quot;update student set sno = ? where sname = ? &quot;, new Object[]&#123;10,&quot;天天&quot;&#125;);    System.out.println(count);&#125;\n\n自动提交事务 update（sql，参数）；update（sql）;\n手动提交事务 update（connection，sql，参数）；\n5. 手动提交事务例如银行转账：zs-1000；li+1000； 需要一起提交\n基础知识：\n ①如果既要保存数据安全，又要保证性能，可以考虑ThreadLocal\nThreadLocal：可以为每个线程 复制一个副本。每个线程可以访问自己内部的副本。 别名 线程本地变量\nset（）：给 tl 中存放一个 变量\nget（）：给 tl 中获取变量（副本）\nremove（）：删除副本\n ②对于数据库来说，一个连接对应于一个事务，一个事务可以包含多个 DML 操作（增删改）\n Service（多个原子操作）–》Dao（原子操作）\n update：如果给每个 dao 操作 都创建一个 connection，则 多个 dao 操作对应于多个事务；\n 但是 一般来说，一个业务（Service）中的多个 dao 操作 应该包含在一个事务中。\n ——》解决：ThreadLocal，在第一次 dao 操作时，真正的创建一个 connnection 对象，然后\n 在其他几次 dao 操作时，借助于 ThreadLocal 本身特性，自动将该 connection 复制多个（connection 只创建了一个，因此该 connection 中的所有操作，必然对应于同一个事务；并且 ThreadLocal 将\nconnection 在使用层面复制了多个，因此可以同时完成多个 dao 操作）\n事务流程：开始事务（将自动事务–&gt;手动提交）–&gt;进行各种 DML–&gt;正常，将刚才所有 DML 全部提交（全部成功）\n –&gt;失败（异常），将刚才所有 DML 全部回滚（全部失败）\n事务的操作 全部和连接 Connection 密切相关\n十六、元数据元数据：描述数据的数据\n\n\n三类：数据库元数据、参数元数据、结果集元数据\n1. 数据库元数据：DataBaseMetaDataConnection——》DataBaseMetaData\npublic static void databaseMetaData() &#123;    try &#123;        Class.forName(DRIVER);        Connection connection = DriverManager.getConnection(URL, USER, PWD);        // 数据库元信息        DatabaseMetaData dbMetadata = connection.getMetaData();        String dbName = dbMetadata.getDatabaseProductName();        System.out.println(&quot;数据库名：&quot; + dbName);        String dbVersion = dbMetadata.getDatabaseProductVersion();        System.out.println(&quot;数据库版本：&quot; + dbVersion);        String driverName = dbMetadata.getDriverName();        System.out.println(driverName);        String url = dbMetadata.getURL();        System.out.println(url);        String userName = dbMetadata.getUserName();        System.out.println(userName);        System.out.println(&quot;------------------&quot;);        ResultSet rs = dbMetadata.getPrimaryKeys(null, &quot;ROOT&quot;, &quot;STUDENT&quot;);        while (rs.next()) &#123;            Object tableName = rs.getObject(3);            Object columnName = rs.getObject(4);            System.out.println(tableName + &quot;--&quot; + columnName);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\n2. 参数元数据：ParameterMetaDatapstmt——》 ParameterMetaData\ngetParameterCount()：获取 SQL 语句中，参数占位符的个数\n因为带参数的 SQL 是通过 pstmt 执行的，因此需要从 pstmt 中获取参数元数据相关信息\npublic static void parameterMetaData() &#123;    try &#123;        Class.forName(DRIVER);        Connection connection = DriverManager.getConnection(URL, USER, PWD);        String sql = &quot;select * from student where sno = ? and sage = ?&quot;;        PreparedStatement pstmt = connection.prepareStatement(sql);        // 通过pstmt获取参数元数据        ParameterMetaData metaData = pstmt.getParameterMetaData();        int count = metaData.getParameterCount();        System.out.println(&quot;参数个数：&quot; + count);        for (int i = 1; i &lt;= count; i++) &#123;            String typeName = metaData.getParameterTypeName(i);            System.out.println(typeName);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\n3. 结果集元数据：ResultSetMetaDataResultSet——》 ResultSetMetaData\nMysql必须在 url 中附加参数配置：\njdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名?generateSimpleParameterMetadata&#x3D;true\nprivate static final String URL = &quot;jdbc:mysql://localhost:3306/login?generateSimpleParameterMetadata=true&quot;;public static void resultSetMetaData() &#123;    try &#123;        Class.forName(DRIVER);        Connection connection = DriverManager.getConnection(URL, USER, PWD);        String sql = &quot;select * from student&quot;;        PreparedStatement pstmt = connection.prepareStatement(sql);        ResultSet rs = pstmt.executeQuery();        ResultSetMetaData metaData = rs.getMetaData();        int count = metaData.getColumnCount();        System.out.println(&quot;列的个数：&quot; + count);        System.out.println(&quot;-------------&quot;);        for (int i=1;i&lt;=count;i++) &#123;            String columnName = metaData.getColumnName(i);            String columnTypeName = metaData.getColumnTypeName(i);            System.out.println(columnName+&quot;\\t&quot;+columnTypeName);        &#125;        while (rs.next()) &#123;            for (int i = 1; i&lt;=count; i++) &#123;                System.out.print(rs.getObject(i) + &quot;\\t&quot;);            &#125;            System.out.println();        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\n十七、自定义标签验证码防止恶意攻击\n强制刷新：除了禁止缓存以外，还需要给服务端传递一个唯一的参数（没有实际用处）。随机数、时间\n先通过 jsp 制作一个可以随机生成验证码图片\n&lt;%@ page import=&quot;java.awt.*&quot; %&gt;&lt;%@ page import=&quot;java.util.Random&quot; %&gt;&lt;%@ page import=&quot;java.awt.image.BufferedImage&quot; %&gt;&lt;%@ page import=&quot;javax.imageio.ImageIO&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;image/jpeg; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%!    // 随机产生颜色值    public Color getColor() &#123;        Random ran = new Random();        int r = ran.nextInt(256);// 产生0-255随机数        int g = ran.nextInt(256);        int b = ran.nextInt(256);        return new Color(r,g,b); // red green blue 0-255    &#125;    // 产生验证码值    public String getNum() &#123;        // 0-8999   1000-9999        int ran = (int)(Math.random() * 9000) + 1000;        return String.valueOf(ran);    &#125;%&gt;&lt;%    // 禁止缓存，防止验证码过期    response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);    response.setHeader(&quot;Cache-control&quot;, &quot;no-cache&quot;);    response.setHeader(&quot;Expires&quot;, &quot;0&quot;);    // 绘制验证码    BufferedImage image = new BufferedImage(80, 30, BufferedImage.TYPE_INT_RGB);    // 画笔    Graphics graphics = image.getGraphics();    graphics.fillRect(0, 0, 80, 30);    graphics.setFont(new Font(&quot;seif&quot;, Font.BOLD, 20));    // 绘制验证码    graphics.setColor(Color.BLACK);    String checkCode = getNum();    StringBuffer sb = new StringBuffer();    for (int i=0;i&lt;checkCode.length();i++) &#123;        sb.append(checkCode.charAt(i)+&quot; &quot;); // 验证码的每一位数字    &#125;    graphics.drawString(sb.toString(), 15, 20); // 绘制验证码    // 绘制干扰线条    for (int i =0;i&lt;30;i++) &#123;        Random ran = new Random();        int xBegin = ran.nextInt(80);        int yBegin = ran.nextInt(30);        int xEnd = ran.nextInt(xBegin + 10);        int yEnd = ran.nextInt(yBegin + 10);        graphics.setColor(getColor());        // 绘制线条        graphics.drawLine(xBegin, yBegin, xEnd, yEnd);    &#125;    // 将验证码真实值  保存在session中，供使用时比较真实性    session.setAttribute(&quot;checkCode&quot;, checkCode);    // 真实的产生图片    ImageIO.write(image, &quot;jpeg&quot;, response.getOutputStream());    // 关闭    out.clear();    out = pageContext.pushBody();%&gt;\n\n前台 jsp:\n&lt;html&gt;    &lt;head&gt;        &lt;title&gt;验证码&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function reloadCheckImg() &#123;                $(&quot;img&quot;).attr(&quot;src&quot;,&quot;img.jsp?t=&quot;+(new Date().getTime()));            &#125;            $(document).ready(function () &#123;                $(&quot;#checkCodeId&quot;).blur(function () &#123;                    var $checkCode = $(&quot;#checkCodeId&quot;).val();                    // 校验：文本框中输入的值 发送到服务端                    // 服务端：获取文本框输入的值，和真实验证码图片中的值对比，并返回验证结果                    $.post(                        &quot;CheckCodeServlet&quot;,                        &quot;checkCode=&quot;+$checkCode,                        function (result) &#123; // 图片地址（imgs/right.jpg imgs/wrong.jpg）                            var resultHtml = $(&quot;&lt;img src=&#x27;&quot;+result+&quot;&#x27; height=&#x27;15&#x27; width=&#x27;15&#x27;&gt;&quot;)                            $(&quot;#tip&quot;).html(resultHtml);                        &#125;                    );                &#125;);            &#125;);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        验证码：        &lt;input type=&quot;text&quot; name=&quot;checkCode&quot; id=&quot;checkCodeId&quot; size=&quot;4&quot; /&gt;        &lt;%-- 验证码 --%&gt;        &lt;a href=&quot;javascript:reloadCheckImg();&quot;&gt;&lt;img src=&quot;img.jsp&quot; /&gt;&lt;/a&gt;        &lt;span id=&quot;tip&quot;&gt;&lt;/span&gt;    &lt;/body&gt;&lt;/html&gt;\n\n以及 Servlet\npublic class CheckCodeServlet extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        String resultTip = &quot;imgs/wrong.jpg&quot;;        // 获取用户输入的验证码        String checkCodeClient = request.getParameter(&quot;checkCode&quot;);        // 真实的验证码值        String checkCodeServer = (String) request.getSession().getAttribute(&quot;checkCode&quot;);        if (checkCodeServer.equals(checkCodeClient)) &#123;            resultTip = &quot;imgs/right.jpg&quot;;        &#125;        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter writer = response.getWriter();        writer.write(resultTip);        writer.flush();        writer.close();    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    &#125;&#125;\n","categories":["高级语言"],"tags":["Java"]},{"title":"Java工具类","url":"/2023/05/17/Java%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"ChatGPT 流式输出调用 ChatGPT 接口，采用流式输出：\n先在控制台进行流式输出，下面是效果图：\n\n本次使用个人 chagpt 接口，可换乘 openai：\n引入okhttp3\n&lt;dependency&gt;    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;    &lt;version&gt;4.9.1&lt;/version&gt;&lt;/dependency&gt;\n\n输出到控制台：@GetMapping(&quot;/fast&quot;)public Result fastChat(String msg) &#123;    OkHttpClient client = new OkHttpClient();    MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);    String jsonInputString = &quot;&#123;&quot; +        &quot;\\&quot;model\\&quot;: \\&quot;chatglm2-6b\\&quot;,&quot; +        &quot;\\&quot;messages\\&quot;: [&#123;&quot; +        &quot;\\&quot;role\\&quot;: \\&quot;user\\&quot;,&quot; +        &quot;\\&quot;content\\&quot;: \\&quot;&quot;+msg+&quot;\\&quot;&quot; +        &quot;&#125;],&quot; +        &quot;\\&quot;temperature\\&quot;: 0.7,&quot; +        &quot;\\&quot;n\\&quot;: 1,&quot; +        &quot;\\&quot;max_tokens\\&quot;: 1024,&quot; +        &quot;\\&quot;stop\\&quot;: [],&quot; +        &quot;\\&quot;stream\\&quot;: true,&quot; +        &quot;\\&quot;presence_penalty\\&quot;: 0,&quot; +        &quot;\\&quot;frequency_penalty\\&quot;: 0&quot; +        &quot;&#125;&quot;;    RequestBody body = RequestBody.create(JSON, jsonInputString);    Request request = new Request.Builder()        .url(&quot;http://192.168.123.170:2421/chat/fastchat&quot;)        .post(body)        .build();    try (Response response = client.newCall(request).execute()) &#123;        if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);        // 使用 InputStreamReader 和 BufferedReader 来处理UTF-8字符流        try (InputStreamReader isr = new InputStreamReader(response.body().byteStream(), StandardCharsets.UTF_8);             BufferedReader reader = new BufferedReader(isr)) &#123;            int intChar;            while ((intChar = reader.read()) != -1) &#123;                char ch = (char) intChar;                System.out.print(ch);                Thread.sleep(50); // 延迟，以便一个接一个地输出字符            &#125;        &#125;        return Result.ok(&quot;Streamed successfully!&quot;);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return Result.fail(&quot;fail&quot;);&#125;\n\nSSE 与前端进行流式输出可以看出 ChatGPT 的回答方式采用的是event-stream，及Server-Sent Events, SSE，这是一种允许服务器向客户端推送事件的技术\n\n下面使用java与vue3进行演示\n\n全局异常类整体结构：\n- exception\t- GlobalExceptionHandler\t- GlobalException- result\t- Result\t- ResultCodeEnum\n\n\n创建全局异常枚举类ResultCodeEnum\n\n@Getterpublic enum ResultCodeEnum &#123;\tSUCCESS(200, &quot;成功&quot;),\tFAIL(201, &quot;失败&quot;),\tSERVICE_ERROR(2012, &quot;服务异常&quot;),\tDATA_ERROR(204, &quot;数据异常&quot;),\tILLEGAL_REQUEST(205, &quot;非法请求&quot;),\tREPEAT_SUBMIT(206, &quot;重复提交&quot;),\tLOGIN_AUTH(208, &quot;未登陆&quot;),\tPERMISSION(209, &quot;没有权限&quot;);\tprivate final Integer code;\tprivate final String message;\tprivate ResultCodeEnum(Integer code, String message) &#123;\t\tthis.code = code;\t\tthis.message = message;\t&#125;&#125;\n\n\n创建Result\n\n@Datapublic class Result&lt;T&gt; &#123;\t// 状态码\tprivate Integer code;\t// 信息\tprivate String message;\t// 数据\tprivate T data;\t// 构造私有化\tprivate Result() &#123;\t&#125;\t// 设置数据，返回方法\tpublic static &lt;T&gt; Result&lt;T&gt; build(T data, Integer code, String message) &#123;\t\t// 创建Result对象，设置值，返回对象\t\tResult&lt;T&gt; result = new Result&lt;&gt;();\t\t// 判断data是否为空\t\tif (data != null) &#123;\t\t\t// 设置数据到result对象中\t\t\tresult.setData(data);\t\t&#125;\t\t// 设置其他值\t\tresult.setCode(code);\t\tresult.setMessage(message);\t\t// 返回结果\t\treturn result;\t&#125;\t// 成功\tpublic static &lt;T&gt; Result&lt;T&gt; ok(T data) &#123;\t\treturn build(data, ResultCodeEnum.SUCCESS.getCode(), ResultCodeEnum.SUCCESS.getMessage());\t&#125;\t// 失败\tpublic static &lt;T&gt; Result&lt;T&gt; fail(T data) &#123;\t\treturn build(data, ResultCodeEnum.FAIL.getCode(), ResultCodeEnum.FAIL.getMessage());\t&#125;&#125;\n\n\n创建统一异常处理类GlobalExceptionHandler\n\n// AOP面向切面@ControllerAdvicepublic class GlobalExceptionHandler &#123;\t@ExceptionHandler(Exception.class)\t@ResponseBody\tpublic Result error(Exception e)&#123;\t\te.printStackTrace();\t\treturn Result.fail(null);\t&#125;\t/**\t * 自定义异常处理方法\t * @param e\t * @return\t */\t@ExceptionHandler(GlobalException.class)\t@ResponseBody\tpublic Result error(GlobalException e)&#123;\t\treturn Result.build(null,e.getCode(),e.getMessage());\t&#125;&#125;\n\n\n创建GlobalException\n\n@Datapublic class GlobalException extends RuntimeException&#123;\t//异常状态码\tprivate Integer code;\t/**\t * 通过状态码和错误消息创建异常对象\t * @param message\t * @param code\t */\tpublic GlobalException(String message, Integer code) &#123;\t\tsuper(message);\t\tthis.code = code;\t&#125;\t/**\t * 接收枚举类型对象\t * @param resultCodeEnum\t */\tpublic GlobalException(ResultCodeEnum resultCodeEnum) &#123;\t\tsuper(resultCodeEnum.getMessage());\t\tthis.code = resultCodeEnum.getCode();\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;GlobalException&#123;&quot; +\t\t\t\t&quot;code=&quot; + code +\t\t\t\t&quot;, message=&quot; + this.getMessage() +\t\t\t\t&#x27;&#125;&#x27;;\t&#125;&#125;\n\nRedisUtil.javaimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.Collection;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Componentpublic final class RedisUtil &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    // =============================common============================    /**     * 指定缓存失效时间     * @param key  键     * @param time 时间(秒)     */    public boolean expire(String key, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 根据key 获取过期时间     * @param key 键 不能为null     * @return 时间(秒) 返回0代表为永久有效     */    public long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    /**     * 判断key是否存在     * @param key 键     * @return true 存在 false不存在     */    public boolean hasKey(String key) &#123;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 删除缓存     * @param key 可以传一个值 或多个     */    @SuppressWarnings(&quot;unchecked&quot;)    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length &gt; 0) &#123;            if (key.length == 1) &#123;                redisTemplate.delete(key[0]);            &#125; else &#123;                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));            &#125;        &#125;    &#125;    // ============================String=============================    /**     * 普通缓存获取     * @param key 键     * @return 值     */    public Object get(String key) &#123;        return key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    /**     * 普通缓存放入     * @param key   键     * @param value 值     * @return true成功 false失败     */    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 普通缓存放入并设置时间     * @param key   键     * @param value 值     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 递增     * @param key   键     * @param delta 要增加几(大于0)     */    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    /**     * 递减     * @param key   键     * @param delta 要减少几(小于0)     */    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // ================================Map=================================    /**     * HashGet     * @param key  键 不能为null     * @param item 项 不能为null     */    public Object hget(String key, String item) &#123;        return redisTemplate.opsForHash().get(key, item);    &#125;    /**     * 获取hashKey对应的所有键值     * @param key 键     * @return 对应的多个键值     */    public Map&lt;Object, Object&gt; hmget(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * HashSet     * @param key 键     * @param map 对应多个键值     */    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * HashSet 并设置时间     * @param key  键     * @param map  对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 删除hash表中的值     *     * @param key  键 不能为null     * @param item 项 可以使多个 不能为null     */    public void hdel(String key, Object... item) &#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    /**     * 判断hash表中是否有该项的值     *     * @param key  键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */    public boolean hHasKey(String key, String item) &#123;        return redisTemplate.opsForHash().hasKey(key, item);    &#125;    /**     * hash递增 如果不存在,就会创建一个 并把新增后的值返回     *     * @param key  键     * @param item 项     * @param by   要增加几(大于0)     */    public double hincr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, by);    &#125;    /**     * hash递减     *     * @param key  键     * @param item 项     * @param by   要减少记(小于0)     */    public double hdecr(String key, String item, double by) &#123;        return redisTemplate.opsForHash().increment(key, item, -by);    &#125;    // ============================set=============================    /**     * 根据key获取Set中的所有值     * @param key 键     */    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;            return redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 根据value从一个set中查询,是否存在     *     * @param key   键     * @param value 值     * @return true 存在 false不存在     */    public boolean sHasKey(String key, Object value) &#123;        try &#123;            return redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将数据放入set缓存     *     * @param key    键     * @param values 值 可以是多个     * @return 成功个数     */    public long sSet(String key, Object... values) &#123;        try &#123;            return redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 将set数据放入缓存     *     * @param key    键     * @param time   时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */    public long sSetAndTime(String key, long time, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().add(key, values);            if (time &gt; 0)                expire(key, time);            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 获取set缓存的长度     *     * @param key 键     */    public long sGetSetSize(String key) &#123;        try &#123;            return redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 移除值为value的     *     * @param key    键     * @param values 值 可以是多个     * @return 移除的个数     */    public long setRemove(String key, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().remove(key, values);            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // ===============================list=================================    /**     * 获取list缓存的内容     *     * @param key   键     * @param start 开始     * @param end   结束 0 到 -1代表所有值     */    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;        try &#123;            return redisTemplate.opsForList().range(key, start, end);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 获取list缓存的长度     *     * @param key 键     */    public long lGetListSize(String key) &#123;        try &#123;            return redisTemplate.opsForList().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 通过索引 获取list中的值     *     * @param key   键     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     */    public Object lGetIndex(String key, long index) &#123;        try &#123;            return redisTemplate.opsForList().index(key, index);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 将list放入缓存     * 从头部插入leftPush     * @param key   键     * @param value 值     */    public boolean lSet(String key, Object value) &#123;        try &#123;            redisTemplate.opsForList().leftPush(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key   键     * @param value 值     * @param time  时间(秒)     */    public boolean lSet(String key, Object value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            if (time &gt; 0)                expire(key, time);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 根据索引修改list中的某条数据     *     * @param key   键     * @param index 索引     * @param value 值     * @return     */    public boolean lUpdateIndex(String key, long index, Object value) &#123;        try &#123;            redisTemplate.opsForList().set(key, index, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 移除N个值为value     *     * @param key   键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */    public long lRemove(String key, long count, Object value) &#123;        try &#123;            Long remove = redisTemplate.opsForList().remove(key, count, value);            return remove;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;&#125;\n\n上传图片本地上传本地路径方式\n\n在 Resource 目录下有一个 upload.html 文件，和一个 static 文件夹，static 下又有一个 images 文件夹，如下图\n\n\n\nupload.html\n\n这里主要就是一个 form 表单，用来提交数据，但是要注意的是我这个表单用了 post 和 enctype&#x3D;”multipart&#x2F;form-data”，以及 input 的类型是 file\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;上传图片&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action=&quot;/uplaod&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;file&quot; name=&quot;file&quot; value=&quot;请选择你要上传的图片&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\nUploadController\n\n为了方便演示，我把业务都放在 controller，，首先我们要先分析文件上传有几步\n\n文件校验（包括但不限于，图片的大小、图片的类型、图片是否为空、上传的是否是文件等）\n将图片重命名，图片重命名又可分为以下几步\n获取原来文件的后缀名，可以使用file.getOriginalFilename()获取原来的文件名\n生成一个随机的新文件名，这里可以使用UUID.randomUUID()\n把新名称和原后缀名拼接起来作为新的文件名\n\n\n把图片上传的指定的目录下，我们这里讲的是 Resource，就以 Resource 为例\nnew ApplicationHome(this.getClass())可以获取当前程序运行的主页\n我们知道 Java 程序都是运行的.class 字节码文件，所以getDir()获取文件夹位置其实是.class 字节码文件的位置，需要使用getParentFile()两次回到项目的主目录\n获取到主目录的绝对路径拼接上从这里到 Resource 下的 images\n最后通过file.transferTo(new File(path));把文件上传到 Resource 下的 images 目录，并且返回一个 url 地址\n\n\n\npackage com.wang.upload.controller;import org.springframework.boot.system.ApplicationHome;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.UUID;/** * @version: java version 1.8 * @Author: WWJ * @description: * @date: 2023-02-17 23:41 */@RestControllerpublic class UploadController &#123;    @PostMapping(&quot;/upload&quot;)    public String UploadFile(MultipartFile file) &#123;        if (file.isEmpty()) &#123;            return &quot;上传文件为空&quot;;        &#125;        String originalFilename = file.getOriginalFilename();        //获取原来的文件名和后缀        String ext = &quot;.&quot; + originalFilename.split(&quot;\\\\.&quot;)[1];        //生成一个新的文件名（以防有重复的名字存在导致被覆盖）        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);        String newName = uuid + ext;        ApplicationHome applicationHome = new ApplicationHome(this.getClass());        String pre = applicationHome.getDir().getParentFile().getParentFile().getAbsolutePath() +                &quot;\\\\src\\\\main\\\\resources\\\\static\\\\images\\\\&quot;;        String path = pre + newName;        try &#123;            file.transferTo(new File(path));        &#125; catch (IOException e) &#123;            e.printStackTrace();            return &quot;上传失败&quot;;        &#125;        return path;    &#125;&#125;\n\n云服务器上传OSS 对象存储\n对象存储 OSS\n\n创建 Bucket\n\n名称：随便起\n地域：想你的服务器在哪就选哪个（也是随便选）\n存储类型：标准存储\n冗余存储：关闭\n版本控制：关闭\n读写权限：公共读写\n\n\n代码\n\n导入依赖\n\n&lt;!-- 阿里云oss依赖 --&gt;&lt;dependency&gt;\t&lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;\t&lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;\t&lt;version&gt;3.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 日期工具栏依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;joda-time&lt;/groupId&gt;    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;    &lt;version&gt;2.10.1&lt;/version&gt;&lt;/dependency&gt;\n\n在applcation.yml文件中配置：keyid与keysecret可以在阿里云的账号的 AccessKey 管理中，进行创建\naliyun:  endpoint: oss-cn-shanghai.aliyuncs.com  keyid: xxxxxxxx  keysecret: xxxxxxxxxxxxxxxx  bucketname: xxxxxxx\n\n\n如果创建的是子用户，一定要赋予该角色 OSS 权限控制\n\nFileUploadController\n@Api(tags = &quot;文件上传接口&quot;)@RestController@RequestMapping(&quot;/upload&quot;)public class FileUploadController &#123;\t@Autowired\tprivate FileUploadService fileUploadService;\t@ApiOperation(&quot;图片上传&quot;)\t@PostMapping(&quot;/fileUpload&quot;)\tpublic Result fileUpload(MultipartFile file) &#123;\t\tString url = fileUploadService.uploadFile(file);\t\treturn Result.ok(url);\t&#125;&#125;\n\nFileUploadServiceImpl\n@Servicepublic class FileUploadServiceImpl implements FileUploadService &#123;\t@Value(&quot;$&#123;aliyun.endpoint&#125;&quot;)\tprivate String endPoint;\t@Value(&quot;$&#123;aliyun.keyid&#125;&quot;)\tprivate String accessId;\t@Value(&quot;$&#123;aliyun.keysecret&#125;&quot;)\tprivate String secreKey;\t@Value(&quot;$&#123;aliyun.bucketname&#125;&quot;)\tprivate String bucketName;\t@Override\tpublic String uploadFile(MultipartFile file) &#123;\t\tOSS ossClient = new OSSClientBuilder().build(endPoint, accessId, secreKey);\t\ttry &#123;\t\t\t// 上传文件流。\t\t\tInputStream inputStream = file.getInputStream();\t\t\tString fileName = file.getOriginalFilename();\t\t\t//生成随机唯一值，使用uuid，添加到文件名称里面\t\t\tString uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);\t\t\tfileName = uuid+fileName;\t\t\t//按照当前日期，创建文件夹，上传到创建文件夹里面\t\t\t//  2023/02/02/01.jpg\t\t\tString timeUrl = new DateTime().toString(&quot;yyyy/MM/dd&quot;);\t\t\tfileName = timeUrl+&quot;/&quot;+fileName;\t\t\t//调用方法实现上传\t\t\tossClient.putObject(bucketName, fileName, inputStream);\t\t\t// 关闭OSSClient。\t\t\tossClient.shutdown();\t\t\t//上传之后文件路径\t\t\t// https://wjwang.oss-cn-shanghai.aliyuncs.com/01.jpg\t\t\treturn &quot;https://&quot;+bucketName+&quot;.&quot;+endPoint+&quot;/&quot;+fileName;\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t\treturn null;\t\t&#125;\t&#125;&#125;\n\n文件大小报错异常在 SpringBoot 的 application.yml 中配置\nspring:  servlet:    multipart:      max-file-size: 100MB      max-request-size: 1000MB\n\nMyBatis Plus代码生成器使用MyBatis Plus，安装依赖\n&lt;!--mybatis-plus--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;    &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;    &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt;\n\nCodeGet.java\nimport com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;/** * @author Wjwang * @description 代码生成工具 * @date 2023/9/23 16:55:01 */public class CodeGet &#123;\tpublic static void main(String[] args) &#123;\t\t// 1、创建代码生成器\t\tAutoGenerator mpg = new AutoGenerator();\t\t// 2、全局配置\t\t// 全局配置\t\tGlobalConfig gc = new GlobalConfig();\t\tgc.setOutputDir(&quot;D:\\\\Project\\\\code\\\\test\\\\service\\\\service-admin\\\\src\\\\main\\\\java&quot;);\t\tgc.setServiceName(&quot;%sService&quot;);    //去掉Service接口的首字母I\t\tgc.setAuthor(&quot;Wjwang&quot;);\t\tgc.setOpen(false);\t\tmpg.setGlobalConfig(gc);\t\t// 3、数据源配置\t\tDataSourceConfig dsc = new DataSourceConfig();\t\tdsc.setUrl(&quot;jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&amp;useSSL=false&quot;);\t\tdsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);\t\tdsc.setUsername(&quot;root&quot;);\t\tdsc.setPassword(&quot;123456&quot;);\t\tdsc.setDbType(DbType.MYSQL);\t\tmpg.setDataSource(dsc);\t\t// 4、包配置\t\tPackageConfig pc = new PackageConfig();\t\tpc.setParent(&quot;com.wjwang&quot;);\t\tpc.setModuleName(&quot;admin&quot;); //模块名\t\tpc.setController(&quot;controller&quot;);\t\tpc.setService(&quot;service&quot;);\t\tpc.setMapper(&quot;mapper&quot;);\t\tmpg.setPackageInfo(pc);\t\t// 5、策略配置\t\tStrategyConfig strategy = new StrategyConfig();\t\tstrategy.setInclude(&quot;user_info&quot;,&quot;admin_info&quot;);\t\tstrategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略\t\tstrategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略\t\tstrategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作\t\tstrategy.setRestControllerStyle(true); //restful api风格控制器\t\tstrategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符\t\tmpg.setStrategy(strategy);\t\t// 6、执行\t\tmpg.execute();\t&#125;&#125;\n\nMybatisX 代码生成首先我们需要在IDEA中安装MyBatisX插件，并开启：\n\n然后需要在IDEA中连接数据库，在需要生成代码的表右键，选择MybatisX-Generator：\n\n在Generate Options中，双击module path选择我们要生成的项目模块，填写信息，点击Next：\n\n选择Mybatis-Plus 3，在注释选项选择： Comment、Lombok，选择模板，点击Finish，在对应位置查找生成的代码：\n\n分页插件创建config.MybatisPlusConfig，编写MybatisPlusConfig.java\nimport com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * MybatisPlus配置类 */@EnableTransactionManagement@Configuration@MapperScan(&quot;com.wjwang.*.mapper&quot;) // 根据项目结构引入public class MybatisPlusConfig &#123;\t/**\t * mp插件\t */\t@Bean\tpublic MybatisPlusInterceptor optimisticLockerInnerInterceptor() &#123;\t\tMybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\t\t//向Mybatis过滤器链中添加分页拦截器\t\tinterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\t\treturn interceptor;\t&#125;&#125;\n\n在 Json 格式中插入当前时间// payload 为JSON格式数据String payload = message.getPayload().toString();获取当前时间Date date = new Date();SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String time = formatter.format(date);JSONObject jsonObject = JSON.parseObject(payload);在JSON中插入k,v对jsonObject.put(&quot;time&quot;, time);// 存入Redis缓存数据库中redisUtil.lSet(&quot;sensor&quot;, jsonObject.toString());\n\n解析 JSON 格式数据\nJSON 格式数据，通过 key，获取 value\n\nObject massage = redisUtil.lGetIndex(&quot;sensor&quot;, 0);JSONObject jsonObject = JSON.parseObject(massage.toString());String sn = jsonObject.getString(&quot;SN&quot;);BigDecimal temp = jsonObject.getBigDecimal(&quot;Temp&quot;);BigDecimal humidity = jsonObject.getBigDecimal(&quot;Humidity&quot;);String time = jsonObject.getString(&quot;time&quot;);\n\n启动 banner$&#123;AnsiColor.BRIGHT_YELLOW&#125;$&#123;AnsiStyle.BOLD&#125;                    _ooOoo_                   o8888888o                   88&quot; . &quot;88                   (| ^_^ |)                   O\\  =  /O                ____/`---&#x27;\\____              .&#x27;  \\\\|     |//  `.             /  \\\\|||  :  |||//  \\            /  _||||| -:- |||||-  \\            |   | \\\\\\  -  /// |   |            | \\_|  &#x27;&#x27;\\---/&#x27;&#x27;  |   |            \\  .-\\__  `-`  ___/-. /          ___`. .&#x27;  /--.--\\  `. . ___        .&quot;&quot; &#x27;&lt;  `.___\\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.      | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |      \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /========`-.____`-.___\\_____/___.-`____.-&#x27;========                     `=---=&#x27;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^       佛祖保佑          永无BUG         永不修改$&#123;AnsiColor.CYAN&#125;$&#123;AnsiStyle.BOLD&#125;::  Java：$&#123;java.version&#125;::  Spring Boot Version: $&#123;spring-boot.version&#125;::  Application Version: $&#123;application.version&#125;$&#123;AnsiStyle.NORMAL&#125;\n\n邮件工具在 Java 中发送邮件主要依靠 javax.mail 包，但是由于使用比较繁琐，因此我们使用Hutool，针对其做了封装。由于依赖第三方包，因此将此工具类归类到 extra 模块中。所有我们需要引入Hutool和javax.mail\n使用\n引入依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;    &lt;version&gt;5.8.26&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;    &lt;artifactId&gt;javax.mail&lt;/artifactId&gt;    &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n邮件服务器配置\n\n在 classpath（在标准 Maven 项目中为src/main/resources）的 config 目录下新建mail.setting文件，最小配置内容如下，在此配置下，smtp 服务器和用户名都将通过from参数识别：\n# 发件人（必须正确，否则发送失败）from = hutool@yeah.net# 密码（注意，某些邮箱需要为SMTP服务单独设置密码，详情查看相关帮助）pass = q1w2e3\n\n有时候一些非标准邮箱服务器（例如企业邮箱服务器）的 smtp 地址等信息并不与发件人后缀一致，端口也可能不同，此时 Hutool 可以提供完整的配置文件：\n# 邮件服务器的SMTP地址，可选，默认为smtp.&lt;发件人邮箱后缀&gt;host = smtp.yeah.net# 邮件服务器的SMTP端口，可选，默认25port = 25# 发件人（必须正确，否则发送失败）from = hutool@yeah.net# 用户名，默认为发件人邮箱前缀user = hutool# 密码（注意，某些邮箱需要为SMTP服务单独设置授权码，详情查看相关帮助）pass = q1w2e3\n\n\n注意邮件服务器必须支持并打开 SMTP 协议，详细请查看相关帮助说明配置文件的样例中提供的是我专门为测试邮件功能注册的 yeah.net 邮箱，帐号密码公开，供 Hutool 用户测试使用。\n\n发送邮件\n发送普通文本邮件，最后一个参数可选是否添加多个附件：\n\n// 格式：MailUtil.send(tos, subject, content, isHtml, files);MailUtil.send(&quot;hutool@foxmail.com&quot;, &quot;测试&quot;, &quot;邮件来自Hutool测试&quot;, false);\n\n\n发送 HTML 格式的邮件并附带附件，最后一个参数可选是否添加多个附件：\n\nMailUtil.send(&quot;hutool@foxmail.com&quot;, &quot;测试&quot;, &quot;&lt;h1&gt;邮件来自Hutool测试&lt;/h1&gt;&quot;, true, FileUtil.file(&quot;d:/aaa.xml&quot;));\n\n\n群发邮件，可选 HTML 或普通文本，可选多个附件：\n\nArrayList&lt;String&gt; tos = CollUtil.newArrayList(\t&quot;person1@bbb.com&quot;,\t&quot;person2@bbb.com&quot;,\t&quot;person3@bbb.com&quot;,\t&quot;person4@bbb.com&quot;);MailUtil.send(tos, &quot;测试&quot;, &quot;邮件来自Hutool群发测试&quot;, false);\n\n发送邮件非常简单，只需一个方法即可搞定其中按照参数顺序说明如下：\n\ntos: 对方的邮箱地址，可以是单个，也可以是多个（Collection 表示）\nsubject：标题\ncontent：邮件正文，可以是文本，也可以是 HTML 内容\nisHtml： 是否为 HTML，如果是，那参数 3 识别为 HTML 内容\nfiles： 可选：附件，可以为多个或没有，将 File 对象加在最后一个可变参数中即可\n\n其他\n自定义邮件服务器\n\n除了使用配置文件定义全局账号以外，MailUtil.send方法同时提供重载方法可以传入一个MailAccount对象，这个对象为一个普通 Bean，记录了邮件服务器信息。\nMailAccount account = new MailAccount();account.setHost(&quot;smtp.yeah.net&quot;);account.setPort(&quot;25&quot;);account.setAuth(true);account.setFrom(&quot;hutool@yeah.net&quot;);account.setUser(&quot;hutool&quot;);account.setPass(&quot;q1w2e3&quot;);MailUtil.send(account, CollUtil.newArrayList(&quot;hutool@foxmail.com&quot;), &quot;测试&quot;, &quot;邮件来自Hutool测试&quot;, false);\n\n\n使用 SSL 加密方式发送邮件 在使用 QQ 或 Gmail 邮箱时，需要强制开启 SSL 支持，此时我们只需修改配置文件即可：\n\n# 发件人（必须正确，否则发送失败），“小磊”可以任意变更，&lt;&gt;内的地址必须唯一，以下方式也对# from = hutool@yeah.netfrom = 小磊&lt;hutool@yeah.net&gt;# 密码（注意，某些邮箱需要为SMTP服务单独设置密码，详情查看相关帮助）pass = q1w2e3# 使用SSL安全连接sslEnable = true\n\n在原先极简配置下只需加入sslEnable即可完成 SSL 连接，当然，这是最简单的配置，很多参数根据已有参数已设置为默认。完整的配置文件如下：\n# 邮件服务器的SMTP地址host = smtp.yeah.net# 邮件服务器的SMTP端口port = 465# 发件人（必须正确，否则发送失败）from = hutool@yeah.net# 用户名（注意：如果使用foxmail邮箱，此处user为qq号）user = hutool# 密码（注意，某些邮箱需要为SMTP服务单独设置密码，详情查看相关帮助）pass = q1w2e3#使用 STARTTLS安全连接，STARTTLS是对纯文本通信协议的扩展。starttlsEnable = true# 使用SSL安全连接sslEnable = true# 指定实现javax.net.SocketFactory接口的类的名称,这个类将被用于创建SMTP的套接字socketFactoryClass = javax.net.ssl.SSLSocketFactory# 如果设置为true,未能创建一个套接字使用指定的套接字工厂类将导致使用java.net.Socket创建的套接字类, 默认值为truesocketFactoryFallback = true# 指定的端口连接到使用的套接字工厂。如果没有设置,将使用默认端口465socketFactoryPort = 465# SMTP超时时长，单位毫秒，缺省值不超时timeout = 0# Socket连接超时值，单位毫秒，缺省值不超时connectionTimeout = 0\n\n\n针对 QQ 邮箱和 Foxmail 邮箱的说明\n\n(1) QQ 邮箱中 SMTP 密码是单独生成的授权码，而非你的 QQ 密码，至于怎么生成，见腾讯的帮助说明：什么是授权码，它又是如何设置？(opens new window)\n使用帮助引导生成授权码后，配置如下即可：\npass = 你生成的授权码\n\n(2) Foxmail 邮箱本质上也是 QQ 邮箱的一种别名，你可以在你的 QQ 邮箱中设置一个 foxmail 邮箱，不过配置上有所区别。在 Hutool 中user属性默认提取你邮箱@前面的部分，但是对于 foxmail 邮箱是无效的，需要单独配置为与之绑定的 qq 号码或者XXXX@qq.com的XXXX。即：\nhost = smtp.qq.comfrom = XXXX@foxmail.comuser = foxmail邮箱对应的QQ号码或者qq邮箱@前面部分...\n\n(3) 阿里云邮箱的user是邮箱的完整地址，即xxx@aliyun.com\n\n针对 QQ 邮箱（foxmail）PKIX path building failed 错误（since 5.6.4）\n\n部分用户反馈发送邮件时会遇到错误：\ncn.hutool.extra.mail.MailException: MessagingException: Could not connect to SMTP host: smtp.qq.com, port: 465...Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n\n这个错误可能是需要 SSL 验证造成的，我们可以手动跳过这个验证：\nMailAccount mailAccount = new MailAccount();mailAccount.setAuth(true);mailAccount.setSslEnable(true);...MailSSLSocketFactory sf = new MailSSLSocketFactory();sf.setTrustAllHosts(true);mailAccount.setCustomProperty(&quot;mail.smtp.ssl.socketFactory&quot;, sf);Mail mail = Mail.create(mailAccount)    .setTos(&quot;xx@xx.com&quot;)\t.setTitle(&quot;邮箱验证&quot;)\t.setContent(&quot;您的验证码是：&lt;h3&gt;2333&lt;/h3&gt;&quot;)\t.setHtml(true)\t.send();\n\nWebSocket1.在 SpringBoot 的 pom.xml 中添加依赖：\n&lt;!-- websocket --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2.在配置中加入WebSocketConfig.java\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configurationpublic class WebSocketConfig &#123;    /**     * 注入一个ServerEndpointExporter,该Bean会自动注册使用@ServerEndpoint注解申明的websocket endpoint     */    @Bean    public ServerEndpointExporter serverEndpointExporter() &#123;        return new ServerEndpointExporter();    &#125;&#125;\n\n3.新建类WebSocketServer.java\nimport cn.hutool.json.JSONArray;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author websocket服务 */@ServerEndpoint(value = &quot;/imserver/&#123;username&#125;&quot;)@Componentpublic class WebSocketServer &#123;    private static final Logger log = LoggerFactory.getLogger(WebSocketServer.class);    /**     * 记录当前在线连接数     */    public static final Map&lt;String, Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;();    /**     * 连接建立成功调用的方法     */    @OnOpen    public void onOpen(Session session, @PathParam(&quot;username&quot;) String username) &#123;        sessionMap.put(username, session);        log.info(&quot;有新用户加入，username=&#123;&#125;, 当前在线人数为：&#123;&#125;&quot;, username, sessionMap.size());        JSONObject result = new JSONObject();        JSONArray array = new JSONArray();        result.set(&quot;users&quot;, array);        for (Object key : sessionMap.keySet()) &#123;            JSONObject jsonObject = new JSONObject();            jsonObject.set(&quot;username&quot;, key);            // &#123;&quot;username&quot;, &quot;zhang&quot;, &quot;username&quot;: &quot;admin&quot;&#125;            array.add(jsonObject);        &#125;//        &#123;&quot;users&quot;: [&#123;&quot;username&quot;: &quot;zhang&quot;&#125;,&#123; &quot;username&quot;: &quot;admin&quot;&#125;]&#125;        sendAllMessage(JSONUtil.toJsonStr(result));  // 后台发送消息给所有的客户端    &#125;    /**     * 连接关闭调用的方法     */    @OnClose    public void onClose(Session session, @PathParam(&quot;username&quot;) String username) &#123;        sessionMap.remove(username);        log.info(&quot;有一连接关闭，移除username=&#123;&#125;的用户session, 当前在线人数为：&#123;&#125;&quot;, username, sessionMap.size());    &#125;    /**     * 收到客户端消息后调用的方法     * 后台收到客户端发送过来的消息     * onMessage 是一个消息的中转站     * 接受 浏览器端 socket.send 发送过来的 json数据     * @param message 客户端发送过来的消息     */    @OnMessage    public void onMessage(String message, Session session, @PathParam(&quot;username&quot;) String username) &#123;        log.info(&quot;服务端收到用户username=&#123;&#125;的消息:&#123;&#125;&quot;, username, message);        JSONObject obj = JSONUtil.parseObj(message);        String toUsername = obj.getStr(&quot;to&quot;); // to表示发送给哪个用户，比如 admin        String text = obj.getStr(&quot;text&quot;); // 发送的消息文本  hello        // &#123;&quot;to&quot;: &quot;admin&quot;, &quot;text&quot;: &quot;聊天文本&quot;&#125;        Session toSession = sessionMap.get(toUsername); // 根据 to用户名来获取 session，再通过session发送消息文本        if (toSession != null) &#123;            // 服务器端 再把消息组装一下，组装后的消息包含发送人和发送的文本内容            // &#123;&quot;from&quot;: &quot;zhang&quot;, &quot;text&quot;: &quot;hello&quot;&#125;            JSONObject jsonObject = new JSONObject();            jsonObject.set(&quot;from&quot;, username);  // from 是 zhang            jsonObject.set(&quot;text&quot;, text);  // text 同上面的text            this.sendMessage(jsonObject.toString(), toSession);            log.info(&quot;发送给用户username=&#123;&#125;，消息：&#123;&#125;&quot;, toUsername, jsonObject.toString());        &#125; else &#123;            log.info(&quot;发送失败，未找到用户username=&#123;&#125;的session&quot;, toUsername);        &#125;    &#125;    @OnError    public void onError(Session session, Throwable error) &#123;        log.error(&quot;发生错误&quot;);        error.printStackTrace();    &#125;    /**     * 服务端发送消息给客户端     */    private void sendMessage(String message, Session toSession) &#123;        try &#123;            log.info(&quot;服务端给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;, toSession.getId(), message);            toSession.getBasicRemote().sendText(message);        &#125; catch (Exception e) &#123;            log.error(&quot;服务端发送消息给客户端失败&quot;, e);        &#125;    &#125;    /**     * 服务端发送消息给所有客户端     */    private void sendAllMessage(String message) &#123;        try &#123;            for (Session session : sessionMap.values()) &#123;                log.info(&quot;服务端给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;, session.getId(), message);                session.getBasicRemote().sendText(message);            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;服务端发送消息给客户端失败&quot;, e);        &#125;    &#125;&#125;\n","categories":["高级语言","工具"],"tags":["Java"]},{"title":"Java技术栈","url":"/2023/09/22/Java%E6%8A%80%E6%9C%AF%E6%A0%88/","content":"SSE 实现消息推送SSE（Server-Sent Events）\n当涉及到部分请求，后端处理时间较长，使用常规 Http 请求，页面等待时间太长，对用户不友好，故考虑使用长链接进行消息推送，\n可选方案有WebSocket、SSE。WebSocket 可实现双工通信，SSE 仅支持服务端向客户端推送消息，根据实际使用场景，SSE 即可满足，故选用 SSE。\n在SpringBoot中，先编写 SSE 服务SseEmitterServer\n@Slf4j@Servicepublic class SseEmitterServer &#123;\tprivate final static Map&lt;String, SseEmitter&gt; SSE_CACHE = new ConcurrentHashMap&lt;&gt;();\t/**\t * 创建新连接\t */\tpublic synchronized SseEmitter createSession() throws IOException &#123;\t\t// 设置过期时间为0 表示永不过期\t\tSseEmitter sseEmitter = new SseEmitter(0L);\t\tString id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);\t\tif (!SSE_CACHE.containsKey(id)) &#123;\t\t\tSSE_CACHE.put(id, sseEmitter);\t\t\tlog.info(&quot;客户端：[&#123;&#125;]新建成功，当前客户端总数为：[&#123;&#125;]&quot;, id, SSE_CACHE.size());\t\t&#125;\t\treturn sseEmitter;\t&#125;\tpublic void closeSession(String clientId)&#123;\t\tif (SSE_CACHE.containsKey(clientId))&#123;\t\t\tSSE_CACHE.get(clientId).complete();\t\t\tSSE_CACHE.remove(clientId);\t\t\tlog.info(&quot;客户端：[&#123;&#125;]关闭成功，当前剩余客户端总数为：[&#123;&#125;]&quot;, clientId, SSE_CACHE.size());\t\t&#125;\t&#125;\t/**\t * 定时任务\t */\t@Scheduled(fixedDelay = 3, initialDelay = 1)\tpublic void job() &#123;\t\tif (SSE_CACHE.size() &gt; 0)&#123;\t\t\tString msg = UUID.randomUUID().toString();\t\t\tSystem.out.println(&quot;定时任务发送消息：&quot; + msg);\t\t\tfor (Map.Entry&lt;String, SseEmitter&gt; entry : SSE_CACHE.entrySet()) &#123;\t\t\t\tSseEmitter sseEmitter = SSE_CACHE.get(entry.getKey());\t\t\t\ttry &#123;\t\t\t\t\tsseEmitter.send(SseEmitter.event().reconnectTime(1000).id(entry.getKey()).data(msg));\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\tSSE_CACHE.remove(entry.getKey());\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\tpublic void sendMessageToClient(String clientId, String message) &#123;\t\tSseEmitter sseEmitter = SSE_CACHE.get(clientId);\t\tif (sseEmitter != null) &#123;\t\t\ttry &#123;\t\t\t\tsseEmitter.send(SseEmitter.event().reconnectTime(1000).id(clientId).data(message));\t\t\t&#125; catch (IOException e) &#123;\t\t\t\tSSE_CACHE.remove(clientId);\t\t\t&#125;\t\t&#125;\t&#125;\tpublic void sendMessageToAllClients(String message) &#123;\t\tfor (Map.Entry&lt;String, SseEmitter&gt; entry : SSE_CACHE.entrySet()) &#123;\t\t\ttry &#123;\t\t\t\tentry.getValue().send(SseEmitter.event().reconnectTime(1000).id(entry.getKey()).data(message));\t\t\t&#125; catch (IOException e) &#123;\t\t\t\tSSE_CACHE.remove(entry.getKey());\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n接口使用：SseController：\n@RestController@CrossOriginpublic class SseController &#123;\t@Resource\tprivate SseEmitterServer sseEmitterServer;\t@GetMapping(&quot;/connect&quot;)\tpublic SseEmitter connect() throws IOException &#123;\t\treturn sseEmitterServer.createSession();\t&#125;\t@GetMapping(&quot;/disconnect&quot;)\tpublic String disconnect(@RequestParam String clientId) &#123;\t\tsseEmitterServer.closeSession(clientId);\t\treturn &quot;Disconnected&quot;;\t&#125;\t@PostMapping(&quot;/send&quot;)\tpublic Result send(@RequestParam String msg) &#123;\t\tsseEmitterServer.sendMessageToAllClients(msg);\t\treturn Result.ok(null);\t&#125;&#125;\n\n在前端使用也非常的方便，下面是 vue 的一个小示例：\n// 创建一个 EventSource 对象实例let eventSource = null;onMounted(() =&gt; &#123;  eventSource = new EventSource(&quot;http://localhost:9091/connect&quot;);  eventSource.onmessage = (event) =&gt; &#123;    // 获取到后端返回的值    message.value += String.fromCharCode(event.data);  &#125;;&#125;);// 调用接口await request.post(  &quot;http://localhost:9091/send?msg=&quot; + encodeURIComponent(text.value));\n\n我们在后端提供两个接口，一个是前端进页面就进行 SSE 链接，另一个是调用接口，使用 SSE 返回给前端\n\n初次进入页面时，进行连接\n\n\n当发送消息调用接口，此处调用语言模型接口，以流式返回：\n\nElasticSearchElasticSearch 介绍ElasticSearch 概述Elasticsearch (简称 ES)是一个分布式、高扩展、高实时的、RESTful 风格的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用 Elasticsearch 的水平伸缩性，能使数据在生产环境变得更有价值。Elasticsearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到 Elasticsearch 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。\nElasticsearch 是面向文档型数据库，一条数据在这里就是一个文档，用 JSON 作为文档序列化的格式，比如下面这条用户数据：\n&#123;  &quot;name&quot;: &quot;John&quot;,  &quot;sex&quot;: &quot;Male&quot;,  &quot;age&quot;: 25,  &quot;birthDate&quot;: &quot;1990/05/01&quot;,  &quot;about&quot;: &quot;I love to go rock climbing&quot;,  &quot;interests&quot;: [&quot;sports&quot;, &quot;music&quot;]&#125;\n\n用 Mysql 这样的数据库存储就会容易想到建立一张 User 表，有各个字段等，在 ElasticSearch 里这就是一个文档，当然这个文档会属于一个 User 的类型，各种各样的类型存在于一个索引当中。这里有一份简易的将 Elasticsearch 和关系型数据术语对照表:\n\n索引(Index)一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。\n能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。\nElasticsearch 索引的精髓：一切设计都是为了提高搜索的性能。\n类型(Type)在一个索引中，你可以定义一种或多种类型。\n一个类型是你的索引的一个逻辑上的分类&#x2F;分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化\n\n\n\n版本\nType\n\n\n\n5.x\n支持多种 type\n\n\n6.x\n只能有一种 type\n\n\n7.x\n默认不再支持自定义索引类型（默认类型为：_doc）\n\n\n文档(Document)一个文档是一个可被索引的基础信息单元，也就是一条数据\n比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。\n在一个 index&#x2F;type 里面，你可以存储任意多的文档。\n字段(Field)相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。\n映射(Mapping)mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。\nElasticSearch 安装下载软件下载地址：ElasticSearch\n推荐下载7.8版本：Elasticsearch 7.8.0\nwindows 安装解压文件，目录结构如下：\n\n\n\n目录\n说明\n\n\n\nbin\n可执行脚本目录\n\n\nconfig\n配置目录\n\n\njdk\n内置 jdk 目录\n\n\nlib\n类库\n\n\nlogs\n日志目录\n\n\nmodules\n模块目录\n\n\nplugins\n插件目录\n\n\n解压完成后进入 bin 目录，双击运行elasticsearch.bat\n\n测试访问: http://localhost:9200/\n\n注意事项一：\nElasticSearch 是使用 java 开发的，且本版本的ES需要 JDK 版本要是 1.8 以上，所以安装 ElasticSearch 之前保证 JDK1.8+安装完毕，并正确的配置好 JDK 环境变量，否则启动 ElasticSearch 失败。\n注意事项二：\n出现闪退，通过路径访问发现“空间不足”\n修改 config&#x2F;jvm.options 文件的 22 行 23 行，把 2 改成 1，让 Elasticsearch 启动的时候占用 1 个 G 的内存。\n-Xmx512m：设置 JVM 最大可用内存为 512M。\n-Xms512m：设置 JVM 初始内存 512m。此值可设置与-Xmx 相同，以避免每次垃圾回收完成后 JVM 重新分配内存。\nik 分词器安装IK 分词器简介IKAnalyzer 是一个开源的，基于 Java 语言开发的轻量级的中文分词工具包。从 2006 年 12 月推出 1.0 版开始，IKAnalyzer 已经推出 了 3 个大版本。最初，它是以开源项目 Lucene 为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的 IKAnalyzer3.0 则发展为面向 Java 的公用分词组件，独立于 Lucene 项目，同时提供了对 Lucene 的默认优化实现。\nIK 分词器 3.0 的特性如下：\n1）采用了特有的“正向迭代最细粒度切分算法“，具有 60 万字&#x2F;秒的高速处理能力。\n2）采用了多子处理器分析模式，支持：英文字母（IP 地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。\n3）对中英联合支持不是很好,在这方面的处理比较麻烦.需再做一次查询，同时是支持个人词条的优化的词典存储，更小的内存占用。\n4）支持用户词典扩展定义。\n5）针对 Lucene 全文检索优化的查询分析器 IKQueryParser；采用歧义分析算法优化查询关键字的搜索排列组合，能极大的提高 Lucene 检索的命中率。\nIK 分词器的安装下载：\nGitHub 仓库地址：https://github.com/medcl/elasticsearch-analysis-ik\n下载地址: https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.8.0/elasticsearch-analysis-ik-7.8.0.zip\n解压安装 IK 插件：\n将ik压缩包直接解压到 ElasticSearch 的 plugins\\ik\\目录下，注意目录结构，解压后的 zip 不要放在 plugins 目录下\n\nkibana 安装-客户端elasticsearch 服务是一个 restful 风格的 http 服务。我们可以采用 postman 作为客户端来进行操作，elastic stack 官方也给我们提供了 kibana 来进行客户端操作，这个相比 postman 要友好一点，因为里面有些自动补全的代码提示\n下载地址: https://www.elastic.co/cn/downloads/past-releases/kibana-7-8-0\n解压文件：进入到 config 目录，修改 kibana.yml 文件：\nKibana默认端口：5601\n\nKibana 连接 elasticsearch 服务器的地址：elasticsearch.hosts: [“","categories":["高级语言"],"tags":["Java","SpringBoot","SSE"]},{"title":"JupyterLab","url":"/2024/12/03/JupyterLab/","content":"JupyterLab介绍：\n官方文档：Link\n\n​\tJupyterLab 是 Project Jupyter 旗下其他笔记本编写应用程序（如 Jupyter Notebook 和 Jupyter Desktop）的同胞兄弟。与 [Jupyter Notebook](https://so.csdn.net/so/search?q=Jupyter Notebook&amp;spm&#x3D;1001.2101.3001.7020) 相比，JupyterLab 提供了更先进、功能更丰富、可定制的体验。\n安装\n官方文档: Link\n\npip install jupyterlab\n\nJupyter Kernel 与 conda 虚拟环境​\t建议：在每个虚拟环境中都完整地安装 jupyterlab（在运行前一定要激活所需的虚拟环境）。\n在使用时，用这个默认的 Kernel 即可，它调用的就是所在虚拟环境的 Python Interpreter。\n可以用下面的代码运行验证一下：\nimport osimport sysprint(f&quot;Python 版本信息: &#123;sys.version&#125;&quot;)print(f&quot;\\n解释器路径: &#123;sys.executable&#125;&quot;)print(f&quot;\\n当前工作目录: &#123;os.getcwd()&#125;&quot;)\n\n此外，这篇问答 How to use Jupyter notebooks in a conda environment? 给出了 3 种不同的使用方式，想要尝试的话可以参考。\n使用安装中文包\n官方文档: Link\n\npip install jupyterlab-language-pack-zh-CN\n\n切换为中文：\n\n启动–no-browser: 禁止启动时自动打开浏览器–ip&#x3D;: Jupyter 服务器监听的 IP 地址，默认为 localhost–port&#x3D;: Jupyter 服务器监听的端口–notebook-dir&#x3D;: 工作目录（顶层）–app-dir&#x3D;: 启动时所在的目录（包含于 notebook-dir）–pylab&#x3D;: 默认为 disabled，需要在 notebook 中使用 %pylab 或 %matplotlib 来启用 matplotlib\njupyter lab --notebook-dir=E:/ --preferred-dir E:/Documents/Somewhere/Else\n\n常用快捷键\nESC: 切换到命令模式\nENTER: 切换到编辑模式\nCtrl + Enter: 运行 Cell\nShift + Enter: 运行 Cell，并切换至下一个 Cell\n\n自动补全和文档提示\n自动补全：Tab\n文档提示：\nShift + Tab\n使用问号：?\n\n\n\n魔术符号\n行魔术：%\n格子魔术：%%\n列举所有魔术符号：%lsmagic\n\n","categories":["高级语言","工具"],"tags":["Python"]},{"title":"MCP服务器","url":"/2025/04/20/MCP%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"MCP介绍MCP : Model   Context   Protocol——模型上下文协议，一种旨在规范大模型语言模型与外部数据源及工具之间交互方式的开放协议标准。\nMCP服务器作为AI与外部工具的中间层，MCP通过标准化的协议代替人类访问并操作外部工具，每个MCP服务器都专精于一类工作，比如有的负责读写浏览器、有的负责读写本地文件、有的操作GIT仓库等等。\nMCP服务器（MCP Server）通常就是运行在本地的一段nodejs 或 python 程序，大模型通过标准输入通道调用某个 MCP Server\nMCP协议与 function call非常相似，MCP的最大优势在于整合了各家大模型不同的 function call 的标准，整合为统一的标准协议\n客户端配置要使用MCP服务还需要选择可以支持的客户端，我们后续以 Cherry Studio 进行演示，同时选择模型时，也需要注意模型需要支持 function call，也就是模型需要带有 tools的小标签，在Cherry Studio中模型会显示扳手🔧\n1.进入Cherry Studio点击设置，选择MCP服务器，第一次右上角有一个感叹号，需要安装UV Installed、Bun Installed\n2.安装完成后，点击添加MCP服务器，后面配置MCP服务器\nCherryStudio在新版本的 CherryStudioMCP服务器中，支持同步服务器，目前可选的只有 ModelScope（魔搭社区），\n\n前往MCP 广场 · 魔搭社区 选择需要使用的MCP服务，有些服务需要对应的密钥，根据指示前往获取个人密钥粘贴到魔搭社区对应的MCP服务器，点击连接。\n获取魔搭社区密钥 访问令牌 · 魔搭社区 ，复制 SDK/API 令牌。\n将魔搭社区的 密钥粘贴到 CherryStudio中，点击同步，即可将魔搭社区中连接到的MCP服务器同步到CherryStudio中。\n\nMCP服务器我们如何去找一下MCP服务器呢，我们可以前往魔搭社区的MCP广场：MCP 广场 · 魔搭社区\n里面已经存放了1000多种MCP服务器，下面对常用的MCP服务器进行演示：\n1.网页内容Fatch MCP Server：帮助我们网页查询、搜索相关内容\n选择使用 uvx 安装方式：\n&quot;mcpServers&quot;: &#123;    &quot;fetch&quot;: &#123;      &quot;isActive&quot;: true,      &quot;command&quot;: &quot;uvx&quot;,      &quot;args&quot;: [        &quot;mcp-server-fetch&quot;      ],      &quot;name&quot;: &quot;fetch&quot;    &#125;&#125;\n\n将fetch的内容复制，添加到 Cherry Studio 的MCP服务器中，点击编辑MCP配置\n\n然后 fatch 服务开启，如果启动失败，提示请求超时，在配置页包管理源选择阿里云\n我们在聊天页面对话时，勾选MCP服务器的 fatch即可帮助我们做网页内容的查询，例如：\n\n帮我看一下这个网站有什么：https://junyyds.cn\n\n2.地图我们可以在魔搭社区的MCP广场找到 高德地图 · MCP 使用SSE 协议接入\n具体流程提供了官方的流程文档：快速接入-MCP Server | 高德地图API，我们只需要高德开发平台创建一个key高德地图API\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;amap-amap-sse&quot;: &#123;      &quot;url&quot;: &quot;https://mcp.amap.com/sse?key=您在高德官网上申请的key&quot;    &#125;  &#125;&#125;\n\n将key补充到上面amap-amap-sse的url路径中，然后在Cherry Studio中点击编辑MCP配置，将amap-amap-sse复制进去，\n或者点击添加服务器名称修改为高德地图，类型选择服务器发送事件（sse），粘贴url\n\n3.联网搜索这里以魔搭社区的Tavily智搜-MCP服务器为例，我们只需要前往 Tavily AI进行注册，生成一个密钥 API Keys\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;tavily-mcp&quot;: &#123;      &quot;command&quot;: &quot;npx&quot;,      &quot;args&quot;: [&quot;-y&quot;, &quot;tavily-mcp@0.1.2&quot;],      &quot;env&quot;: &#123;        &quot;TAVILY_API_KEY&quot;: &quot;your-api-key-here&quot;      &#125;    &#125;  &#125;&#125; \n\n将tavily-mcp复制到Cherry Studio 的MCP配置中，对话时选择tavily-mcp\n","categories":["大模型"],"tags":["MCP"]},{"title":"Markdown语法","url":"/2023/05/17/Markdown%E8%AF%AD%E6%B3%95/","content":"常用语法\n字体\n\n&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;\n\n我是华文彩云\n&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为 5&lt;/font&gt;\n\n我是黑体，绿色，尺寸为 5\n数学符合&amp;公式希腊字母表\n\n\n符号\n代码\n符合\n代码\n\n\n\n$\\alpha$\n\\alpha\n$\\Alpha$\n\\Alpha\n\n\n$\\beta$\n\\beta\n$\\Beta$\n\\Beta\n\n\n$\\gamma$\n\\gamma\n$\\Gamma$\n\\gamma\n\n\n$\\delta$\n\\delta\n$\\Delta$\n\\delta\n\n\n$\\epsilon$\n\\epsilon\n$\\Epsilon$\n\\epsilon\n\n\n$\\zeta$\n\\zeta\n$\\Zeta$\n\\Zeta\n\n\n$\\eta$\n\\eta\n$\\Eta$\n\\Eta\n\n\n$\\theta$\n\\theta\n$\\Theta$\n\\Theta\n\n\n$\\iota$\n\\iota\n$\\Iota$\n\\Iota\n\n\n$\\lambda$\n\\lambda\n$\\Lambda$\n\\Lambda\n\n\n$\\mu$\n\\mu\n$\\Mu$\n\\Mu\n\n\n$\\nu$\n\\nu\n$\\Nu$\n\\Nu\n\n\n$\\omicron$\n\\omicron\n$\\Omicron$\n\\Omicron\n\n\n$\\phi$\n\\phi\n$\\Phi$\n\\Phi\n\n\n$\\upsilon$\n\\upsilon\n$\\upsilon$\n\\upsilon\n\n\n$\\sigma$\n\\sigma\n$\\Sigma$\n\\Sigma\n\n\n$\\rho$\n\\rho\n$\\Rho$\n\\Rho\n\n\n$\\pi$\n\\pi\n$\\Pi$\n\\Pi\n\n\n数学符号\n\n\n描述\n符号\n代码\n\n\n\n行内公式\n$$\n$$\n\n\n上标\n$y&#x3D;x^2$\ny &#x3D; x^2\n\n\n下标\n$O_2$\nO_2\n\n\n分式\n$\\frac {a}{b}$\n\\frac {a}{b}\n\n\n根式\n$\\sqrt[a]b$\n\\sqrt[a]b\n\n\n占位符\n$\\quad$\n\\quad\n\n\n向量\n$\\vec{a}$\n\\vec{a}\n\n\n无穷，极限\n$\\infty$，$\\lim$\n\\infty，\\lim\n\n\n省略号\n$x_1^2 + \\cdots + x_n^2$\nx_1^2 + \\cdots + x_n^2\n\n\n\n矩阵\n\nL*&#123;n\\times n&#125; = \\begin&#123;bmatrix&#125;a*&#123;11&#125; &amp; a*&#123;12&#125; &amp; \\cdots &amp; a*&#123;1n&#125; \\\\a*&#123;21&#125; &amp; a*&#123;22&#125; &amp; \\cdots &amp; a*&#123;2n&#125; \\\\\\vdots &amp; \\vdots &amp;\\ddots &amp; \\vdots\\\\a*&#123;n1&#125; &amp; a*&#123;n2&#125; &amp; \\cdots &amp; a*&#123;nn&#125; \\\\\\end&#123;bmatrix&#125;\n\n$L_{n\\times n} &#x3D; \\begin{bmatrix}a_{11} &amp; a_{12} ewq &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\vdots &amp; \\vdots &amp;\\ddots &amp; \\vdots\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\\\end{bmatrix}$\n\n花括号\n\n$c(u)=\\begin&#123;cases&#125; \\sqrt\\frac&#123;1&#125;&#123;N&#125;，u=0\\\\ \\sqrt\\frac&#123;2&#125;&#123;N&#125;， u\\neq0\\end&#123;cases&#125;$\n\n$c(u)&#x3D;\\begin{cases} \\sqrt\\frac{1}{N}，u&#x3D;0\\ \\sqrt\\frac{2}{N}， u\\neq0\\end{cases}$\n数学符号补充\n\n\n$\\geqslant$\n$\\leqslant$\n\n\n\n\\leqslant\n\\leqslant\n\n\n集合\n\n\n算式\nmarkdown\n描述\n\n\n\n$\\emptyset$\n\\emptyset\n空集\n\n\n$\\in$\n\\in\n属于\n\n\n$\\notin$\n\\notin\n不属于\n\n\n$\\subset$\n\\subset\n子集\n\n\n$\\supset$\n\\supset\n\n\n\n$ \\subseteq$\n\\subseteq\n真子集\n\n\n$\\supseteq$\n\\supseteq\n\n\n\nTypora 美化修改GIthub主题的css样式，在 Typora 的偏好设置中，点击 -》外观 -》 打开主题文件夹，在文件夹中选择**github.css**，下面修改包括：\n\n字体：手写字体&#x3D;&#x3D;华康手札体 W5P&#x3D;&#x3D;\n高亮颜色\n表格优化\n复选框优化\n\n@charset &quot;UTF-8&quot;;body &#123;    font-family: &quot;华康手札体W5P&quot;;    color: rgb(51, 51, 51);    line-height: 1.6;&#125;/*==背景高亮==*/mark &#123;    background: #ffffff;    color: #db3f1e;    font-weight: bold;    border-bottom: 0px solid #ffffff;    padding: 0.0px;    margin: 0 0px;&#125;::selection &#123; background-color: #d1ff79; &#125;table thead&#123;white-space:nowrap;&#125;table &#123;width:100%;table-layout:fixed !important;word-break:break-word !important;&#125; /* 修改checkbox样式 */.task-list-item p&#123;font-size:25px;!important;color:#1E90FF;&#125;.task-list-item input[type=checkbox]&#123;display:inline-block !important;zoom: 140%;&#125;.md-task-list-item &gt; input &#123;  margin-left: -0.8em !important ;&#125;.md-task-list-item &gt; li .mathjax-block, li p &#123;margin: 0.0rem 0px;&#125;\n\n（Windows）安装字体：华康手札体 W5P\n\n将解压出来的华康手札体W5P.ttf，复制到**&quot;C:\\Windows\\Fonts&quot;**中，复制及自动安装，然后在 Typora 中，将在安装字体的名字复制，写入到主题的 css 样式中。\n\n其他设置可打开高级设置：\n\n","categories":["技术栈"],"tags":["Markdown"]},{"title":"Python工具类","url":"/2023/05/17/Python%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"使用 pyinstaller 打包在 pycharm 中点击新建环境\n\n进入文件后，会有一个文件夹venv，用来存放管理的库文件\n创建 requirements.txt\npip install requests\n\npip freeze &gt; requirements.txt\n\n\n可以看到虚拟环境下安装的包\n安装 pyinstaller\npip install pyinstaller\n\n安装完成后将终端关闭，重新打开\n我们输入pyinstaller，当出现一下结果，说明安装成功\n\n单文件打包\npyinstaller -D app.py\n\n开始打包\n\n之后在当前文件夹会出现三个文件\n\nbuild：中间编译时，产出的文件\ndist：打包生成后的文件目录\nxxx.spec：打包的配置文件\n\n在dist中可以看到有我们上面起的名字app，只需将app 文件夹发给他人，打开里面的app.exe文件，即可使用\n文件读写with open(&#x27;xxx.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:\tf.write(&#x27;xxx&#x27; + &#x27;\\n&#x27;)    f.close()\n\n爬虫\n代码案例\n\nfrom bs4 import BeautifulSoupimport requestsdef getHTMLText(url):    try:        headers = &#123;            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;&#125;        res = requests.get(url, headers=headers)        res.raise_for_status()        res.encoding = res.apparent_encoding        return res.text    except:        return &#x27;error&#x27;def get_info(url):    demo = getHTMLText(url)    soup = BeautifulSoup(demo, &#x27;html.parser&#x27;)    table = soup.find(&#x27;table&#x27;, &#123;&#x27;class&#x27;: &#x27;rk-table&#x27;&#125;)    tbody = table.find(&#x27;tbody&#x27;)    rows = tbody.find_all(&#x27;tr&#x27;)    for row in rows:        tds = row.find_all(&#x27;td&#x27;)        rank = tds[0].text.strip()        name = row.find(&#x27;a&#x27;).text.strip()        location = tds[2].text.strip()        total = tds[4].text.strip()        data = &#123;            &#x27;排名&#x27;: rank,            &#x27;学校名称&#x27;: name,            &#x27;省市&#x27;: location,            &#x27;总分&#x27;: total        &#125;        print(data)url_2020 = &#x27;https://www.shanghairanking.cn/rankings/bcur/2020&#x27;url_2021 = &#x27;https://www.shanghairanking.cn/rankings/bcur/2021&#x27;get_info(url_2021)\n\n爬虫框架 Scrapy\n简介\n\n\n基本功能Scrapy 是一个适用爬取网站数据、提取结构性数据的应用程序框架，它可以应用在广泛领域：Scrapy 常应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。通常我们可以很简单的通过 Scrapy 框架实现一个爬虫，抓取指定网站的内容或图片。\n\n架构**Scrapy Engine(引擎)**：负责 Spider、ItemPipeline、Downloader、Scheduler 中间的通讯，信号、数据传递等。**Scheduler(调度器)**：它负责接受引擎发送过来的 Request 请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。Downloader（下载器）：负责下载 Scrapy Engine(引擎)发送的所有 Requests 请求，并将其获取到的 Responses 交还给 Scrapy Engine(引擎)，由引擎交给 Spider 来处理。Spider（爬虫）：它负责处理所有 Responses,从中分析提取数据，获取 Item 字段需要的数据，并将需要跟进的 URL 提交给引擎，再次进入 Scheduler(调度器)。**Item Pipeline(管道)**：它负责处理 Spider 中获取到的 Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。Downloader Middlewares（下载中间件）：一个可以自定义扩展下载功能的组件。Spider Middlewares（Spider 中间件）：一个可以自定扩展和操作引擎和 Spider 中间通信的功能组件。\n\n\n\n\nscrapy 项目的结构\n项目名字项目的名字spiders 文件夹（存储的是爬虫文件）init自定义的爬虫文件 核心功能文件inititems 定义数据结构的地方 爬虫的数据都包含哪些middleware 中间件 代理pipelines 管道 用来处理下载的数据settings 配置文件 robots 协议 ua 定义等\n\n\n环境搭建\n\npip install scrapy\n\n\n项目搭建\n\nscrapy startproject 工程名（img）\n\n结果\nNew Scrapy project &#x27;img&#x27;, using template directory &#x27;D:\\Environment\\Anaconda3\\Lib\\site-packages\\scrapy\\templates\\project&#x27;, created in:    C:\\Users\\Admin\\Desktop\\scrapy\\imgYou can start your first spider with:    cd img    scrapy genspider example example.com\n\n转到项目，创建源文件\ncd imgscrapy genspider unsplash unsplash.com\n\n结果\nCreated spider &#x27;unsplash&#x27; using template &#x27;basic&#x27; in module:  img.spiders.unsplash\n\n运行\nscrapy crawl unsplash(为文件名)\n\nScrapy 爬取 unsplash一、分析网站\n\n高清图片网站https://unsplash.com/, 能展示超过 7w+张高清图片. 浏览时, 其通过 API 返回图片的 URl\n\n在 chrome 浏览器中有此插件 unsplash, 在插件文件中找到对应 JS, 再找出 api 地址\n\n\n根据插件安装的时间找到对应的 chrome 插件目录\n二、爬取图片 URL\n\n安装 Scrapy, pip install Scrapy\n\n在工程目录中创建项目 scrapy startproject scrapy_unsplash E:\\wendi1\\pyplace\\scrapy_unsplash\n\n进入项目目录, 创建爬虫 scrapy genspider unsplash api.unsplash.com –template&#x3D;crawl\n\n此时在.&#x2F;scrapy_unsplash&#x2F;spiders 目录中生成 unsplash.py 文件.\n配置 settings.py , 并发连接数 CONCURRENT_REQUESTS &#x3D; 100 , 下载延迟 DOWNLOAD_DELAY &#x3D; 1.6\n\n\n首先需要爬取网站, 然后将 raw 种类的图片 URL 存入 sqlite, unsplash.py 代码:\n\n\n# -*- coding: utf-8 -*-import jsonimport sqlite3import threadingimport scrapyfrom scrapy.spiders import CrawlSpiderclass UnsplashSpider(CrawlSpider):    name = &#x27;unsplash&#x27;    allowed_domains = [&#x27;api.unsplash.com&#x27;]    def start_requests(self):        createDB()  # 创建数据库        start, page = 1, 2000,  # 要爬的页面数        for i in range(start, page + 1):  # 从第一页开始            url = &#x27;https://api.unsplash.com/photos/?client_id=fa60305aa82e74134cabc7093ef54c8e2c370c47e73152f72371c828daedfcd7&amp;page=&#x27; + str(                i) + &#x27;&amp;per_page=30&#x27;            yield scrapy.Request(url=url, callback=self.parse_item)    def parse_item(self, response):        conn = sqlite3.connect(&quot;E:\\\\wendi1\\\\pyplace\\\\scrapy_unsplash\\\\database\\\\link.db&quot;)  # 连接数据库        print(&#x27;-------------------&#x27;)        js = json.loads(str(response.body_as_unicode()), &#x27;utf-8&#x27;)  # 读取响应body，并转化成可读取的json        for j in js:            link = j[&quot;urls&quot;][&quot;raw&quot;]            sql = &quot;INSERT INTO LINK(LINK) VALUES (&#x27;%s&#x27;);&quot; % link  # 将link插入数据库            conn.execute(sql)        semaphore = threading.Semaphore(1)  # 引入线程信号量，避免写入数据库时死锁        semaphore.acquire()  # P操作        conn.commit()  # 写入数据库，此时数据库文件独占        semaphore.release()  # V操作def createDB():  # 创建数据库    conn = sqlite3.connect(&quot;E:\\\\wendi1\\\\pyplace\\\\scrapy_unsplash\\\\database\\\\link.db&quot;)  # Sqlite是一个轻量数据库，不占端口，够用    conn.execute(&quot;DROP TABLE IF EXISTS LINK;&quot;)  # 重新运行删掉数据库    conn.execute(&quot;CREATE TABLE LINK (&quot;  # 创建属性ID：主键自增；属性LINK：存放图片链接                 &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT,&quot;                 &quot;LINK VARCHAR(255));&quot;)\n\n执行 scrapy crawl unsplash . 在第 16 行可修改爬取的页面总数\nurl 已存入 sqlite 中 :\n连接 Mysql 数据库使用pymysql官方库，封装公用代码\n新增一个pymysql_comm.py类, 代码如下:\nimport pymysqlfrom timeit import default_timerhost = &#x27;localhost&#x27;port = 3306user = &#x27;root&#x27;password = &#x27;123456&#x27;db = &#x27;mysql_test&#x27; # 连接的数据库charset = &#x27;utf8mb4&#x27;# ---- 用pymysql 操作数据库def get_connection():    conn = pymysql.connect(host=host, port=port, db=db, user=user, password=password, charset=charset)    return conn# ---- 使用 with 的方式来优化代码class UsingMysql(object):    def __init__(self, commit=True, log_time=True, log_label=&#x27;总用时&#x27;):        &quot;&quot;&quot;        :param commit: 是否在最后提交事务(设置为False的时候方便单元测试)        :param log_time:  是否打印程序运行总时间        :param log_label:  自定义log的文字        &quot;&quot;&quot;        self._log_time = log_time        self._commit = commit        self._log_label = log_label    def __enter__(self):        # 如果需要记录时间        if self._log_time is True:            self._start = default_timer()        # 在进入的时候自动获取连接和cursor        conn = get_connection()        cursor = conn.cursor()        # cursor = conn.cursor(pymysql.cursors.DictCursor) 可使返回的结果不再是普通的元组列表，而是字典列表        conn.autocommit = False        self._conn = conn        self._cursor = cursor        return self    def __exit__(self, *exc_info):        # 提交事务        if self._commit:            self._conn.commit()        # 在退出的时候自动关闭连接和cursor        self._cursor.close()        self._conn.close()        if self._log_time is True:            diff = default_timer() - self._start            print(&#x27;-- %s: %.6f 秒&#x27; % (self._log_label, diff))    @property    def cursor(self):        return self._cursor\n\n当我们需要使用时，增删改查演示：\n\n先增加了一条记录, 然后接着查看这条记录\n\nfrom pymysql_comm import UsingMysqldef select_one(cursor):    cursor.execute(&quot;select * from Product&quot;)    data = cursor.fetchone()    print(&quot;-- 单条记录: &#123;0&#125; &quot;.format(data))# 新增单条记录def create_one():    with UsingMysql(log_time=True) as um:        sql = &quot;insert into Product(name, remark) values(%s, %s)&quot;        params = (&#x27;男士双肩背包1&#x27;, &#x27;这个是非常好的背包&#x27;)        um.cursor.execute(sql, params)        # 查看结果        select_one(um.cursor)if __name__ == &#x27;__main__&#x27;:    create_one()\n\n\n删除某条记录\n\nfrom pymysql_comm import UsingMysqldef delete_one(cursor, name):    sql = &#x27;delete from Product where name = %s&#x27;    params = name    cursor.execute(sql, params)    print(&#x27;--- 已删除名字为%s的商品. &#x27; % name)def select_one(cursor):    sql = &#x27;select * from Product&#x27;    cursor.execute(sql)    data = cursor.fetchone()    print(&#x27;--- 已找到名字为%s的商品. &#x27; % data[&#x27;name&#x27;])    return data[&#x27;name&#x27;]def select_one_by_name(cursor, name):    sql = &#x27;select * from Product where name = %s&#x27;    params = name    cursor.execute(sql, params)    data = cursor.fetchone()    if data:        print(&#x27;--- 已找到名字为%s的商品. &#x27; % data[&#x27;name&#x27;])    else:        print(&#x27;--- 名字为%s的商品已经没有了&#x27; % name)# 删除单条记录def check_delete_one():    with UsingMysql(log_time=True) as um:        # 查找一条记录        name = select_one(um.cursor)        # 删除        delete_one(um.cursor, name)        # 查看还在不在?        select_one_by_name(um.cursor, name)if __name__ == &#x27;__main__&#x27;:    check_delete_one()\n\n\n修改记录\n\nfrom pymysql_comm import UsingMysqldef update_by_pk(cursor, name, pk):    sql = &quot;update Product set name = &#x27;%s&#x27; where id = %d&quot; % (name, pk)    cursor.execute(sql)def select_one(cursor):    sql = &#x27;select * from Product&#x27;    cursor.execute(sql)    return cursor.fetchone()def select_one_by_name(cursor, name):    sql = &#x27;select * from Product where name = %s&#x27;    params = name    cursor.execute(sql, params)    data = cursor.fetchone()    if data:        print(&#x27;--- 已找到名字为%s的商品. &#x27; % data[&#x27;name&#x27;])    else:        print(&#x27;--- 名字为%s的商品已经没有了&#x27; % name)# 修改记录def check_update():    with UsingMysql(log_time=True) as um:        # 查找一条记录        data = select_one(um.cursor)        pk = data[&#x27;id&#x27;]        print(&#x27;--- 商品&#123;0&#125;: &#x27;.format(data))        # 修改名字        new_name = &#x27;单肩包&#x27;        update_by_pk(um.cursor, new_name, pk)        # 查看        select_one_by_name(um.cursor, new_name)if __name__ == &#x27;__main__&#x27;:    check_update()\n\n\n查询\n\nfrom pymysql_comm import UsingMysqldef fetch_list_by_filter(cursor, pk):    sql = &#x27;select * from Product where id &gt; %d&#x27; % pk    cursor.execute(sql)    data_list = cursor.fetchall()    print(&#x27;-- 总数: %d&#x27; % len(data_list))    return data_list# 查找def fetch_list():    with UsingMysql(log_time=True) as um:        # 查找id 大于800的记录        data_list = fetch_list_by_filter(um.cursor, 800)        # 查找id 大于 10000 的记录        data_list = fetch_list_by_filter(um.cursor, 10000)if __name__ == &#x27;__main__&#x27;:    fetch_list()\n\n\n分页查询\n\nfrom pymysql_comm import UsingMysqldef fetch_page_data(cursor, pk, page_size, skip):    sql = &#x27;select * from Product where id &gt; %d limit %d,%d&#x27; % (pk, skip, page_size)    cursor.execute(sql)    data_list = cursor.fetchall()    print(&#x27;-- 总数: %d&#x27; % len(data_list))    print(&#x27;-- 数据: &#123;0&#125;&#x27;.format(data_list))    return data_list# 查找def check_page():    with UsingMysql(log_time=True) as um:        page_size = 10        pk = 500        for page_no in range(1, 6):            print(&#x27;====== 第%d页数据&#x27; % page_no)            skip = (page_no - 1) * page_size            fetch_page_data(um.cursor, pk, page_size, skip)if __name__ == &#x27;__main__&#x27;:    check_page()\n\n爬虫案例（写入数据库）\n实例\n\nimport jsonimport reimport pymysqlimport requestsconn = pymysql.connect(host=&#x27;127.0.0.1&#x27;  # 连接名称，默认127.0.0.1                       , user=&#x27;root&#x27;  # 用户名                       , passwd=&#x27;123456&#x27;  # 密码                       , port=3306  # 端口，默认为3306                       , db=&#x27;python&#x27;  # 数据库名称                       , charset=&#x27;utf8&#x27;  # 字符编码                       )cur = conn.cursor()  # 生成游标对象def getHTMLText(url):    try:        headers = &#123;            &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&#x27;&#125;        res = requests.get(url, headers=headers)        res.raise_for_status()        res.encoding = res.apparent_encoding        return res.text    except:        return &#x27;error&#x27;def main(url):    res = getHTMLText(url)    regex = re.compile(r&quot;(?=\\()(.*)(?&lt;=\\))&quot;)    jsonString = regex.findall(res)[-1]    jsonString = jsonString.strip(&#x27;()&#x27;)    jsonData = json.loads(jsonString)    diffValue = jsonData[&#x27;data&#x27;][&#x27;diff&#x27;]    for i in range(len(diffValue)):        demo = diffValue[i][&#x27;f12&#x27;]        name = diffValue[i][&#x27;f14&#x27;]        sql = &quot;INSERT INTO money(demo,name) VALUES (&#x27;&#123;&#125;&#x27;, &#x27;&#123;&#125;&#x27;);&quot;.format(demo, name)        cur.execute(sql)        conn.commit()        print(demo+name)    cur.close()    conn.close()url = &#x27;http://85.push2.eastmoney.com/api/qt/clist/get?cb=jQuery1124007516892373587614_1682312504170&amp;pn=1&amp;pz=20&amp;po=1&amp;np=1&amp;ut=bd1d9ddb04089700cf9c27f6f7426281&amp;fltt=2&amp;invt=2&amp;wbp2u=|0|0|0|web&amp;fid=f3&amp;fs=m:0+t:6,m:0+t:80,m:1+t:2,m:1+t:23,m:0+t:81+s:2048&amp;fields=f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f12,f13,f14,f15,f16,f17,f18,f20,f21,f23,f24,f25,f22,f11,f62,f128,f136,f115,f152&amp;_=1682312504458&#x27;main(url)\n\n图片转文字画import numpy as npfrom PIL import Imageimport timeif __name__ == &#x27;__main__&#x27;:    start_time = time.time()    image_file = &#x27;lena.png&#x27;    height = 100    img = Image.open(image_file)    img_width, img_height = img.size    width = int(1.8 * height * img_width // img_height)    img = img.resize((width, height), Image.ANTIALIAS)    pixels = np.array(img.convert(&#x27;L&#x27;))    print(&#x27;type(pixels) = &#x27;, type(pixels))    print(pixels.shape)    print(pixels)    chars = &quot;MNHQ$OC?7&gt;!:-;. &quot;    N = len(chars)    step = 256 // N    print(N)    result = &#x27;&#x27;    for i in range(height):        for j in range(width):            result += chars[pixels[i][j] // step]        result += &#x27;\\n&#x27;    with open(&#x27;text.txt&#x27;, mode=&#x27;w&#x27;) as f:        f.write(result)    end_time = time.time()    elapsed_time = end_time - start_time    print(f&#x27;程序耗时：&#123;elapsed_time:.2f&#125; 秒&#x27;)\n\n示例\n\nGUI用 Python 来写 GUI 的库：pyqt、wxpython、tkinter、kivy\n比较常用的是 tkinter 它是 Python 内置的库\n检测是否存在打开 cmd，输入：\npython -m tkinter\n\n\n开始使用tkinter 把不同的组件都封装成了 Class\n每个组件都有一些属性可以设置，比如可以设置字体常用的宽高字体颜色\nimport tkinter as tkapp = tk.Tk()app.title(&quot;My App&quot;) # 定义窗口的标题app.geometry(&quot;600x400&quot;)\t# 使用 geometry指定窗口的宽高lb = tk.Label(app, text=&quot;Hello World&quot;)\t# 想要往里加入文本，可以使用 Label 对象lb.pack()\t# 用 pack 塞到窗口中去tk.mainloop()  # 调用了 mainloop 方法，主要是让它去循环等待用户的交互\n\n示例：\nimport tkinter as tkapp = tk.Tk()app.title(&quot;Jarvis&quot;)app.geometry(&quot;600x400&quot;)lb = tk.Label(app, text=&quot;Hello World&quot;, width=20, height=10, fg=&quot;blue&quot;).pack()tk.Button(app, text=&quot;点我&quot;, width=20, background=&#x27;pink&#x27;).pack()tk.mainloop()\n\n\n按钮可以定义点击事件：当点击按钮的时候调用方法来修改 Lable 里面的内容（command 来绑定回调函数）\n","categories":["高级语言","工具"],"tags":["Python"]},{"title":"Redis","url":"/2023/05/17/Redis/","content":"安装windows：\nReleases · tporadowski&#x2F;redis (github.com)\n点击安装Redis-x64-5.0.14.1.msi\n通用命令：\n查看所有键\nkeys命令可用于查看所有键，语法如下\nkeys pattern\n\n说明：pattern 用于匹配 key，其中*表示任意个任意字符，?表示一个任意字符。\n示例：\n127.0.0.1:6379&gt; KEYS *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;\n\n注意：该命令会遍历 Redis 服务器中保存的所有键，因此当键很多时会影响整个 Redis 服务的性能，线上环境需要谨慎使用。\n\n键总数\ndbsize可用于查看键的总数，语法如下\ndbsize\n\n判断键是否存在\nexists命令可用于判断一个键是否存在，语法如下\nexists key\n\n说明：若键存在则返回 1，不存在则返回 0。\n\n删除键\ndel可用于删除指定键，语法如下\ndel key [key ...]\n\n说明：返回值为删除键的个数，若删除一个不存在的键，则返回 0。\n\n查询键的剩余过期时间\nttl key\n\n说明：ttl的含义为time to live，用于查询一个定时键的剩余存活时间，返回值以秒为单位。若查询的键的未设置过期时间，则返回-1，若查询的键不存在，则返回-2。\n\n数据库管理命令\nRedis 默认有编号为 0~15 的 16 个逻辑数据库，每个数据库之间的数据是相互独立的，所有连接默认使用的都是 0 号数据库。\n\n切换数据库\nselect命令可用于切换数据库，语法如下\nselect index\n\n说明：若 index 超出范围，会报错\n\n清空数据库\nflushdb命令会清空当前所选用的数据库，flushall命令会清空 0~15 号所有的数据库。\n注意：生产环境慎用\n\n\n\n\n常用数据类型string 类型概述：Redis 中的 string 类型保存的是字节序列（Sequence of bytes），因此任意类型的数据，只要经过序列化之后都可以保存到 Redis 的 string 类型中，包括文本、数字甚至是一个对象。\nsetset命令用于添加 string 类型的键值对，具体语法如下：\nset key value [expiration EX seconds|PX milliseconds] [NX|XX]\n\n各选项含义：\n\nEX seconds：设置过期时间，单位为秒\n\nPX milliseconds：设置过期时间，单位为毫秒\n\nNX：仅在 key 不存在时 set\n\nXX：仅在 key 存在时 set\n\n\n例如：set k2 v2 ex 20：设置 key 为 k2，value 为 v2，20s 后过期\ngetget命令用于获取某个 string 类型的键对应的值，具体如下：\nget key\n\nincrincr命令用于对数值做自增操作，具体语法如下\nincr key\n\n若 key 对应的 value 是整数，则返回自增后的结果，若不是整数则报错，若 key 不存在则创建并返回 1\ndecrdecr命令用于对数值做自减操作，具体语法如下\ndecr key\n\n应用场景\nstring 类型常用于缓存、计数器等场景。\nlist 类型概述：\nlist 类型可用于存储多个 string 类型的元素，并且所有元素按照被添加的顺序存储。\n常用命令\nlist 类型相关的命令较多，下面分类进行进行介绍。\n添加元素向列表中添加元素的命令有lpush、rpush 、linsert，各命令的功能与用法如下\n\nlpush：该命令用于向 list 左侧添加元素，语法如下\nlpush key value [value ...]\n\n示例：\nlpush l1 a b c\n\nrpush：该命令用于向 list 右侧添加元素，语法如下\nrpush key value [value ...]\n\nlinsert：该命令用于向 list 指定位置添加元素，语法如下\nlinsert key BEFORE|AFTER pivot value\n\n示例：在 li 的 list 列表中，在 b 后新增一个 value 为 new\nlinsert l1 after b new\n\n查询元素查询 list 元素的命令有lindex和lrange，各命令的功能与用法如下\nlindex：该命令用于获取指定索引位置的元素，语法如下\nlindex key index\n\n说明：index 从左到右依次是 0，1，2…，从右到左依次是-1，-2，-3…\nlrange：该命令用于获取指定范围内的元素列表，语法如下\nlrange key start stop\n\n示例：获取 list 全部元素，命令如下\nlrange l1 0 -1\n\n删除元素删除 list 元素的命令有lpop、rpop、lrem，各命令的功能与用法如下\n\nlpop：该命令用于移除并返回 list 左侧元素，语法如下\nlpop key [count]\n\n说明：count 参数表示移除元素的个数\nrpop：该命令用于移除并返回 list 右侧的元素，语法如下\nrpop key [count]\n\nlrem：该命令用于移除 list 中的指定元素，语法如下\nlrem key count value\n\n说明：count 参数表示要移除 element 元素的个数（list 中可以存在多个相同的元素），count 的用法如下\n\n若 count&gt;0，则从左到右删除最多 count 个 element 元素\n若 count&lt;0，则从右到左删除最多 count（的绝对值）个 element 元素\n若 count&#x3D;0，则删除所有的 element 元素\n\n修改元素lset：命令可用于修改指定索引位置的元素，语法如下\nlset key index value\n\n其他llen命令可用于查看 list 长度，语法如下\nllen key\n\n应用场景\n\n社交应用中，可使用 list 缓存每个用户发布的最新的 N 条记录。\nlist 可用作异步消息队列。\n\nset 类型概述：和 list 类型相似，set 类型也可用来存储多个 string 类型的元素，但与 list 类型不同，set 中的元素是无序的，且 set 中不会包含相同元素。\n集合内sadd：该命令用于向 set 中添加元素，语法如下\nsadd key member [member ...]\n\nsmembers：该命令用于查询 set 中的全部元素，语法如下\nsmembers key\n\nsrem：该命令用于移除 set 中的指定元素，语法如下\nsrem key member [member ...]\n\nspop：该命令随机移除并返回 set 中的 n 个元素，语法如下\nspop key [count]\n\nsrandmember：该命令随机返回 set 中的 n 个元素（不删除），语法如下\nsrandmember key [count]\n\nscard：该命令用于查询 set 中的元素个数，语法如下\nscard key\n\nsismember：该命令用于元素是否在 set 中，语法如下\nsismember key member\n\n集合间sinter：该命令用于计算多个集合的交集，语法如下\nsinter key [key ...]\n\nsunion：该命令用于计算多个集合的并集，语法如下\nsunion key [key ...]\n\nsdiff：该命令用于计算多个集合的差集，语法如下\nsdiff key [key ...]\n\n应用场景\nset 可用于计算共同关注好友，随机抽奖系统等等。\nHash 类型概述：hash 类型类似于 Java 语言中的HashMap，可用于存储键值对。\n\n\nhset：该命令用于向 hash 中增加键值对，语法如下\nhset key field value [field value ...]\n\nhget：该命令用于获取 hash 中某个键对应的值，语法如下\nhget key field\n\nhdel：该命令用于删除 hash 中的指定的键值对，语法如下\nhdel key field [field ...]\n\nhlen：该命令用于查询 hash 中的键值对个数，语法如下\nhlen key\n\nhexists：该命令用于判断 hash 中的某个键是否存在，语法如下\nhexists key field\n\nhkeys：该命令用于返回 hash 中所有的键，语法如下\nhkeys key\n\nhvals：该命令用于返回 hash 中所有的值，语法如下\nhvals key\n\nhgetall：该命令用于返回 hash 中所有的键与值，语法如下\nhgetall key\n\n应用场景\nhash 类型可用于缓存对象等。\nzet 类型概述：zset（sorted set）被称为有序集合，同 set 相似，zset 中也不会包含相同元素，但不同的是，zset 中的元素是有序的。并且 zset 中的元素并非像 list 一样按照元素的插入顺序排序，而是按照每个元素的分数（score）排序。\n\n\nzadd：该命令用于向 zset 中添加元素，语法如下\nzadd key [NX|XX] [CH] [INCR] score member [score member ...]\n\n**说明***：\n\nNX：仅当 member 不存在时才 add\nXX：仅当 member 存在时才 add\nCH：返回此次操作后有序集合元素发生变化的数量\nINCR：如果 member 存在，其分数会在原分数的基础上增加指定的增量值；如果成员不存在，则会添加该成员，并将其分数设置为增量值。\n\nzcard：该命令用于计算 zset 中的元素个数，语法如下\nzcard key\n\nzscore：用于查看某个元素的分数，语法如下\nzscore key member\n\nzrank/zrevrank：这组命令用于计算元素的排名，其中 zrank 按照 score 的升序排序，zrevrank 则按照降序排序，语法如下\nzrank/zrevrank key member\n\n说明：名次从 0 开始。\nzrem：该命令用于删除元素，语法如下\nzrem key member [member ...]\n\nzincrby：该命令用于增加元素的分数，语法如下\nzincrby key increment member\n\nzrange：该命令用于查询指定区间范围的元素，语法如下\nzrange key start stop [byscore] [rev] [limit offset count] [withscores]\n\n说明：\n\nstart&#x2F;stop：用于指定查询区间，但是在不同模式下，其代表的含义也不相同\n默认模式下，start~stop表示的是名次区间，且该区间为闭区间。名次从 0 开始，且可为负数，-1 表示倒数第一，-2 表示倒数第二，以此类推。\nbyscore 模式下（声明了 byscore 参数），则start~stop表示的就是分数区间，该区间默认仍为闭区间。在该模式下，可以在start或stop前增加(来表示开区间，例如(1 (5，表示的就是(1,5)这个开区间。除此之外，还可以使用-inf和+inf表示负无穷和正无穷。\n\n\nbyscore：用于切换到分数模式\nrev：表示降序排序。在 byscore 模式下使用 rev 参数需要注意查询区间，start 应大于 stop。\nlimit：该选项只用于 byscore 模式，作用和 sql 语句中的 limit 一致\nwithscores：用于打印分数\n\n应用场景\nzset 主要用于各种排行榜。\nRedisRedis.conf 详解Redis 持久化Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以 Redis 提供了持久化功能！\nRDB（Redis DataBase）\n什么是 RDB\n\nAOF（Append Only File）将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部执行一遍！\n\nAOF\n\nRedis 发布订阅Redis 发布订阅（pub&#x2F;sub）是一种&#x3D;&#x3D;消息通信模式&#x3D;&#x3D;：发送者（pub），订阅者（sub）接收消息。\nRedis 客户端可以订阅任意数量的频道。\nRedis 主从复制Redis 缓存穿透和雪崩Redis 数据备份与恢复备份数据\nredis Save 命令基本语法如下：\n127.0.0.1:6379&gt; SAVEOK\n\n该命令将在 redis 安装目录中创建 dump.rdb 文件。\n恢复数据\n登录目标 redis 服务器，我们先停止 redis 服务：\nservice redis stop  #停止redis服务\n\n然后进入 redis 的文件存放目录 redis,把刚刚备份的 dump.rdb 文件替换该目录下的 dump.rdb 文件（建议先备份当前目录下的 dump.rdb 文件），重启 redis 服务\nservice redis start #启动redis服务\n\n到此，redis 数据迁移完成\n\n获取\n\n获取 redis 目录可以使用 CONFIG 命令，如下所示：\nredis 127.0.0.1:6379&gt; CONFIG GET dir\n","categories":["技术栈"],"tags":["Redis"]},{"title":"SpringBoot","url":"/2023/06/29/SpringBoot/","content":"开发流程创建项目maven项目\n&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.1.1&lt;/version&gt;    &lt;/parent&gt;\n\n\n\n导入场景场景启动器\n    &lt;dependencies&gt;&lt;!--        web开发场景--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n\n\n主程序@SpringBootApplication // 这是一个SpringBoot应用public class MainApplication &#123;\tpublic static void main(String[] args) &#123;\t\tSpringApplication.run(MainApplication.class, args);\t&#125;&#125;\n\n\n\n业务@RestController // @RestController = @Controller + @ResponseBodypublic class HelloController &#123;\t\t@GetMapping(&quot;/hello&quot;)\tpublic String Hello()&#123;\t\treturn &quot;Hello, Spring Boot3!&quot;;\t&#125;&#125;\n\n\n\n测试默认访问：localhost:8080\n打包&lt;!--    SpringBoot应用打包插件--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;\n\nmvn clean package 把项目打成可执行的 jar 包\n\njava -jar demo.jar 启动项目\n核心技能注解组件注册@Configuration：表面这是一个通用配置类\n@SpringBootConfiguration：与@Configuration类似，表面是SpringBoot的配置类\n@Bean：创建实例\t@Scope：调整组件范围\n@Import：导入组件，组件的名字默认是全类名\n@Component\t@Controller\t@Service\t@Repository\n步骤：\n\n在@Configuration 编写一个配置类\n在配置类中，自定义方法给容器中注册组件。配合@Bean\n或使用@Import导入第三方组件\n\n条件注解\n如果注解指定的条件成立，则触发指定行为\n\n@ConditionalOnXxx\n@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为\n@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为\n@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为\n@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为\n属性绑定**@ConfigurationProperties(prefix  &#x3D; “”)**：声明组件的属性和配置文件哪些前缀进行绑定\n@EnableConfigurationProperties：快速注册注解\n\n将容器中的任意组件（Bean）的属性值和配置文件的配置项的值进行绑定\n\n给容器中注册组件\n使用@ConfigurationProperties声明组件和配置文件中的哪些配置项进行绑定\n\n\nYaml语法\nbirthDay 推荐写成birth-day\n文本：\n单引号不会转义 【\\n以普通字符串显示】\n双引号会转义 【\\n显示为换行符】\n\n\n大文本\n|  开头，大文本写在下层，保留文本格式，换行符正确显示\n&gt;   开头，大文本写在下层，折叠换行符\n\n\n多文本合并\n使用--- 可以把多个yaml文档合并在一个文档，每个文档区依然是独立的，中间用---分割\n\n\n\n在application.yml中，分别配置属性、对象、数组、哈希Map\n@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Datapublic class Person &#123;\tprivate String name;\tprivate Integer age;\tprivate Child child; // 嵌套对象\tprivate List&lt;Dog&gt; dogs; // 数组\tprivate Map&lt;String, Cat&gt; cats; // 表示Map&#125;\n\nperson:  name: 张三  age: 18  child:    name: 儿子    age: 19  dogs:    - name: 小黑      age: 3    - name: 小狗      age: 4  cats:    c1:      name: 小猫      age: 5    c2: &#123; name: 小花, age: 6 &#125; # 对象也可以用&#123; &#125;表示\n\n\n\nxxxxxxxxxx redis 127.0.0.1:6379&gt; CONFIG GET dirbash\n规范：项目开发不要编写system.out.println()，应该使用日志记录信息\n\n\n\n\n日志门面\n日志实现\n\n\n\nSLF4J\nLogback\n\n\n日志是系统一启动就要使用，xxxAutoConfigration是系统启动好了以后放好的组件，启动后使用\n所以日志是利用监听器机制配置好的\n日志格式2023-07-01T23:27:53.062+08:00  INFO 12256 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2023-07-01T23:27:53.062+08:00  INFO 12256 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.10]\n\n默认输出格式：\n\n时间和日期：毫秒级精度\n日志级别：ERROR, WARN, INFO, DBBUG, or TRACE\n进程ID\n— ：消息分隔符\n线程名：使用 [] 包含\nLogger 名：通常是产生日志的类名\n消息：日志记录的消息\n\n注意：logback没有FATAL级别，对应的是ERROR\n默认值：参考：spring-boot包 additonal-spring-configration-metadata.json文件\n可修改为：%d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %-5level %logger ===&gt; %msg%n\nlogging:  pattern:    console: &quot;%d&#123;yyyy/MM/dd-HH:mm:ss&#125; [%thread] %-5level %logger ===&gt; %msg%n&quot;\n\n使用方法在类上添加@Slf4j\n@Slf4j@RestControllerpublic class HelloController &#123;\t@GetMapping(&quot;/h&quot;)\tpublic String hello() &#123;\t\tlog.info(&quot;哈哈，方法进来了&quot;);\t\treturn &quot;hello&quot;;\t&#125;&#125;\n\n日志级别\n由低到高：ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF\n只会打印指定级别以上级别的日志\nALL：打印所有日志\nTRACE：追踪框架详细流程日志，一般不使用\nDEBUG：开发调式细节日志\nINFO：关键、感兴趣信息日志\nWARN：警告但不是错误的信息日志，比如：版本过时\nERROR：业务错误日志，比如出现各种异常\nFATAL：致命错误日志，比如出现jvm系统崩溃\nOFF：关闭所有日志记录\n\n\n不指定级别的所有类，都使用root指定的级别作为默认级别\nSpringBoot日志默认级别是INFO\n\n\n在application.yml中配置logging.level.&lt;logger-anme&gt;&#x3D;&lt;level&#x2F;&gt;指定日志级别\nlevel可取值范围：ALL,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,OFF，定义在LogLevel类中\nroot的logger-name叫root，可以配置logging.level.root&#x3D;warn，代表所有未指定日志级别都是root的warn级别\n\n日志分组自定义一个abc分组\nlogging:  group:    abc: com.wjwang.controller, com.wjwang.service\n\n然后可以使用logging.level.abc=xxx进行分组控制\n日志文件保存logging:  file:    name: D:\\\\log  # 指定日志文件的名称，可以写路径加名称\n\n\n\n文档归档与滚动切割\n归档：每天的日志单独存在一个文档中。\n切割：每个文件10MB，超过大小切割成另外一个文件。\n\nlogging:  file:    name: spring3-log  logback:    rollingpolicy:#      归档、切割      file-name-pattern: &quot;$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log&quot;      max-file-size: 1KB\n\n\n\nWeb开发WebMvcAutoConfiguration效果：\n放了两个Filter：\nHiddenHttpMethodFilter：页面表单提交Rest请求（GET、POST、PUT、DELETE）\nFormContentFilter： 表单内容Filter，GET（数据放URL后面）、POST（数据放请求体）请求可以携带数据，PUT、DELETE 的请求体数据会被忽略\n\n\n给容器中放了WebMvcConfigurer组件；给SpringMVC添加各种定制功能\n所有的功能最终会和配置文件进行绑定\nWebMvcProperties： spring.mvc配置文件\nWebProperties： spring.web配置文件\n\n\n\n@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class) //额外导入了其他配置@EnableConfigurationProperties(&#123; WebMvcProperties.class, WebProperties.class &#125;)@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware&#123;          &#125;\n\nWebMvcConfigurer接口提供了配置SpringMVC底层的所有组件入口\n\n静态资源规则源码@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    if (!this.resourceProperties.isAddMappings()) &#123;        logger.debug(&quot;Default resource handling disabled&quot;);        return;    &#125;    //1、    addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(),            &quot;classpath:/META-INF/resources/webjars/&quot;);    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;        registration.addResourceLocations(this.resourceProperties.getStaticLocations());        if (this.servletContext != null) &#123;            ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);            registration.addResourceLocations(resource);        &#125;    &#125;);&#125;\n\n\n规则一：访问： &#x2F;webjars&#x2F;**路径就去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;下找资源.\nmaven 导入依赖\n\n\n规则二：访问： &#x2F;**路径就去 静态资源默认的四个位置找资源\nclasspath:/META-INF/resources/\nclasspath:/resources/\nclasspath:/static/\nclasspath:/public/\n\n\n规则三：静态资源默认都有缓存规则的设置\n所有缓存的设置，直接通过配置文件： spring.web\ncachePeriod： 缓存周期； 多久不用找服务器要新的。 默认没有，以s为单位\ncacheControl： HTTP缓存控制；https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\nuseLastModified：是否使用最后一次修改。配合HTTP Cache规则\n\n\n\n\n如果浏览器访问了一个静态资源 index.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求。\n\nregistration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());\n\n\n\nEnableWebMvcConfiguration//SpringBoot 给容器中放 WebMvcConfigurationSupport 组件。//我们如果自己放了 WebMvcConfigurationSupport 组件，Boot的WebMvcAutoConfiguration都会失效。@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(WebProperties.class)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;   &#125;\n\n\nHandlerMapping： 根据请求路径  /a 找那个handler能处理请求\nWelcomePageHandlerMapping： \n访问 /**路径下的所有请求，都在以前四个静态资源路径下找，欢迎页也一样\n找index.html：只要静态资源的位置有一个 index.html页面，项目启动默认访问\n\n\n\n\n\nWeb场景自动配置\n整合web场景\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n引入了autoconfigure功能\n\n@EnableAutoConfiguration注解使用@Import(AutoConfigurationImportSelector.class)批量导入组件\n\n所有自动配置类如下：\n\n\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfigurationorg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration===以下是响应式web场景和现在的没关系===org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration==================================org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration\n\n默认效果\n包含了 ContentNegotiatingViewResolver 和 BeanNameViewResolver 组件，方便视图解析\n默认的静态资源处理机制： 静态资源放在 static 文件夹下即可直接访问\n自动注册了 Converter,GenericConverter,Formatter组件，适配常见数据类型转换和格式化需求\n支持 HttpMessageConverters，可以方便返回json等数据类型\n注册 MessageCodesResolver，方便国际化及错误消息处理\n支持 静态 index.html\n自动使用ConfigurableWebBindingInitializer，实现消息处理、数据绑定、类型转化、数据校验等功能\n\n\n重要：\n\n如果想保持 boot mvc 的默认配置，并且自定义更多的 mvc 配置，如：interceptors,* formatters*,* view controllers** *等。可以使用@Configuration*注解添加一个 WebMvcConfigurer 类型的配置类，并不要标注 @EnableWebMvc\n如果想保持 boot mvc 的默认配置，但要自定义核心组件实例，比如：*RequestMappingHandlerMapping,* RequestMappingHandlerAdapter, 或ExceptionHandlerExceptionResolver，给容器中放一个 WebMvcRegistrations 组件即可\n如果想全面接管 Spring MVC，@Configuration 标注一个配置类，并加上 @EnableWebMvc**注解，实现 WebMvcConfigurer 接口\n\n\n静态资源默认规则\n规则一：访问： &#x2F;webjars&#x2F;**路径就去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;下找资源.\nmaven 导入依赖\n\n\n规则二：访问： &#x2F;**路径就去 静态资源默认的四个位置找资源\nclasspath:/META-INF/resources/\nclasspath:/resources/\nclasspath:/static/\nclasspath:/public/\n\n\n规则三：静态资源默认都有缓存规则的设置\n所有缓存的设置，直接通过配置文件： spring.web\ncachePeriod： 缓存周期； 多久不用找服务器要新的。 默认没有，以s为单位\ncacheControl： HTTP缓存控制；https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\nuseLastModified：是否使用最后一次修改。配合HTTP Cache规则\n\n\n\n自定义静态资源规则\n自定义静态资源路径、自定义缓存规则\n\n配置方式spring.mvc： 静态资源访问前缀路径\nspring.web：\n\n静态资源目录\n静态资源缓存策略\n\n#1、spring.web：# 1.配置国际化的区域信息# 2.静态资源策略(开启、处理链、缓存)#开启静态资源映射规则spring.web.resources.add-mappings=true#设置缓存spring.web.resources.cache.period=3600##缓存详细合并项控制，覆盖period配置：## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器spring.web.resources.cache.cachecontrol.max-age=7200## 共享缓存spring.web.resources.cache.cachecontrol.cache-public=true#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304spring.web.resources.cache.use-last-modified=true#自定义静态资源文件夹位置spring.web.resources.static-locations=classpath:/a/,classpath:/b/,classpath:/static/#2、 spring.mvc## 2.1. 自定义webjars路径前缀spring.mvc.webjars-path-pattern=/wj/**## 2.2. 静态资源访问路径前缀spring.mvc.static-path-pattern=/static/**\n\n代码方式\n\n容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效\n@EnableWebMvc &#x2F;&#x2F;禁用boot的默认配置\n\n\n@Configuration //这是一个配置类public class MyConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        //保留以前规则        //自己写新的规则。        registry.addResourceHandler(&quot;/static/**&quot;)                .addResourceLocations(&quot;classpath:/a/&quot;,&quot;classpath:/b/&quot;)                .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS));    &#125;&#125;\n\n@Configuration //这是一个配置类,给容器中放一个 WebMvcConfigurer 组件，就能自定义底层public class MyConfig  /*implements WebMvcConfigurer*/ &#123;    @Bean    public WebMvcConfigurer webMvcConfigurer()&#123;        return new WebMvcConfigurer() &#123;            @Override            public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;                registry.addResourceHandler(&quot;/static/**&quot;)                        .addResourceLocations(&quot;classpath:/a/&quot;, &quot;classpath:/b/&quot;)                        .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS));            &#125;        &#125;;    &#125;&#125;\n\n\n\n路径匹配Ant风格路径用法Ant 风格的路径模式语法具有以下规则：\n\n*：表示任意数量的字符。\n?：表示任意一个字符。\n：表示任意数量的目录**。\n{}：表示一个命名的模式占位符。\n[]：表示字符集合，例如[a-z]表示小写字母。\n\n例如：\n\n*.html 匹配任意名称，扩展名为.html的文件。\n/folder1/*/*.java 匹配在folder1目录下的任意两级目录下的.java文件。\n&#x2F;folder2/**/*.jsp 匹配在folder2目录下任意目录深度的.jsp文件。\n/&#123;type&#125;/&#123;id&#125;.html 匹配任意文件名为{id}.html，在任意命名的&#123;type&#125;目录下的文件。\n\n注意：Ant 风格的路径模式语法中的特殊字符需要转义，如：\n\n要匹配文件路径中的星号，则需要转义为\\\\*。\n要匹配文件路径中的问号，则需要转义为\\\\?。\n\n模式切换\nAntPathMatcher 与 PathPatternParser\n\nPathPatternParser 在 jmh 基准测试下，有 68 倍吞吐量提升，降低 30%40%空间分配率\nPathPatternParser 兼容 AntPathMatcher语法，并支持更多类型的路径模式\nPathPatternParser  “*“ 多段匹配的支持仅允许在模式末尾使用*\n\n\n@GetMapping(&quot;/a*/b?/&#123;p1:[a-f]+&#125;&quot;)public String hello(HttpServletRequest request,                     @PathVariable(&quot;p1&quot;) String path) &#123;    log.info(&quot;路径变量p1： &#123;&#125;&quot;, path);    //获取请求路径    String uri = request.getRequestURI();    return uri;&#125;\n\n总结： \n\n使用默认的路径匹配规则，是由 PathPatternParser  提供的\n如果路径中间需要有 **，替换成ant风格路径\n\n# 改变路径匹配策略：# ant_path_matcher 老版策略；# path_pattern_parser 新版策略；spring.mvc.pathmatch.matching-strategy=ant_path_matcher\n\n\n\n内容协商\n一套系统适配多端数据返回\n\n\n多端内容适配默认规则\nSpringBoot 多端内容适配。\n基于请求头内容协商：（默认开启）\n​    客户端向服务端发送请求，携带HTTP标准的Accept请求头。\n​      Accept: application/json、text/xml、text/yaml\n​      服务端根据客户端请求头期望的数据类型进行动态返回\n基于请求参数内容协商：（需要开启）\n​    发送请求 GET /projects/spring-boot?format=json \n​    匹配到 @GetMapping(&quot;/projects/spring-boot&quot;) \n​    根据参数协商，优先返回 json 类型数据【需要开启参数匹配设置】\n​    发送请求 GET /projects/spring-boot?format=xml，优先返回 xml 类型数据\n\n\n\n效果演示\n请求同一个接口，可以返回json和xml不同格式数据\n\n\n引入支持写出xml内容依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt;\n\n标注注解\n@JacksonXmlRootElement  // 可以写出为xml文档@Datapublic class Person &#123;    private Long id;    private String userName;    private String email;    private Integer age;&#125;\n\n开启基于请求参数的内容协商\n# 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启spring.mvc.contentnegotiation.favor-parameter=true# 指定内容协商时使用的参数名。默认是 formatspring.mvc.contentnegotiation.parameter-name=type\n\n效果\n\n\n\n\n自定义内容返回增加yaml返回支持\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;&lt;/dependency&gt;\n\n把对象写出成YAML\npublic static void main(String[] args) throws JsonProcessingException &#123;    Person person = new Person();    person.setId(1L);    person.setUserName(&quot;张三&quot;);    person.setEmail(&quot;aaa@qq.com&quot;);    person.setAge(18);    YAMLFactory factory = new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);    ObjectMapper mapper = new ObjectMapper(factory);    String s = mapper.writeValueAsString(person);    System.out.println(s);&#125;\n\n编写配置\n#新增一种媒体类型spring.mvc.contentnegotiation.media-types.yaml=text/yaml\n\n增加HttpMessageConverter组件，专门负责把对象写出为yaml格式\n@Beanpublic WebMvcConfigurer webMvcConfigurer()&#123;    return new WebMvcConfigurer() &#123;        @Override //配置一个能把对象转为yaml的messageConverter        public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;            converters.add(new MyYamlHttpMessageConverter());        &#125;    &#125;;&#125;\n\n\n\n模板引擎\n模板引擎页面默认放在 src&#x2F;main&#x2F;resources&#x2F;templates\nSpringBoot 包含以下模板引擎的自动配置\n\nFreeMarker\nGroovy\nThymeleaf\nMustache\n\nThymeleaf官网：https://www.thymeleaf.org\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;`&gt;&lt;head&gt;\t&lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt;\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;\t&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; th:href=&quot;@&#123;/css/gtvg.css&#125;&quot; /&gt;&lt;/head&gt;&lt;body&gt;\t&lt;p th:text=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt;&lt;/body&lt;/html&gt;\n\n\n\nThymeleaf整合&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\n\n自动配置原理\n\n开启了org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration自动配置\n属性绑定在 ThymeleafProperties 中，对应配置文件 spring.thymeleaf 内容\n所有的模板页面默认在 classpath:/templates文件夹下\n默认效果\n所有的模板页面在 classpath:/templates/下面找\n找后缀名为.html的页面\n\n\n\n基本语法th:xxx：动态渲染指定的 html 标签属性值、或者th指令（遍历、判断等）\n\nth:text：标签体内文本值渲染\n\n\nth:utext：不会转义，显示为html原本的样子。\n\n\nth:属性：标签指定属性渲染\n\nth:attr：标签任意属性渲染\n\nth:if``th:each``...：其他th指令\n\n例如：\n\n\n&lt;p th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;&lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;&lt;img src=&quot;../../images/gtvglogo.png&quot; \tth:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;\n\n表达式：用来动态取值\n\n$&#123;&#125;：变量取值；使用model共享给页面的值都直接用${}\n@&#123;&#125;：url路径；\n#&#123;&#125;：国际化消息\n~&#123;&#125;：片段引用\n*&#123;&#125;：变量选择：需要配合th:object绑定对象\n\n系统工具&amp;内置对象：详细文档\n\nparam：请求参数对象\nsession：session对象\napplication：application对象\n#execInfo：模板执行信息\n#messages：国际化消息\n#uris：uri&#x2F;url工具\n#conversions：类型转换工具\n#dates：日期工具，是java.util.Date对象的工具类\n#calendars：类似#dates，只不过是java.util.Calendar对象的工具类\n#temporals： JDK8+ **java.time** API 工具类\n#numbers：数字操作工具\n#strings：字符串操作\n#objects：对象操作\n#bools：bool操作\n#arrays：array工具\n#lists：list工具\n#sets：set工具\n#maps：map工具\n#aggregates：集合聚合工具（sum、avg）\n#ids：id生成工具\n\n属性设置\nth:href&#x3D;”@{&#x2F;product&#x2F;list}”\n\nth:attr&#x3D;”class&#x3D;${active}”\n\nth:attr&#x3D;”src&#x3D;@{&#x2F;images&#x2F;gtvglogo.png},title&#x3D;${logo},alt&#x3D;#{logo}”\n\nth:checked&#x3D;”${user.active}”\n\n\n&lt;p th:text=&quot;$&#123;content&#125;&quot;&gt;原内容&lt;/p&gt;&lt;a th:href=&quot;$&#123;url&#125;&quot;&gt;登录&lt;/a&gt;&lt;img src=&quot;../../images/gtvglogo.png&quot;      th:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;\n\n遍历\n语法：  th:each=&quot;元素名,迭代状态 : $&#123;集合&#125;&quot;\n\n&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt;  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt;&lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;&gt;  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt;\n\niterStat 有以下属性：\n\nindex：当前遍历元素的索引，从0开始\ncount：当前遍历元素的索引，从1开始\nsize：需要遍历元素的总数量\ncurrent：当前正在遍历的元素对象\neven&#x2F;odd：是否偶数&#x2F;奇数行\nfirst：是否第一个元素\nlast：是否最后一个元素\n\n数据访问\nSpringBoot 整合 Spring、SpringMVC、MyBatis 进行数据访问场景开发\n\n创建SSM整合项目&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n\n配置数据源spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demospring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.type=com.zaxxer.hikari.HikariDataSource\n\n安装MyBatisX 插件，帮我们生成Mapper接口的xml文件即可\n配置MyBatis#指定mapper映射文件位置mybatis.mapper-locations=classpath:/mapper/*.xml#参数项调整mybatis.configuration.map-underscore-to-camel-case=true\n\nCRUD编写\n编写Bean\n编写Mapper\n使用mybatisx插件，快速生成MapperXML\n测试CRUD\n\n自动配置原理SSM整合总结：\n\n\n导入 mybatis-spring-boot-starter\n\n配置数据源信息\n\n配置mybatis的mapper接口扫描与xml映射文件扫描\n\n编写bean，mapper，生成xml，编写sql 进行crud。事务等操作依然和Spring中用法一样\n\n效果：\n\n\n所有sql写在xml中\n所有mybatis配置写在application.properties下面\n\n\n\n\n\njdbc场景的自动配置： \n\n\nmybatis-spring-boot-starter导入 spring-boot-starter-jdbc，jdbc是操作数据库的场景\nJdbc场景的几个自动配置\n\n\n\n\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n\n\n\n\n\n\n\n数据源的自动配置\n所有和数据源有关的配置都绑定在DataSourceProperties\n默认使用 HikariDataSource\n\n\n\n\n\n\n\n\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration\n\n\n\n\n\n\n\n给容器中放了JdbcTemplate操作数据库\n\n\n\n\n\n\n\n\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration\n\n\n\n\n\n\n\n基于XA二阶提交协议的分布式事务数据源\n\n\n\n\n\n\n\n\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration\n\n\n\n\n\n\n\n支持事务\n\n\n\n\n\n\n\n具有的底层能力：数据源、JdbcTemplate、事务\n\n\nMyBatisAutoConfiguration：配置了MyBatis的整合流程\n\n\nmybatis-spring-boot-starter导入 mybatis-spring-boot-autoconfigure（mybatis的自动配置包），\n默认加载两个自动配置类：\n\n\n\n\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n\n\n\n\n\n\n\n必须在数据源配置好之后才配置\n给容器中SqlSessionFactory组件。创建和数据库的一次会话\n给容器中SqlSessionTemplate组件。操作数据库\n\n\n\n\n\n\n\nMyBatis的所有配置绑定在MybatisProperties\n每个Mapper接口的代理对象是怎么创建放到容器中。详见**@MapperScan**原理：\n\n\n\n\n利用@Import(MapperScannerRegistrar.class)批量给容器中注册组件。解析指定的包路径里面的每一个类，为每一个Mapper接口类，创建Bean定义信息，注册到容器中。\n\n\n\n\n\n\n如何分析哪个场景导入以后，开启了哪些自动配置类。\n找：classpath:/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中配置的所有值，就是要开启的自动配置类，但是每个类可能有条件注解，基于条件注解判断哪个自动配置类生效了。\n\n快速定位生效的配置#开启调试模式，详细打印开启了哪些自动配置debug=true# Positive（生效的自动配置）  Negative（不生效的自动配置）\n\n\n\n基础特性SpringApplication自定义 banner\n\n类路径添加banner.txt或设置spring.banner.location就可以定制 banner\n推荐网站：Spring Boot banner 在线生成工具\n\n自定义 SpringApplication\nimport org.springframework.boot.Banner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MyApplication &#123;    public static void main(String[] args) &#123;        SpringApplication application = new SpringApplication(MyApplication.class);        application.setBannerMode(Banner.Mode.OFF);        application.run(args);    &#125;&#125;\n\nFluentBuilder API\nnew SpringApplicationBuilder()    .sources(Parent.class)    .child(Application.class)    .bannerMode(Banner.Mode.OFF)    .run(args);\n\n\n\nProfiles\n环境隔离能力；快速切换开发、测试、生产环境\n步骤：\n\n标识环境：指定哪些组件、配置在哪个环境生效\n切换环境：这个环境对应的所有组件和配置就应该生效\n\n\n使用指定环境\n\nSpring Profiles 提供一种隔离配置的方式，使其仅在特定环境生效；\n任何@Component, @Configuration 或 @ConfigurationProperties 可以使用 @Profile 标记，来指定何时被加载。【容器中的组件都可以被 @Profile标记】\n\n环境激活\n\n配置激活指定环境； 配置文件\n\nspring.profiles.active=production,hsqldb\n\n\n也可以使用命令行激活。–spring.profiles.active&#x3D;dev,hsqldb\n\n还可以配置默认环境； 不标注@Profile 的组件永远都存在。\n\n\n以前默认环境叫default\nspring.profiles.default=test\n\n\n推荐使用激活方式激活指定环境\n\n\n环境包含\n注意：\n\nspring.profiles.active 和spring.profiles.default 只能用到 无 profile 的文件中，如果在application-dev.yaml中编写就是无效的\n也可以额外添加生效文件，而不是激活替换。比如：\n\nspring.profiles.include[0]=commonspring.profiles.include[1]=local\n\n最佳实战：\n\n生效的环境 &#x3D; 激活的环境&#x2F;默认环境  + 包含的环境\n\n项目里面这么用\n\n\n基础的配置mybatis、log、xxx：写到包含环境中\n需要动态切换变化的 db、redis：写到激活的环境中\n\n\n\nProfile分组创建prod组，指定包含db和mq配置\nspring.profiles.group.prod[0]=dbspring.profiles.group.prod[1]=mq\n\n使用–spring.profiles.active&#x3D;prod ，就会激活prod，db，mq配置文件\nProfile 配置文件\napplication-&#123;profile&#125;.properties可以作为指定环境的配置文件。\n\n激活这个环境，配置就会生效。最终生效的所有配置是\n\n\napplication.properties：主配置文件，任意时候都生效\napplication-&#123;profile&#125;.properties：指定环境配置文件，激活指定环境生效\n\n\n\nprofile优先级 &gt; application \n外部化配置\n场景：线上应用如何快速修改配置，并应用最新配置？\n\nSpringBoot 使用  配置优先级 + 外部配置  简化配置更新、简化运维。\n只需要给jar应用所在的文件夹放一个application.properties最新配置文件，重启项目就能自动应用最新配置\n\n\n单元测试-JUnit5SpringBoot 提供一系列测试工具集及注解方便我们进行测试。spring-boot-test提供核心测试能力，spring-boot-test-autoconfigure 提供测试的一些自动配置。我们只需要导入spring-boot-starter-test 即可整合测试\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\nspring-boot-starter-test 默认提供了以下库供我们测试使用\n\nJUnit 5\nSpring Test\nAssertJ\nHamcrest\nMockito\nJSONassert\nJsonPath\n\n核心原理事件和监听器自动配置原理自定义starter场景整合Docker安装sudo yum install -y yum-utilssudo yum-config-manager \\    --add-repo \\    https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-pluginsudo systemctl enable docker --now#测试工作docker ps#  批量安装所有软件docker compose  \n\n创建 /prod 文件夹，准备以下文件\nprometheus.yml\nglobal:  scrape_interval: 15s  evaluation_interval: 15sscrape_configs:  - job_name: &#x27;prometheus&#x27;    static_configs:      - targets: [&#x27;localhost:9090&#x27;]  - job_name: &#x27;redis&#x27;    static_configs:      - targets: [&#x27;redis:6379&#x27;]  - job_name: &#x27;kafka&#x27;    static_configs:      - targets: [&#x27;kafka:9092&#x27;]\n\ndocker-compose.yml\nversion: &#x27;3.9&#x27;services:  redis:    image: redis:latest    container_name: redis    restart: always    ports:      - &quot;6379:6379&quot;    networks:      - backend  zookeeper:    image: bitnami/zookeeper:latest    container_name: zookeeper    restart: always    environment:      ZOOKEEPER_CLIENT_PORT: 2181      ZOOKEEPER_TICK_TIME: 2000    networks:      - backend  kafka:    image: bitnami/kafka:3.4.0    container_name: kafka    restart: always    depends_on:      - zookeeper    ports:      - &quot;9092:9092&quot;    environment:      ALLOW_PLAINTEXT_LISTENER: yes      KAFKA_CFG_ZOOKEEPER_CONNECT: zookeeper:2181      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1    networks:      - backend    kafka-ui:    image: provectuslabs/kafka-ui:latest    container_name:  kafka-ui    restart: always    depends_on:      - kafka    ports:      - &quot;8080:8080&quot;    environment:      KAFKA_CLUSTERS_0_NAME: dev      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092    networks:      - backend  prometheus:    image: prom/prometheus:latest    container_name: prometheus    restart: always    volumes:      - ./prometheus.yml:/etc/prometheus/prometheus.yml    ports:      - &quot;9090:9090&quot;    networks:      - backend  grafana:    image: grafana/grafana:latest    container_name: grafana    restart: always    depends_on:      - prometheus    ports:      - &quot;3000:3000&quot;    networks:      - backendnetworks:  backend:    name: backend\n\n启动环境\ndocker compose -f docker-compose.yml up -d\n\nNoSQLRedis依赖导入\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置\nspring.data.redis.host=192.168.200.100spring.data.redis.port=6379\n\n测试\n@AutowiredStringRedisTemplate redisTemplate;@Testvoid redisTest()&#123;    redisTemplate.opsForValue().set(&quot;a&quot;,&quot;1234&quot;);    Assertions.assertEquals(&quot;1234&quot;,redisTemplate.opsForValue().get(&quot;a&quot;));&#125;\n\n自动配置原理\n\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports中导入了RedisAutoConfiguration、RedisReactiveAutoConfiguration和RedisRepositoriesAutoConfiguration。所有属性绑定在RedisProperties&#96;中\n\nRedisReactiveAutoConfiguration属于响应式编程，不用管。RedisRepositoriesAutoConfiguration属于 JPA 操作，也不用管\n\nRedisAutoConfiguration 配置了以下组件\n\n\nLettuceConnectionConfiguration： 给容器中注入了连接工厂LettuceConnectionFactory，和操作 redis 的客户端DefaultClientResources。\nRedisTemplate&lt;Object, Object&gt;： 可给 redis 中存储任意对象，会使用 jdk 默认序列化方式。\nStringRedisTemplate： 给 redis 中存储字符串，如果要存对象，需要开发人员自己进行序列化。key-value都是字符串进行操作··\n\n\n\n\n\n定制化序列化机制\n@Configurationpublic class AppRedisConfiguration &#123;    /**     * 允许Object类型的key-value，都可以被转为json进行存储。     * @param redisConnectionFactory 自动配置好了连接工厂     * @return     */    @Bean    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);        //把对象转为json字符串的序列化工具        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());        return template;    &#125;&#125;\n\nredis客户端\n\nRedisTemplate、StringRedisTemplate： 操作redis的工具类\n\n要从redis的连接工厂获取链接才能操作redis\n\nRedis客户端\n\n\nLettuce： 默认\nJedis：可以使用以下切换\n\n\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--        切换 jedis 作为操作redis的底层客户端--&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n参考配置\nspring.data.redis.host=8.130.74.183spring.data.redis.port=6379#spring.data.redis.client-type=lettuce#设置lettuce的底层参数#spring.data.redis.lettuce.pool.enabled=true#spring.data.redis.lettuce.pool.max-active=8spring.data.redis.client-type=jedisspring.data.redis.jedis.pool.enabled=truespring.data.redis.jedis.pool.max-active=8\n\n\n\n远程调用RPC（Remote Procedure Call）：远程过程调用\n\n本地过程调用： a()； b()； a() { b()；}： 不同方法都在同一个JVM运行\n远程过程调用：\n\n服务提供者：\n服务消费者：\n通过连接对方服务器进行请求\\响应交互，来实现调用效果\n\nAPI&#x2F;SDK的区别是什么？\n\napi：接口（Application Programming Interface）\n\n\n远程提供功能；\n\n\nsdk：工具包（Software Development Kit）\n\n\n导入jar包，直接调用功能即可\n\n\n\n\n***开发过程中***，我们经常需要调用别人写的功能\n\n如果是**内部*微服务，可以通过依赖cloud*、*注册中心、openfeign***等进行调用\n如果是**外部*暴露的，可以发送 http 请求、或遵循外部协议***进行调用\n\nSpringBoot 整合提供了很多方式进行远程调用\n\n*轻量级客户端方式*\n\n\n***RestTemplate***： 普通开发\n***WebClient***： 响应式编程开发\n***Http Interface***： 声明式编程\n\n\n***Spring Cloud分布式***解决方案方式\n\n\nSpring Cloud OpenFeign\n\n\n*第三方框架*\n\n\nDubbo\ngRPC\n…\n\n\n\n\nWebClient\n非阻塞、响应式HTTP客户端\n\n创建于配置\n发请求：\n\n请求方式： GET\\POST\\DELETE\\xxxx\n请求路径： &#x2F;xxx\n请求参数：aa&#x3D;bb&amp;cc&#x3D;dd&amp;xxx\n请求头： aa&#x3D;bb,cc&#x3D;ddd\n请求体：\n\n创建 WebClient 非常简单:\n\nWebClient.create()\nWebClient.create(String baseUrl)\n\n还可以使用 WebClient.builder() 配置更多参数项:\n\nuriBuilderFactory: 自定义UriBuilderFactory ，定义 baseurl.\ndefaultUriVariables: 默认 uri 变量.\ndefaultHeader: 每个请求默认头.\ndefaultCookie: 每个请求默认 cookie.\ndefaultRequest: Consumer 自定义每个请求.\nfilter: 过滤 client 发送的每个请求\nexchangeStrategies: HTTP 消息 reader&#x2F;writer 自定义.\nclientConnector: HTTP client 库设置.\n\n//获取响应完整信息WebClient client = WebClient.create(&quot;https://example.org&quot;);\n\n获取响应\n\nretrieve()方法用来声明如何提取响应数据。比如\n\n//获取响应完整信息WebClient client = WebClient.create(&quot;https://example.org&quot;);Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()        .uri(&quot;/persons/&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)        .retrieve()        .toEntity(Person.class);//只获取bodyWebClient client = WebClient.create(&quot;https://example.org&quot;);Mono&lt;Person&gt; result = client.get()        .uri(&quot;/persons/&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)        .retrieve()        .bodyToMono(Person.class);//stream数据Flux&lt;Quote&gt; result = client.get()        .uri(&quot;/quotes&quot;).accept(MediaType.TEXT_EVENT_STREAM)        .retrieve()        .bodyToFlux(Quote.class);//定义错误处理Mono&lt;Person&gt; result = client.get()        .uri(&quot;/persons/&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)        .retrieve()        .onStatus(HttpStatus::is4xxClientError, response -&gt; ...)        .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)        .bodyToMono(Person.class);\n\n\n天气调用结果图\n\n\nHTTP Interface\nSpring 允许我们通过定义接口的方式，给任意位置发送 http 请求，实现远程调用，可以用来简化 HTTP 远程访问。需要webflux场景才可\n\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;\n\n定义接口\npublic interface BingService &#123;    @GetExchange(url = &quot;/search&quot;)    String search(@RequestParam(&quot;q&quot;) String keyword);&#125;\n\n创建代理&amp;测试\n@SpringBootTestclass Boot05TaskApplicationTests &#123;    @Test    void contextLoads() throws InterruptedException &#123;        //1、创建客户端        WebClient client = WebClient.builder()                .baseUrl(&quot;https://cn.bing.com&quot;)                .codecs(clientCodecConfigurer -&gt; &#123;                    clientCodecConfigurer                            .defaultCodecs()                            .maxInMemorySize(256*1024*1024);                            //响应数据量太大有可能会超出BufferSize，所以这里设置的大一点                &#125;)                .build();        //2、创建工厂        HttpServiceProxyFactory factory = HttpServiceProxyFactory                .builder(WebClientAdapter.forClient(client)).build();        //3、获取代理对象        BingService bingService = factory.createClient(BingService.class);        //4、测试调用        Mono&lt;String&gt; search = bingService.search(&quot;尚硅谷&quot;);        System.out.println(&quot;==========&quot;);        search.subscribe(str -&gt; System.out.println(str));        Thread.sleep(100000);    &#125;&#125;\n\n消息服务Web安全\nApache Shiro\nSpring Security\n自研：Filter\n\nSpring Security认证：Authentication\n\nwho are you?登录系统，用户系统\n\n授权：Authorization\n\nwhat are you allowed to do？权限管理，用户授权\n\n攻击防护\n\n● XSS（Cross-site scripting）● CSRF（Cross-site request forgery）● CORS（Cross-Origin Resource Sharing）● SQL注入● …\n\n扩展：权限模型\nRBAC(Role Based Access Controll)\n\n● 用户（t_user）  ○ id,username,password，xxx  ○ 1,zhangsan  ○ 2,lisi● 用户_角色（t_user_role）【N对N关系需要中间表】  ○ zhangsan, admin  ○ zhangsan,common_user  ○ lisi, hr  ○ lisi, common_user● 角色（t_role）  ○ id,role_name  ○ admin  ○ hr  ○ common_user● 角色_权限(t_role_perm)  ○ admin, 文件r  ○ admin, 文件w  ○ admin, 文件执行  ○ admin, 订单query，create,xxx  ○ hr, 文件r● 权限（t_permission）  ○ id,perm_id  ○ 文件 r,w,x  ○ 订单 query,create,xxx\n\n\nACL(Access Controll List)\n\n直接用户和权限挂钩● 用户（t_user）  ○ zhangsan  ○ lisi● 用户_权限(t_user_perm)  ○ zhangsan,文件 r  ○ zhangsan,文件 x  ○ zhangsan,订单 query● 权限（t_permission）  ○ id,perm_id  ○ 文件 r,w,x  ○ 订单 query,create,xxx\n\n\n\n@Secured(&quot;文件 r&quot;)public void readFile()&#123;    //读文件&#125;\n\nSpring Security 原理过滤器链架构\nSpring Security利用 FilterChainProxy 封装一系列拦截器链，实现各种安全拦截功能\nServlet三大组件：Servlet、Filter、Listener\n\n\nFilterChainProxy\nSecurityFilterChain\n使用HttpSecurity@Configuration@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;  @Override  protected void configure(HttpSecurity http) throws Exception &#123;    http.antMatcher(&quot;/match1/**&quot;)      .authorizeRequests()        .antMatchers(&quot;/match1/user&quot;).hasRole(&quot;USER&quot;)        .antMatchers(&quot;/match1/spam&quot;).hasRole(&quot;SPAM&quot;)        .anyRequest().isAuthenticated();  &#125;&#125;\n\nMethodSecurity@SpringBootApplication@EnableGlobalMethodSecurity(securedEnabled = true)public class SampleSecureApplication &#123;&#125;@Servicepublic class MyService &#123;  @Secured(&quot;ROLE_USER&quot;)  public String secure() &#123;    return &quot;Hello Security&quot;;  &#125;&#125;\n\n核心\n\nWebSecurityConfigurerAdapter\n\n@EnableGlobalMethodSecurity： 开启全局方法安全配置\n\n\n@Secured\n@PreAuthorize\n@PostAuthorize\n\n\nUserDetailService： 去数据库查询用户详细信息的service（用户基本信息、用户角色、用户权限）\n\n\n实战引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity6&lt;/artifactId&gt;    &lt;!-- Temporary explicit version to fix Thymeleaf bug --&gt;    &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\n页面首页\n&lt;p&gt;Click &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;here&lt;/a&gt; to see a greeting.&lt;/p&gt;\n\nHello页\n&lt;h1&gt;Hello&lt;/h1&gt;\n\n登录页\n&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;https://www.thymeleaf.org&quot;&gt;  &lt;head&gt;    &lt;title&gt;Spring Security Example&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div th:if=&quot;$&#123;param.error&#125;&quot;&gt;Invalid username and password.&lt;/div&gt;    &lt;div th:if=&quot;$&#123;param.logout&#125;&quot;&gt;You have been logged out.&lt;/div&gt;    &lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;      &lt;div&gt;        &lt;label&gt; User Name : &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;/label&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label&gt; Password: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;/label&gt;      &lt;/div&gt;      &lt;div&gt;&lt;input type=&quot;submit&quot; value=&quot;Sign In&quot; /&gt;&lt;/div&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n","categories":["高级语言"],"tags":["Java","SpringBoot"]},{"title":"SpringCloud","url":"/2023/09/19/SpringCloud/","content":"SpringCloud目前微服务的开发框架，最常用的有以下四个：\nSpring Cloud：http://projects.spring.io/spring-cloud（现在非常流行的微服务架构）\nDubbo：http://dubbo.io\nDropwizard：http://www.dropwizard.io （关注单个微服务的开发）\nConsul、etcd&amp;etc.（微服务的模块）\n基本概念什么是 SpringCloudSpring Cloud 是一系列框架的集合。它利用 Spring Boot 的开发便利性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、 熔断器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 SpringBoot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包\nSpringCloud 与 SpringBoot 的关系\nSpring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个微服务，Spring Cloud 是一个基于 Spring Boot 实现的开发工具；\nSpring Boot 专注于快速、方便集成的单个微服务个体，Spring Cloud 关注全局的服务治理框架；\nSpring Boot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud 很大的一部分是基于 Spring Boot 来实现，必须基于 Spring Boot 开发。\n可以单独使用 Spring Boot 开发项目，但是 Spring Cloud 离不开 Spring Boot。\n\nSpring Cloud 主要基础服务组件服务发现——Netflix Eureka （Nacos）\n服务调用——Netflix Feign\n熔断器——Netflix Hystrix （Sentinel）\n服务网关——Spring Cloud GateWay\n分布式配置——Spring Cloud Config （Nacos）\nNacos 下载与安装SpringCloud-Nacos（1）Nacos 是阿里巴巴推出来的一个新开源项目，是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。\n（2）常见的注册中心：\n\nEureka（原生，2.0 遇到性能瓶颈，停止维护）\n\nZookeeper（支持，专业的独立产品。例如：dubbo）\n\nConsul（原生，GO 语言开发）\n\nNacos\n\n\n相对于 Spring Cloud Eureka 来说，Nacos 更强大。Nacos &#x3D; Spring Cloud Eureka + Spring Cloud Config\nNacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config\n- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。\n（3）Nacos 是以服务为主要服务对象的中间件，Nacos 支持所有主流的服务发现、配置和管理。\nNacos 主要提供以下四大功能：\n\n服务发现和服务健康监测\n\n动态配置服务\n\n动态 DNS 服务\n\n服务及其元数据管理\n\n\n（4）Nacos 结构图\n\nNacos 下载和安装（1）下载地址和版本\n下载地址：https://github.com/alibaba/nacos/releases\n下载版本：nacos-server-2.2.1.tar.gz 或 nacos-server-2.2.1.zip，解压没有中文没有空格目录即可\n（2）修改配置文件\n参考官方文档：https://nacos.io/zh-cn/docs/v2/guide/user/auth.html\n在/nacos/conf/application.properties中，修改nacos.core.auth.plugin.nacos.token.secret.key的，因为 2.2.0.1 以后无默认值\n\n\n\nnacos.core.auth.plugin.nacos.token.secret.key\nSecretKey012345678901234567890123456789012345678901234567890123456789(2.2.0.1 后无默认值)\n2.1.0 ~ latest\n默认鉴权插件用于生成用户登陆临时 accessToken 所使用的密钥，使用默认值有安全风险\n\n\n\n（3）启动 nacos 服务\n- Linux&#x2F;Unix&#x2F;Mac\n启动命令(standalone 代表着单机模式运行，非集群模式)\n启动命令：sh startup.sh -m standalone\n- Windows\n启动方式，cmd 打开，执行命令：\nstartup.cmd -m standalone\n\n访问：http://localhost:8848/nacos\n用户名密码：nacos&#x2F;nacos\n\n服务注册把各个微服务注册到注册中心，其他模块步骤相同\n在 service 模块配置 pom配置 Nacos 客户端的 pom 依赖\n&lt;!--服务注册--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n添加服务配置信息配置 application.yml，在客户端微服务中添加注册 Nacos 服务的配置信息\nspring:  cloud:    nacos:      server-addr: localhost:8848\n\n添加 Nacos 客户端注解在客户端微服务启动类中添加注解\n@EnableDiscoveryClient\n\n启动客户端微服务启动注册中心\n启动已注册的微服务，可以在 Nacos 服务列表中看到被注册的微服务\n\n","categories":["高级语言"],"tags":["Java","SpringCloud"]},{"title":"Vue与Uni-APP教程","url":"/2023/10/18/Vue/","content":"ES6语法Promise语法回调函数举例就以uniapp里面的网络请求uni.request()为例了，如果是微信小程序wx.request()也是一样的，还有jQuery的ajax()，这些都是异步请求，通过success回调函数获取数据的，而axios网络请求已经封装了promise了。\n例如我们先要获取文章分类列表的id，再得到数据后，通过id获取该分类下的所有文章，再通过文章的id获取文章下的评论，最终获取该文章的所有评论：\ngetData() &#123;//获取分类列表iduni.request(&#123;    url: &quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,    success: res =&gt; &#123;        let id = res.data[0].id        // 根据分类id获取该分类下的所有文章        uni.request(&#123;            url: &quot;https://ku.qingnian8.com/dataApi/news/newslist.php&quot;,            data: &#123;                cid: id            &#125;,            success: res2 =&gt; &#123;                //获取到一篇文章的id，根据文章id找到该文章下的评论                let id = res2.data[0].id;                uni.request(&#123;                    url: &quot;https://ku.qingnian8.com/dataApi/news/comment.php&quot;,                    data: &#123;                        aid: id                    &#125;,                    success: res3 =&gt; &#123;                        //找到该文章下所有的评论                        console.log(res3)                    &#125;                &#125;)            &#125;        &#125;)    &#125;&#125;)\n\n上面的代码，有多层嵌套，出现多个success回调，按照这样写的话，可维护、可读性很差，下面开始改造：\nonLoad() &#123;    this.getNav(res =&gt; &#123;        console.log(res);    &#125;);&#125;,methods: &#123;    getNav(callback) &#123;        uni.request(&#123;            url: &quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,            success: res =&gt; &#123;                callback(res)            &#125;        &#125;)    &#125;,&#125;\n\n我们在getNav()中可以传一个回调函数callback，将请求的结果调用回调callback(res)，下面全部改写回调函数：\nonLoad() &#123;\t// 调用获取导航列表后，将结果调用其他函数时，额外传入一个回调函数    this.getNav(res =&gt; &#123;        let id = res.data[0].id;        this.getList(id, res =&gt; &#123;            let id = res.data[0].id;            this.getComment(id, res =&gt; &#123;                console.log(res);            &#125;)        &#125;);    &#125;);    &#125;,    methods: &#123;    // 获取导航列表    getNav(callback) &#123;        uni.request(&#123;            url: &quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,            success: res =&gt; &#123;                callback(res)            &#125;        &#125;)    &#125;,    // 获取新闻列表    getList(id, callback) &#123;        uni.request(&#123;            url: &quot;https://ku.qingnian8.com/dataApi/news/newslist.php&quot;,            data: &#123;                cid: 51            &#125;,            success: res =&gt; &#123;                callback(res);            &#125;        &#125;)    &#125;,    // 获取当前新闻的评论    getComment(id, callback) &#123;        uni.request(&#123;            url: &quot;https://ku.qingnian8.com/dataApi/news/comment.php&quot;,            data: &#123;                aid: id            &#125;,            success: res =&gt; &#123;                callback(res);            &#125;        &#125;)    &#125;,&#125;\n\n这样的话仔细看来，并没有解决回调地狱的问题，还是回调里面嵌套回调，只是把函数独立出来了，看着清晰条理了一些而已，但是维护难度还是有的，所以随着ES6的普及，这种方案逐渐边缘化，取而代之的就是promise方案了。\n什么是promisepromise是解决异步的方法，本质上是一个构造函数，可以用它实例化一个对象。对象身上有resolve、reject、all，原型上有then、catch方法。promise对象有三种状态：pending（初识状态&#x2F;进行中）、resolved或fulfilled（成功）、rejected（失败）\n\npending。它的意思是 “待定的，将发生的”，相当于是一个初始状态。创建Promise对象时，且没有调用resolve或者是reject方法，相当于是初始状态。这个初始状态会随着你调用resolve，或者是reject函数而切换到另一种状态。 \nresolved。表示解决了，就是说这个承诺实现了。 要实现从pending到resolved的转变，需要在 创建Promise对象时，在函数体中调用了resolve方法\nrejected。拒绝，失败。表示这个承诺没有做到，失败了。要实现从pending到rejected的转换，只需要在创建Promise对象时，调用reject函数。\n\n通过代码打印promise的方法：\n\nconsole.dir(Promise)\n\n\n\n使用Promise进行改造：\nonLoad() &#123;    this.getNav().then(res =&gt; &#123;        console.log(res);    &#125;)&#125;,methods: &#123;    // 获取导航列表    getNav() &#123;        return new Promise((resolve, reject) =&gt; &#123; // 返回promise对象            uni.request(&#123;                url: &quot;https://ku.qingnian8.com/dataApi/news/navlist.php&quot;,                success: res =&gt; &#123;                    resolve(res);                &#125;,                fail: (err) =&gt; &#123;                    reject(err);                &#125;            &#125;)        &#125;)    &#125;,&#125;\n\n最后的调用变为了.then的链式调用：\n//promise链式调用this.getNav().then(res=&gt;&#123;    let id=res.data[0].id;    return this.getArticle(id);&#125;).then(res=&gt;&#123;    let id=res.data[0].id;    return this.getComment(id);&#125;).then(res=&gt;&#123;    console.log(res);&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)\n\n如果想要等待所有请求全部加载完成再响应，可以使用：\nonLoad() &#123;    let p1 = this.getNav();    let p2 = this.getArticle();    let p3 = this.getComment();    Promise.all([p1, p2, p3]).then(res =&gt; &#123;    \tconsole.log(res);    &#125;)&#125;\n\nawait&#x2F;async异步处理同步化这两个命令是成对出现的，如果使用await没有在函数中使用async命令，那就会报错，如果直接使用async没有使用await不会报错，只是返回的函数是个promise，可以，但是没有意义，所以这两个一起使用才会发挥出它们本身重要的作用。\n这两个命令怎么用那，还是通过上面的案例，来该着一下then的链式调用代码。\nasync onLoad() &#123;    let id, res;    res = await this.getNav();    id = res.data[0].id;    res = await this.getArticle(id);    id = res.data[0].id;    res = await this.getComment(id);    console.log(res)&#125;,\n\n以上代码就是最终的改造版了，可以看到onload是函数，这个函数必须有async命令，在调用函数的部分，前面都加了一个await，这个命令的意思就是等这一行的异步方法执行成功后，将返回的值赋值给res变量，然后才能再走下一行代码，这就是将原来的异步编程改为了同步编程，这就是标题提到的“异步处理，同步化”。\n\n总结：如果涉及到网络请求没有依赖关系的话，异步请求是效率最高的，但是下一个的方法依赖于上一个网络请求的结果，那么久必须使用await命令，将异步结果等待返回之后再执行后面的代码。\nVue3项目初始化搭建脚手架npm create vue@latest\n\n然后根据自己需要进行脚手架的设置：\nD:\\我的文件\\Desktop&gt;npm create vue@latestVue.js - The Progressive JavaScript Framework√ 请输入项目名称： ... vue3√ 是否使用 TypeScript 语法？ ... 否 / 是√ 是否启用 JSX 支持？ ... 否 / 是√ 是否引入 Vue Router 进行单页面应用开发？ ... 否 / 是√ 是否引入 Pinia 用于状态管理？ ... 否 / 是√ 是否引入 Vitest 用于单元测试？ ... 否 / 是√ 是否要引入一款端到端（End to End）测试工具？ » 不需要√ 是否引入 ESLint 用于代码质量检测？ ... 否 / 是正在构建项目 D:\\我的文件\\Desktop\\vue3...项目构建完成，可执行以下命令：  cd vue3  npm install  npm run dev\n\n项目目录.vscode\t\t\t\t\t--- VScode工具的配置文件node_modules\t\t\t--- Vue项目的运行依赖文件夹public\t\t\t\t\t--- 资源文件夹（浏览器图标）src\t\t\t\t\t\t--- 源码文件夹.gitignore\t\t\t\t--- git忽略文件index.html\t\t\t\t--- rHTML文件package.json\t\t\t--- 信息描述文件README.md\t\t\t\t--- 注释文件vite.config.js\t\t\t--- Vue配置文件\n\n插件在官方推荐的编译器VSode中，安装Volar插件，用来支持Vue语法\n\n还可以在这个插件中设置，在使用Ref数据使，自动添加**.value**\n在VScode的设置中，选择：扩展 -&gt; Volar ，勾选&#x3D;&#x3D;自动输入value&#x3D;&#x3D;\n\nvue-router引入vue-router安装：\nnpm install vue-router\n\n使用:\n在src目录下，新建文件夹router，在router文件夹中新建文件index.ts/index.js，写入一下内容\n// 创建一个路由器，暴露出去import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;// 测试路由import Home from &#x27;@/pages/Home.vue&#x27;const router = createRouter(&#123;  history: createWebHistory(import.meta.env.BASE_URL), // 路由器的工作模式  routes: [    &#123;      path: &#x27;/home&#x27;,      component: Home    &#125;  ]&#125;)export default router\n\n在main.ts/main.js中引入：\nimport router from &#x27;./router&#x27;app.use(router)\n\n在组件中可以使用这种方式：RouterLink为路由跳转，RouterView为不同路由的显示\n&lt;!-- 导航区 --&gt;&lt;div class=&quot;navigate&quot;&gt;    &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;    &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;    &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;&lt;/div&gt;&lt;!-- 展示区 --&gt;&lt;div class=&quot;main-content&quot;&gt;    &lt;RouterView /&gt;&lt;/div&gt;\n\n路由器工作模式\nhistory模式\n\n优点：URL更加美观，不带有#，更接近传统的网站URL。\n缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有404模式。\nconst router = createRouter(&#123;  history: createWebHistory(), // history模式  /******/&#125;)\n\n\nhash模式\n\n优点：兼容性更好，因为不需要服务端处理路径。\n缺点：URL带有#不太美观，且在SEO优化方面相对较差\nconst router = createRouter(&#123;  history: createWebHashHistory(), // hash模式  /******/&#125;)\n\n\n路由_to的两种写法\n路径字符串方式\n&lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;\n\n\n\n路径对象方式\n&lt;RouterLink :to=&quot;&#123;path: &#x27;/homne&#x27;&#125;&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;\n\n路由传参路由传参可通过 query、param\nquery参数:\n直接通过路由传参：\n&lt;router-link :to=&quot;`/news/detail?id=$&#123;news.id&#125;&amp;title=$&#123;news.title&#125;&amp;content=$&#123;news.content&#125;`&quot;&gt;    &#123;&#123; news.title &#125;&#125;&lt;/router-link&gt;\n\n在跳转到的路由组件中，使用route获取\n&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; route.query.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; route.query.title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; route.query.content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Detail&quot;&gt;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute();&lt;/script&gt;\n\n\n优化写法:\n\n路由传参：将to使用对象写法，query中写参数\n&lt;router-link  :to=&quot;&#123;          path: `/news/detail`,          query: &#123;            id: news.id,            title: news.title,            content: news.content          &#125;        &#125;&quot;        &gt;    &#123;&#123; news.title &#125;&#125;&lt;/router-link&gt;\n\n在跳转到的路由组件中，使用route获取\n&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; query.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; query.title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; query.content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Detail&quot;&gt;import &#123; toRefs &#125; from &quot;vue&quot;;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute();const &#123;query&#125; = toRefs(route);&lt;/script&gt;\n\nparam参数:\n首先在路由配置页中，预留参数位：在子路由的path中写入detail/:id/:title/:content\nroutes: [    &#123;      path: &#x27;/news&#x27;,      component: News,      children: [          &#123;              path: &#x27;detail/:id/:title/:content&#x27;,              component: Detail          &#125;      ]    &#125;,]\n\n路由跳转：\n&lt;router-link :to=&quot;`/news/detail/$&#123;news.id&#125;/$&#123;news.title&#125;/$&#123;news.content&#125;`&quot;&gt;    &#123;&#123; news.title &#125;&#125;&lt;/router-link&gt;\n\n路由接收：\n&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; route.params.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; route.params.title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; route.params.content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Detail&quot;&gt;import &#123;useRoute&#125; from &quot;vue-router&quot;;const route = useRoute();&lt;/script&gt;\n\n\n优化写法\n\n在路由配置页中，为路由设置名称\nchildren: [    &#123;        name: &#x27;detail&#x27;,        path: &#x27;detail/:id/:title/:content&#x27;,        component: Detail    &#125;]\n\n路由跳转: 且params中不可以传对象或数组\n&lt;RouterLink :to=&quot;&#123;  name: &#x27;detail&#x27;,  params: &#123;    id: news.id,    title: news.title,    content: news.content  &#125;&#125;&quot;&gt;  &#123;&#123; news.title&#125;&#125;&lt;/RouterLink&gt;\n\n\n如果有些参数不是必要的，可以在路由配置页中，在该参数后面加一个?\n\nchildren: [    &#123;        name: &#x27;detail&#x27;,        path: &#x27;detail/:id/:title/:content?&#x27;,        component: Detail    &#125;]\n\nprops配置为了简化在路由接收时，从route中取值的繁琐步骤，可在路由配置页，添加：props: true\nchildren: [    &#123;        name: &#x27;detail&#x27;,        path: &#x27;detail/:id/:title/:content&#x27;,        component: Detail,        props: true    &#125;]\n\n此时，路由组件&lt;Detail /&gt;相当于变为了 &lt;Detail id=? title=? content=? /&gt;，将接收到的参数转化为props\n在路由接收页面就可以直接通过 defineProps 拿到参数：\n&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Detail&quot;&gt;defineProps([&#x27;id&#x27;, &#x27;title&#x27;, &#x27;content&#x27;])&lt;/script&gt;\n\n\nProps有三种写法，选择合适的写法\n\n&#123;\t\t// 第一种写法：将路由收到的所有params参数作为props传给路由组件\tprops: true,\t// 第二种写法：第二种写法：函数写法，可以自己决定将什么作为props传给路由组件    props(route)&#123;    \treturn route.query    &#125;\t// 第三种写法：对象写法，可以自己决定将什么作为props传给路由组件    props: &#123;        id: 1,        title: &#x27;新闻标题&#x27;,        content: &#x27;新闻内容&#x27;    &#125;&#125;\n\nreplace属性\n作用：控制路由跳转时操作浏览器历史记录的模式。\n\n浏览器的历史记录有两种写入方式：分别为push和replace：\n\npush是追加历史记录（默认值）。可在浏览器点击退后，返回之前路由\nreplace是替换当前记录。无法回退之前路由，可用于登录页跳转\n\n\n开启replace模式：加入replace\n&lt;Router-link replace to=&quot;/home&quot;&gt;首页&lt;/Router-link&gt;\n\n编程式路由导航编程式路由导航，为了脱离&lt;RouterLink&gt;实现路由跳转，我们只需要在组件种引入useRouter\nimport &#123; useRouter &#125; from &quot;vue-router&quot;;const router = useRouter()// 此处 push 用法和路由 to 的用法一样，有两种，字符串和对象写法router.push(&#123;    name: &#x27;detail&#x27;,    params: &#123;      id: news.id,      title: news.title,      content: news.content    &#125;&#125;)\n\n编程式路由可写在函数中，当满足条件进行跳转，例如登录跳转。\n重定向使用redirect可重定向到指定路由\nconst router = createRouter(&#123;    history: createWebHistory(import.meta.env.BASE_URL), // 路由器的工作模式    routes: [        &#123;            path: &#x27;/home&#x27;,            component: Home        &#125;,        &#123;            path: &#x27;/&#x27;,            redirect: &#x27;/home&#x27;        &#125;    ]&#125;)\n\nPiniaVue的状态管理库\n搭建pinia环境安装pinia\nnpm i pinia\n\n在main.ts/main.js中引入pinia：\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 第一步：引入piniaimport &#123; createPinia &#125; from &#x27;pinia&#x27;const app = createApp(App)// 第二步：创建piniaconst pinia = createPinia()// 第三步：挂载piniaapp.use(pinia)app.mount(&#x27;#app&#x27;)\n\n存储+读取数据假如我们有一个组件叫Count.vue，我们需要存储一个数据为：sum，我们可以在项目路径中@/src/store中创建count.ts，写入\ndefineStore需要一个id和对象，id我们使用组件名\nimport &#123;defineStore&#125; from &quot;pinia&quot;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;    // 真正存储数据的地方    state() &#123;        return &#123;            sum: 0        &#125;    &#125;&#125;)\n\n在组件Count.vue中使用时，我们先引入count.ts，在通过count.ts中暴露出的useCountStore.sum获取数据\nimport &#123;useCountStore&#125; from &quot;@/store/count&quot;const countStore = useCountStore()// 取数据countStore.sum\n\n\n更方便的读取数据 storeToRefs,使用storeToRefs，只会关注store中的数据，不会对方法进行ref包裹\n\nimport &#123;useCountStore&#125; from &quot;@/store/count&quot;import &#123;storeToRefs&#125; from &quot;pinia&quot;;const countStore = useCountStore()const &#123;sum, school, address&#125; = storeToRefs(countStore)\n\n\n\n修改数据(3种方式)第一种修改方式，直接操作数据\nfunction add() &#123;  countStore.sum += 1&#125;\n\n第二种修改方式，批量变更，使用$patch可以进行批量数据修改，当批量数据变更时使用这种\nfunction add() &#123;  countStore.$patch(&#123;    sum: countStore.sum += n.value,    school: &#x27;bjdx&#x27;  &#125;)&#125;\n\n第三种修改方式，在count.ts中编写修改数据的行为，在count.ts中加入actions，在actions中编写修改行为，可复用\nimport &#123;defineStore&#125; from &quot;pinia&quot;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;    // actions里面放置的是一个一个方法，用于响应组件的“动作”    actions: &#123;        increment(value: number) &#123;            this.sum += value // 此处无法直接获取sum，需使用this.sum获取        &#125;    &#125;,    // 真正存储数据的地方    state() &#123;        return &#123;            sum: 0,            school: &#x27;北京大学&#x27;,            address: &#x27;北京市朝阳区芍药居&#x27;        &#125;    &#125;&#125;)\n\n在count.ts组件中调用: 直接使用 countStore.方法\nfunction add() &#123;  countStore.increment(n.value)&#125;\n\ngetters使用在count.ts中，可以加入getters：\nimport &#123;defineStore&#125; from &quot;pinia&quot;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;    /******/,    getters: &#123;        bigSum: state =&gt; state.sum * 10,        upperSchool(): string &#123;            return this.school.toUpperCase()        &#125;    &#125;&#125;)\n\n使用时和state中的数据一样，推荐使用方法：\nimport &#123;useCountStore&#125; from &quot;@/store/count&quot;import &#123;storeToRefs&#125; from &quot;pinia&quot;;const countStore = useCountStore()const &#123;sum, school, address, bigSum, upperSchool&#125; = storeToRefs(countStore)\n\n$subscribe使用$subscribe可以监视store中的数据变化，例如下面代码\nimport &#123;useTalkStore&#125; from &quot;@/store/loveTalk&quot;;const talkStore = useTalkStore()talkStore.$subscribe((mutation, state) =&gt; &#123;  console.log(mutation)  console.log(state)&#125;)\n\nmutation: 提供关于状态更改操作的详细信息\nstate: 取到存储的当前最新的完整状态\nStore的组合式store还可以用组合式去书写，例如loveTalk.ts\nimport &#123;reactive&#125; from &quot;vue&quot;;export const useTalkStore = defineStore(&#x27;talk&#x27;, () =&gt; &#123;    // talkList 就是 state    const talkList = reactive(JSON.parse(localStorage.getItem(&#x27;talkList&#x27;) as string) || [])    // 函数 相当于action    async function getAllTalk() &#123;        let &#123;data: &#123;content: title&#125;&#125; = await axios.get(&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;)        let obj = &#123;id: nanoid(), title: title&#125;        talkList.unshift(obj)    &#125;    return &#123;talkList,getAllTalk&#125;&#125;)\n\n\n\n组件通信【props】概述：props是使用频率最高的一种通信方式，常用于：父 &lt;-&gt; 子\n\n若父传子：属性值是非函数\n若子传父：属性值是函数\n\n首先我们创建一个父组件：Father.vue\n&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件&lt;/h3&gt;\t\t&lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;\t\t&lt;h4 v-show=&quot;toy&quot;&gt;子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;\t\t&lt;Child :car=&quot;car&quot; :sendToy=&quot;getToy&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;\timport Child from &#x27;./Child.vue&#x27;\timport &#123;ref&#125; from &#x27;vue&#x27;\t// 数据\tlet car = ref(&#x27;梅赛德斯奔驰&#x27;)\tlet toy = ref(&#x27;&#x27;)\t// 方法\tfunction getToy(value:string)&#123;\t\ttoy.value = value\t&#125;&lt;/script&gt;\n\n一个子组件：Child.vue\n&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h3&gt;子组件&lt;/h3&gt;\t\t&lt;h4&gt;玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;\t\t&lt;h4&gt;父给的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;\t\t&lt;button @click=&quot;sendToy(toy)&quot;&gt;把玩具给父亲&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;\timport &#123;ref&#125; from &#x27;vue&#x27;\t// 数据\tlet toy = ref(&#x27;奥特曼&#x27;)\t// 声明接收props\tdefineProps([&#x27;car&#x27;,&#x27;sendToy&#x27;])&lt;/script&gt;\n\n父组件传给子组件，通过在子组件:car=&#39;car&#39;，子组件通过defineProps拿到&#39;car&#39;\n子组件传给父组件，在子组件的按钮上写上父组件传的sendToy函数，父组件使用getToy方法获取的值\n\n注意：props适合父子组件，如果组件嵌套过深不适合使用\n\n【自定义事件】自定义事件专门用于：子-&gt;父\n在父组件中，给子组件添加自定义事件：@自定义事件，并且在子组件使用defineEmits(),使用emit去接收\n父组件：Father.vue\n&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h3&gt;父组件&lt;/h3&gt;\t\t&lt;h4 v-show=&quot;toy&quot;&gt;子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;\t\t&lt;!-- 给子组件Child绑定事件 --&gt;    &lt;Child @send-toy=&quot;saveToy&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;  import Child from &#x27;./Child.vue&#x27;\timport &#123; ref &#125; from &quot;vue&quot;;\t// 数据\tlet toy = ref(&#x27;&#x27;)\t// 用于保存传递过来的玩具\tfunction saveToy(value:string)&#123;\t\tconsole.log(&#x27;saveToy&#x27;,value)\t\ttoy.value = value\t&#125;&lt;/script&gt;\n\n子组件：Child.vue\n&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h3&gt;子组件&lt;/h3&gt;\t\t&lt;h4&gt;玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;\t\t&lt;button @click=&quot;emit(&#x27;send-toy&#x27;,toy)&quot;&gt;测试&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;\timport &#123; ref &#125; from &quot;vue&quot;;\t// 数据\tlet toy = ref(&#x27;奥特曼&#x27;)\t// 声明事件\tconst emit =  defineEmits([&#x27;send-toy&#x27;])&lt;/script&gt;\n\n【mitt】Uni-App编写Uni-App，推荐使用官方的IDE：HBuilderX，编写微信小程序，还需要下载微信开发者工具：微信开发者工具\n引入插件DCloud有活跃的插件市场，https://ext.dcloud.net.cn，并提供了变现、评价等机制。\nDCloud插件市场将插件分为前端组件、JS SDK、uni-app前端模板、App原生插件、uniCloud等7大类、20多个子类。\n比如安装uni-ui：uni-ui，点击下载插件并导入HBuilderX\n\n云存储云存储的上传方式有3种：\n\nweb界面：即在https://unicloud.dcloud.net.cn web控制台，点击云存储，通过web界面进行文件上传。该管理界面同时提供了资源浏览、删除等操作界面。\n\n客户端API或组件上传：在前端js中编写uniCloud.uploadFile，或者使用uni ui的FilePicker组件，文件选择+上传均封装完毕。\n&lt;uni-file-picker v-model=&quot;imageValue&quot; fileMediatype=&quot;image&quot; mode=&quot;grid&quot; @select=&quot;select&quot; @progress=&quot;progress&quot;@success=&quot;success&quot; @fail=&quot;fail&quot; ref=&quot;files&quot; /&gt;\n云函数上传文件到云存储：即在云函数js中编写uniCloud.uploadFile\n\n\n使用云函数js编写：\n自定义上传页面\n&lt;template&gt;\t&lt;view class=&quot;file&quot;&gt;\t\t&lt;view class=&quot;uploadGroup&quot;&gt;\t\t\t&lt;view class=&quot;box&quot; v-for=&quot;(item, index) in temFiles&quot; :key=&quot;index&quot;&gt;\t\t\t\t&lt;image :src=&quot;item&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;\t\t\t\t&lt;view class=&quot;close&quot; @click=&quot;onClose(index)&quot;&gt;×&lt;/view&gt;\t\t\t&lt;/view&gt;\t\t\t&lt;view class=&quot;box add&quot; @click=&quot;addFile&quot; v-show=&quot;temFiles.length&lt;maxSize&quot;&gt;+&lt;/view&gt;\t\t&lt;/view&gt;\t&lt;/view&gt;&lt;/template&gt;&lt;script&gt;\texport default &#123;\t\tdata() &#123;\t\t\treturn &#123;\t\t\t\ttemFiles: [],\t\t\t\tmaxSize: 9\t\t\t&#125;\t\t&#125;,\t\tonLoad() &#123;&#125;,\t\tmethods: &#123;\t\t\taddFile() &#123;\t\t\t\tuni.chooseImage(&#123;\t\t\t\t\tsuccess: res =&gt; &#123;\t\t\t\t\t\tthis.temFiles = [...this.temFiles, ...res.tempFilePaths].slice(0, this.maxSize);\t\t\t\t\t&#125;\t\t\t\t&#125;)\t\t\t&#125;,\t\t\tonClose(e) &#123;\t\t\t\tthis.temFiles.splice(e, 1);\t\t\t&#125;\t\t&#125;,\t&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;\t.uploadGroup &#123;\t\tpadding: 30rpx;\t\tdisplay: flex;\t\tflex-wrap: wrap;\t\t.box &#123;\t\t\tmargin-left: 15rpx;\t\t\tmargin-bottom: 15rpx;\t\t\twidth: 200rpx;\t\t\theight: 200rpx;\t\t\tbackground: #eee;\t\t\tposition: relative;\t\t\timage &#123;\t\t\t\twidth: 100%;\t\t\t\theight: 100%;\t\t\t&#125;\t\t\t.close &#123;\t\t\t\tposition: absolute;\t\t\t\tright: 0;\t\t\t\ttop: 0;\t\t\t\twidth: 50rpx;\t\t\t\theight: 50rpx;\t\t\t\tbackground: rgba(0, 0, 0, 0.7);\t\t\t\tcolor: #fff;\t\t\t\tborder-radius: 0 0 0 80rpx;\t\t\t\tdisplay: flex;\t\t\t\talign-items: center;\t\t\t\tjustify-content: center;\t\t\t&#125;\t\t&#125;\t\t.add &#123;\t\t\tfont-size: 80rpx;\t\t\tdisplay: flex;\t\t\talign-items: center;\t\t\tjustify-content: center;\t\t\tcolor: #999;\t\t&#125;\t&#125;&lt;/style&gt;\n\n下面是效果图：\n\n页面间传值例如我们从A页&#x3D;&gt;B页：\n在A页中的跳转时，将参数拼接上：\nclickItem(id) &#123;    uni.navigateTo(&#123;        url: &quot;/pages/B/B?id=&quot; + id,    &#125;)&#125;\n\n此时点击跳转的链接就变为了(http://localhost:5173/#/pages/B/B?id=1)\n当我们在B页面要接收时，直接使用onLOad去接收\nonLoad(id) &#123;    console.log(id);&#125;,\n\n此时，A页面就将id转给了B页面。\n各种事件下拉刷新当用户下拉刷新时触发，示例：\nonPullDownRefresh() &#123;\tthis.listArr = [];\tthis.getData();&#125;,\n\n下拉刷新时，重新获取数据，但是刷新的动画不会消失，所以可以在数据完后后使用uni.stopPullDownRefresh()结束刷新的动画。\n触底事件当用户滑倒到页面底部时触发，示例：\n// 触底onReachBottom() &#123;\tthis.getData();&#125;,methods: &#123;    getData() &#123;        uniCloud.callFunction(&#123;            name: &quot;art_get_all&quot;,            data: &#123;                skip: this.listArr.length            &#125;        &#125;).then(res =&gt; &#123;            let oldList = this.listArr;            this.listArr = [...oldList, ...res.result.data]            uni.stopPullDownRefresh()        &#125;)    &#125;,&#125;,\n\n此处在下拉时，请求数据，并且根据已经加载的数据，获取新的数据，所以采用：this.listArr.length，去分页查询新的数据，下面是与函数的查询：\nconst db = uniCloud.database();exports.main = async (event, context) =&gt; &#123;\tlet &#123;\t\tskip = 0\t&#125; = event;\treturn await db.collection(&quot;article&quot;).limit(8).skip(skip).orderBy(&quot;time&quot;, &quot;desc&quot;).get(); // 每次传递8条，时间倒序&#125;;\n\n\n\nUni-App-TS创建项目使用命令行创建uni-app-vue3-ts版：\nnpx degit dcloudio/uni-preset-vue#vite-ts 项目名\n\n进入项目后，进行安装依赖：npm i，启动可按package.json文件中的scripts启动命令\n用VS Code开发安装uni-app 插件\nuni-create-view ：快速创建 uni-app 页面\nuni-helper ：uni-app 代码提示\nuniapp 小程序扩展 ：鼠标悬停查文档\n\nTS类型校验pnpm i -D miniprogram-api-typings @uni-helper/uni-app-types\n\n配置tsconfig.json，可参考：\n// tsconfig.json&#123;  &quot;extends&quot;: &quot;@vue/tsconfig/tsconfig.json&quot;,  &quot;compilerOptions&quot;: &#123;    &quot;sourceMap&quot;: true,    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [&quot;./src/*&quot;]    &#125;,    &quot;lib&quot;: [&quot;esnext&quot;, &quot;dom&quot;],    // 类型声明文件    &quot;types&quot;: [      &quot;@dcloudio/types&quot;, // uni-app API 类型      &quot;miniprogram-api-typings&quot;, // 原生微信小程序类型      &quot;@uni-helper/uni-app-types&quot; // uni-app 组件类型    ]  &#125;,  // vue 编译器类型，校验标签类型  &quot;vueCompilerOptions&quot;: &#123;    // 原配置 `experimentalRuntimeMode` 现调整为 `nativeTags`    &quot;nativeTags&quot;: [&quot;block&quot;, &quot;component&quot;, &quot;template&quot;, &quot;slot&quot;],   &#125;,  &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;]&#125;\n\nJSON 注释问题在VScode中，严格要求json格式，在json中会爆红，只需要我们设置文件关联，把 manifest.json 和 pages.json 设置为 jsonc\n设置 &#x3D;》搜索文件关联 &#x3D;》Files: Associations &#x3D;》添加项\n\n安装uni-ui组件库采用npm方式进行安装，在 vue-cli 项目中可以使用 npm 安装 uni-ui 库\nnpm i @dcloudio/uni-ui\n\n配置easycom\n使用 npm 安装好 uni-ui 之后，需要配置 easycom 规则，让 npm 安装的组件支持 easycom\n打开项目根目录下的 pages.json 并添加 easycom 节点：\n// pages.json&#123;\t&quot;easycom&quot;: &#123;\t\t&quot;autoscan&quot;: true,\t\t&quot;custom&quot;: &#123;\t\t\t// uni-ui 规则如下配置\t\t\t&quot;^uni-(.*)&quot;: &quot;@dcloudio/uni-ui/lib/uni-$1/uni-$1.vue&quot;\t\t&#125;\t&#125;,\t\t// 其他内容\tpages:[\t\t// ...\t]&#125;\n\n当我们使用ts时，需要对uni-ui声明组件类型，安装@uni-helper/uni-ui-types\nnpm i -D @uni-helper/uni-ui-types\n\n并且在项目根目录的tsconfig.json添加类型, compilerOptions -&gt; types：\n&quot;types&quot;: [    &quot;@dcloudio/types&quot;,    &quot;miniprogram-api-typings&quot;,    &quot;@uni-helper/uni-app-types&quot;,    &quot;@uni-helper/uni-ui-types&quot;]\n\n\n\n微信小程序登录微信小程序扫码登录流程-官方时序图\n\n流程为：\n\n前端调用wx.login()获取code值，发给后端\n后端将code,appId，appSecret作为参数调用微信接口 code2Session\n后端通过调用微信接口返回的openId，session_key(用于解析用户信息)\n后端根据微信接口返回的openId查询是否存在用户信息\n存在则返回用户信息+token，不存在则注册用户返回openId用于前端请求用户保存用户信息\n\n第一步：引入依赖：\n&lt;!-- 微信小程序 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt;    &lt;artifactId&gt;weixin-java-miniapp&lt;/artifactId&gt;    &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n在application.yml文件中，配置：\nwx:  miniapp:    appId: xxxxxxxxxxxxxxxxxx    secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx    msgDataFormat: JSON\n\n创建配置文件类WxConfigProperties.java，读取配置内容：\n@Component@Data@ConfigurationProperties(prefix = &quot;wx.miniapp&quot;)public class WxConfigProperties &#123;\tprivate String appId;\tprivate String secret;&#125;\n\n创建微信工具包对象WxConfigOperator.java\n@Componentpublic class WxConfigOperator &#123;\t\t@Resource\tprivate WxConfigProperties wxConfigProperties;\t\t@Bean\tpublic WxMaService wxMaService() &#123;\t\t// 小程序 id和密钥\t\tWxMaDefaultConfigImpl wxMaConfig = new WxMaDefaultConfigImpl();\t\twxMaConfig.setAppid(wxConfigProperties.getAppId());\t\twxMaConfig.setSecret(wxConfigProperties.getSecret());\t\t\t\tWxMaService service = new WxMaServiceImpl();\t\tservice.setWxMaConfig(wxMaConfig);\t\treturn service;\t&#125;&#125;\n\n\n\n通过wx.login（微信前端–小程序）接口获取code，将code传到后端，后端调用https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code\n","categories":["高级语言"],"tags":["Vue"]},{"title":"ffmpeg工具","url":"/2023/09/20/ffmpeg%E5%B7%A5%E5%85%B7/","content":"安装 ffmpegffmpeg 的官方网站是：FFmpeg\nLinux 版\nsudo add-apt-repository universesudo apt updatesudo apt install ffmpeg\n\nwindows 版\nWindows 可用版本的下载地址：Download FFmpeg\n下载后，将 ffmpeg 目录中的bin添加到环境变量中去，比如我的为：D:\\Program Files\\ffmpeg\\bin\n\n尝试一下有没有正确安装：\nffmpeg\n\n\nffmpeg 命令基本形式：ffmpeg [全局参数] &#123;[输入文件参数] -i 输入文件地址&#125; ... &#123;[输出文件参数] 输出文件地址&#125; ...\n\n所有没有使用 -i 指定的文件都被认为是输出文件。 FFmpeg 可以接受多个输入文件并输出到您指定的位置。你也可以将输入输出都指定为同一个文件名，不过这个时候要在输出文件前使用用 -y 标记。\n1. 获得媒体文件的信息ffmpeg 最简单的使用就是用来 显示文件信息 。不用给输出，只是简单的写：\nffmpeg -i file_name\n\n视频和音频文件都可以使用：\nffmpeg -i video_file.mp4ffmpeg -i audio_file.mp3\n\n\n命令会输出很多与您文件无关的信息（ffmpeg 本身的信息），虽说这个蛮有用的，你可以使用 -hide_banner 来隐藏掉它们:\nffmpeg -i video_file.mp4 -hide_bannerffmpeg -i audio_file.mp3 -hide_banner\n\n\n2. 转换媒体文件ffmpeg 最让人称道常用的恐怕就是你轻而易举的在不同媒体格式之间进行自由转换了。你是要指明输入和输出文件名就行了， ffmpeg 会从后缀名猜测格式，这个方法同时适用于视频和音频文件\n下面是一些例子:\nffmpeg -i video_input.mp4 video_output.aviffmpeg -i video_input.webm video_output.flvffmpeg -i audio_input.mp3 audio_output.oggffmpeg -i audio_input.wav audio_output.flac\n\n你也可以同时指定多个输出后缀：\nffmpeg -i audio_input.wav audio_output_1.mp3 audio_output_2.ogg\n\n这样会同时输出多个文件.\n想看支持的格式，可以用：\nffmpeg -formats\n\n同样的，你可以使用 -hide_banner 来省略一些程序信息。\n你可以在输出文件前使用 -qscale 0 来保留原始的视频质量：\nffmpeg -i video_input.wav -qscale 0 video_output.mp4\n\n进一步，你可以指定编码器，使用 -c:a (音频) 和 g-c:v (视频) 来指定编码器名称，或者写 copy 来使用与源文件相同的编码器：\nffmpeg -i video_input.mp4 -c:v copy -c:a libvorbis video_output.avi\n\nNote: 这样做会让文件后缀使人困惑，所以请避免这么做。\n3. 从视频中抽取音频为了从视频文件中抽取音频，直接加一个 -vn 参数就可以了：\nffmpeg -i video.mp4 -vn audio.mp3\n\n这会让命令复用原有文件的比特率，一般来说，使用 -ab (音频比特率)来指定编码比特率是比较好的：\nffmpeg -i video.mp4 -vn -ab 128k audio.mp3\n\n一些常见的比特率有 96k, 128k, 192k, 256k, 320k (mp3 也可以使用最高的比特率)。\n其他的一些常用的参数比如 -ar (采样率: 22050, 441000, 48000), -ac (声道数), -f (音频格式, 通常会自动识别的). -ab 也可以使用 -b:a 来替代. 比如：\nffmpeg -i video.mov -vn -ar 44100 -ac 2 -b:a 128k -f mp3 audio.mp3\n\n4. 让视频静音和之前的要求类似，我们可以使用 -an 来获得纯视频(之前是 -vn).\nffmpeg -i video_input.mp4 -an -video_output.mp4\n\nNote: 这个 -an 标记会让所有的音频参数无效，因为最后没有音频会产生。\n5. 从视频中提取图片这个功能可能对很多人都挺有用，比如你可能有一些幻灯片，你想从里面提取所有的图片，那么下面这个命令就能帮你：\nffmpeg -i video.mp4 -r 1 -f image2 image-%3d.png\n\n我们来解释一下这个命令：\n-r 代表了帧率（一秒内导出多少张图像，默认 25）， -f 代表了输出格式(image2 实际上上 image2 序列的意思）。\n最后一个参数 (输出文件) 有一个有趣的命名：它使用 %3d 来指示输出的图片有三位数字 (000, 001, 等等.)。你也可以用 %2d (两位数字) 或者 %4d (4 位数字) ，只要你愿意，你可以随便实验 一下可以怎么写！\nNote: 同样也有将图片转变为视频&#x2F;幻灯片的方式，下面的高级应用中会讲到。\n6. 更改视频分辨率或长宽比对 ffmpeg 来说又是个简单的任务，你只需要使用 -s 参数来缩放视频就行了:\nffmpeg -i video_input.mov -s 1024x576 video_output.mp4\n\n同时，你可能需要使用 -c:a 来保证音频编码是正确的:\nffmpeg -i video_input.h264 -s 640x480 -c:a video_output.mov\n\n你也可是使用**-aspect** 来更改长宽比:\nffmpeg -i video_input.mp4 -aspect 4:3 video_output.mp4\n\nNote: 在高级应用中还会提到更强大的方法\n7. 为音频增加封面图片有个很棒的方法把音频变成视频，全程使用一张图片（比如专辑封面）。当你想往某个网站上传音频，但那个网站又仅接受视频（比如 YouTube, Facebook 等）的情况下会非常有用。\n下面是例子：\nffmpeg -loop 1 -i image.jpg -i audio.wav -c:v libx264 -c:a aac -strict experimental -b:a 192k -shortest output.mp4\n\n只要改一下编码设置 (-c:v 是 视频编码， -c:a 是音频编码) 和文件的名称就能用了。\nNote: *如果你使用一个较新的 ffmpeg 版本（4.x），你就可以不指定 -strict experimental*\n8. 为视频增加字幕另一个常见又很容易实现的要求是给视频增加字母，比如一部外文电源，使用下面的命令：\nffmpeg -i video.mp4 -i subtitles.srt -c:v copy -c:a copy -preset veryfast -c:s mov_text -map 0 -map 1 output.mp4\n\n当然，你可以指定自己的编码器和任何其他的音频视频参数。你可以阅读这篇文章来了解字幕相关内容 editing subtitles in Linux 。\n\n压缩媒体文件\n\n压缩文件可以极大减少文件的体积，节约存储空间，这对于文件传输尤为重要。通过 ffmepg，有好几个方法来压缩文件体积。\nNote: 文件压缩的太厉害会让文件质量显著降低。\n首先，对于音频文件，可以通过降低比特率(使用 -b:a 或 -ab):\nffmpeg -i audio_input.mp3 -ab 128k audio_output.mp3ffmpeg -i audio_input.mp3 -b:a 192k audio_output.mp3\n\n再次重申，一些常用的比特率有: 96k, 112k, 128k, 160k, 192k, 256k, 320k.值越大，文件所需要的体积就越大。\n对于视频文件，选项就多了，一个简单的方法是通过降低视频比特率 (通过 -b:v):\nffmpeg -i video_input.mp4 -b:v 1000k -bufsize 1000k video_output.mp4\n\nNote: 视频的比特率和音频是不同的（一般要大得多）。\n你也可以使用 -crf 参数 (恒定质量因子). 较小的crf 意味着较大的码率。同时使用 libx264 编码器也有助于减小文件体积。这里有个例子，压缩的不错，质量也不会显著变化：\nffmpeg -i video_input.mp4 -c:v libx264 -crf 28 video_output.mp4\n\ncrf 设置为 20 到 30 是最常见的，不过您也可以尝试一些其他的值。\n降低帧率在有些情况下也能有效（不过这往往让视频看起来很卡）:\nffmpeg -i video_input.mp4 -r 24 video_output.mp4\n\n-r 指示了帧率 (这里是 24)。\n你还可以通过压缩音频来降低视频文件的体积，比如设置为立体声或者降低比特率：\nffmpeg -i video_input.mp4 -c:v libx264 -ac 2 -c:a aac -strict -2 -b:a 128k -crf 28 video_output.mp4\n\nNote: *-strict -2 和 -ac 2 是来处理立体声部分的。*\n\n裁剪媒体文件（基础）\n\n想要从开头开始剪辑一部分，使用 T -t 参数来指定一个时间:\nffmpeg -i input_video.mp4 -t 5 output_video.mp4ffmpeg -i input_audio.wav -t 00:00:05 output_audio.wav\n\n这个参数对音频和视频都适用，上面两个命令做了类似的事情：保存一段 5s 的输出文件（文件开头开始算）。上面使用了两种不同的表示时间的方式，一个单纯的数字（描述）或者 HH:MM:SS (小时, 分钟, 秒). 第二种方式实际上指示了结束时间。\n也可以通过 -ss 给出一个开始时间，**-to** 给出结束时间：\nffmpeg -i input_audio.mp3 -ss 00:01:14 output_audio.mp3ffmpeg -i input_audio.wav -ss 00:00:30 -t 10 output_audio.wavffmpeg -i input_video.h264 -ss 00:01:30 -to 00:01:40 output_video.h264ffmpeg -i input_audio.ogg -ss 5 output_audio.ogg\n\n可以看到 开始时间 (-ss HH:MM:SS), 持续秒数 (-t duration), 结束时间 (-to HH:MM:SS), 和开始秒数 (-s duration)的用法.\n你可以在媒体文件的任何部分使用这些命令。\n实战MP4&lt;&#x3D;&gt;Gif\n简单用法：\n\nffmpeg -i 输入路径/input.mp4 输出路径/output.gif\n\n按视频实际尺寸进行转换，帧率也会比较高，反正生成的 gif 文件比较大\n\n设置参数\n\nffmpeg -ss 1 -t 4 -i gif2.mp4 -s 720x360 -r 8 ./22.gif\n\n-ss 1 -t 4 表示从从视频的第 1 秒开始转换，4 秒后停止。\n-s 用于设定分辨率，\n-r 用于设定帧数，一般设置 10 帧左右就行。\n\n例如本指令表示为：从从视频的第 1 秒开始转换，4 秒后停止，转换为 720x360px,8 帧，名为 22.gif，输出到当前终端运行目录下。\n\n\n将 gif 转换成 MP4\n\nffmpeg -f gif -i name.gif output.mp4\n\n\nmp4 生成 Gif\n\nffmpeg -i name.mp4 name.gif不清晰，改用以下命令ffmpeg -i name.mp4 -vf palettegen palette.pngffmpeg -i name.mp4 -i palette.png -lavfi paletteuse name.gif-s 表示分辨率改为多少-r 多少fps-vf 表示生产画板palettegen-lavfi 表示使用画板paletteuse\n","categories":["工具"],"tags":["ffmpeg"]},{"title":"运维平台","url":"/2024/06/05/Zabbix%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0/","content":"1Panel 面板应用商店第三方库官方库的应用比较少，我们可以添加第三方库，在面板的计划任务新增一条Shell脚本，任务名称随意，执行周期建议每天，脚本内容如下：\n#!/bin/bash# 直接执行或复制此脚本到 1Panel-&gt;计划任务中定时执行即可# 1panel本地app的目录（如果不是默认安装，需修改该目录）app_local_dir=&quot;/opt/1panel/resource/apps/local&quot;# AppStore的git仓库地址（必选）git_repo_url=&quot;https://mirror.ghproxy.com/https://github.com//okxlin/appstore&quot;#git_repo_url=&quot;https://gitee.com/svip520/1panel-appstore&quot;# 访问git仓库的access token，访问私有仓库时用，优先级高于账密（可选）# 建议使用access token，降低账密泄露的风险git_access_token=&quot;&quot;# 访问git仓库的用户名，访问私有仓库时用（可选）git_username=&quot;&quot;# 访问git仓库的密码，访问私有仓库时用（可选）git_password=&quot;&quot;# 指定克隆的分支（可选）git_branch=&quot;&quot;# 指定克隆的深度（可选）git_depth=1# 拉取远程仓库前是否清空本地app目录（可选）clean_local_app=true# 拉取远程仓库前是否清空远程app缓存（可选）clean_remote_app_cache=false# 设置克隆或拉取远程仓库时使用的代理（可选）proxyUrl=&quot;&quot;# 设置示例：# proxyUrl=&quot;http://127.0.0.1:7890&quot;# proxyUrl=&quot;socks5://127.0.0.1:7890&quot;# proxyUrl=&quot;socks5://user:password@host:port&quot;# 将远程app store工程克隆到本地的工作目录work_dir=&quot;/opt/1panel_hepler&quot;set -emkdir -p &quot;$work_dir/logs&quot;log_file=&quot;$work_dir/logs/local_appstore_sync_helper_$(date +&quot;%Y-%m-%d&quot;).log&quot;logs() &#123;  local message=&quot;$1&quot;  if [ -n &quot;$log_file&quot; ]; then    mkdir -p &quot;$(dirname &quot;$log_file&quot;)&quot;    if [ $? -eq 0 ]; then      echo -e &quot;[$(date +&quot;%Y-%m-%d %H:%M:%S&quot;)] $message&quot;      echo &quot;[$(date +&quot;%Y-%m-%d %H:%M:%S&quot;)] $message&quot; &gt;&gt;&quot;$log_file&quot;      return    fi  fi  echo -e &quot;$message&quot;&#125;# 函数: url_encode# 参数:#   - url: 需要进行编码的字符串# 返回值:#   经过URL编码后的字符串function url_encode() &#123;  local string=$1  local length=&quot;$&#123;#string&#125;&quot;  local url_encoded_string=&quot;&quot;  local c  for ((i = 0; i &lt; length; i++)); do    c=$&#123;string:i:1&#125;    case &quot;$c&quot; in    [a-zA-Z0-9.~_-]) url_encoded_string+=$c ;;    *) url_encoded_string+=$(printf &#x27;%%%02X&#x27; &quot;&#x27;$c&quot;) ;;    esac  done  echo &quot;$url_encoded_string&quot;&#125;# 定义函数，接收一个URL参数和可选的替换字符串参数replace_protocol() &#123;  local url=$1  local replacement=$2  # 如果没有提供替换字符串，则删除&quot;http://&quot;或&quot;https://&quot;  if [[ -z $replacement ]]; then    local new_url=$(echo $url | sed &quot;s/http:\\/\\///&quot; | sed &quot;s/https:\\/\\///&quot;)  else    local new_url=$(echo $url | sed &quot;s/http:\\/\\//$&#123;replacement&#125;/&quot; | sed &quot;s/https:\\/\\//$&#123;replacement&#125;/&quot;)  fi  # 输出替换后的URL  echo $new_url&#125;# 函数: clone_git_repo# 参数:#   - url: Git仓库URL#   - username: 账号（可选）#   - password: 密码（可选）#   - access_token: 访问令牌（可选）#   - branch: 克隆分支（可选）#   - depth: 克隆深度（可选，默认为0，即克隆整个仓库）function clone_git_repo() &#123;  local url=$1  local username=$2  local password=$3  local access_token=$4  local branch=$5  local depth=$6  branch=$&#123;branch:+--branch $branch&#125;  depth=$&#123;depth:+--depth $depth&#125;  echo &quot;branch: $branch, depth: $depth&quot;  if [[ -n $access_token ]]; then    echo &quot;use access_token to clone&quot;    local fix_url=$(replace_protocol &quot;$url&quot;)    git clone &quot;https://oauth2:$access_token@$fix_url&quot; $branch $depth  elif [[ -n $username &amp;&amp; -n $password ]]; then    local encoded_username=$(url_encode &quot;$username&quot;)    local encoded_password=$(url_encode &quot;$password&quot;)    local fix_url=$(replace_protocol &quot;$url&quot;)    # echo &quot;use username and password to clone, encoded_username: $encoded_username, encoded_password: $encoded_password, fix_url: $fix_url&quot;    echo &quot;use username and password to clone&quot;    git clone &quot;https://$encoded_username:$encoded_password@$fix_url&quot; $branch $depth  else    echo &quot;use default clone&quot;    git clone &quot;$url&quot; $branch $depth  fi&#125;# 取消代理function proxy_off() &#123;  unset http_proxy  unset https_proxy  unset ALL_PROXY  unset no_proxy  logs &quot;Proxy Off&quot;&#125;# 开启代理function proxy_on() &#123;  proxy_url=&quot;http://127.0.0.1:7890&quot;  match_str=&quot;://&quot;  if [ -n &quot;$1&quot; ]; then    if [[ $1 =~ $match_str ]]; then      proxy_url=$1    else      logs &quot;Incorrect proxy_url, use defualt proxy_url&quot;      return    fi  fi  export http_proxy=$proxy_url  export https_proxy=$proxy_url  export ALL_PROXY=$proxy_url  export no_proxy=&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot;  logs &quot;Proxy On $proxy_url&quot;&#125;function scriptInfo() &#123;  echo &quot;&quot;  logs &quot;##################################################################&quot;  logs &quot;#  Name: local appstore sync helper for 1Panel                 #&quot;  logs &quot;#  Author: nameless                                              #&quot;  logs &quot;##################################################################&quot;  echo &quot;&quot;&#125;function main() &#123;  scriptInfo  if [ ! -d &quot;$app_local_dir&quot; ]; then    logs &quot;未检测到1panel的app目录，请检查1panel是否安装正确，或修改脚本中的app_local_dir变量&quot;    exit 1  fi  # 检查地址结尾是否包含.git，如果不包含则自动补全  if [[ &quot;$git_repo_url&quot; != *&quot;.git&quot; ]]; then    git_repo_url=&quot;$&#123;git_repo_url&#125;.git&quot;  fi  local repo_username=&quot;&quot;  local repo_projectname=&quot;&quot;  # 使用正则表达式匹配仓库地址中的用户名和项目名  if [[ $git_repo_url =~ .*\\/(.*)\\/(.*)\\.git ]]; then    repo_username=$&#123;BASH_REMATCH[1]&#125;    repo_projectname=$&#123;BASH_REMATCH[2]&#125;    # logs &quot;用户名: $repo_username&quot;    # logs &quot;项目名: $repo_projectname&quot;  fi  if [ -z &quot;$repo_username&quot; ] || [ -z &quot;$repo_projectname&quot; ]; then    logs &quot;无法提取用户名和项目名，请检查git_repo_url变量提供的地址是否正确&quot;    exit 1  fi  mkdir -p &quot;$work_dir/temp&quot;  local repo_user_dir=&quot;$work_dir/temp/$repo_username&quot;  local repo_dir=&quot;$repo_user_dir/$repo_projectname&quot;  # 根据clean_remote_app_cache变量的值决定是否清空远程app的缓存数据  if [ &quot;$clean_remote_app_cache&quot; = true ] &amp;&amp; [ -d &quot;$repo_dir&quot; ]; then    rm -rf &quot;$repo_dir&quot;    logs &quot;已清空远程app的缓存数据&quot;  fi  # 根据proxyUrl变量的值决定是否开启代理  if [ -n &quot;$proxyUrl&quot; ]; then    proxy_on &quot;$proxyUrl&quot;  fi  # clone或拉取远程仓库最新代码  logs &quot;准备获取远程仓库最新代码：$git_repo_url&quot;  if [ -d &quot;$repo_dir&quot; ]; then    logs &quot;执行git pull操作&quot;    cd &quot;$repo_dir&quot;    # 强行拉取最新代码    git pull --force 2&gt;&gt;&quot;$log_file&quot;  else    logs &quot;执行git clone操作&quot;    mkdir -p &quot;$repo_user_dir&quot;    cd &quot;$repo_user_dir&quot;    clone_git_repo &quot;$git_repo_url&quot; &quot;$git_username&quot; &quot;$git_password&quot; &quot;$git_access_token&quot; &quot;$git_branch&quot; &quot;$git_depth&quot; 2&gt;&gt;&quot;$log_file&quot;  fi  logs &quot;远程仓库最新代码获取完成&quot;  if [ ! -d &quot;$repo_dir/apps&quot; ]; then    logs &quot;未检测到apps目录，请检查远程仓库是否正确&quot;    exit 1  fi  # 根据clean_local_app变量的值决定是否清空本地app目录  if [ &quot;$clean_local_app&quot; = true ]; then    rm -rf &quot;$app_local_dir&quot;/*    logs &quot;已清空本地原有的app&quot;  fi  # 将远程仓库的apps目录下的所有app复制到本地app_local_dir目录下  cd &quot;$repo_dir&quot;  cp -rf apps/* &quot;$app_local_dir&quot;  pwd  ls -lah  du -sh  # 根据clean_remote_app_cache变量的值决定是否清空远程app的缓存数据  if [ &quot;$clean_remote_app_cache&quot; = true ]; then    rm -rf &quot;$repo_dir&quot;  fi  if [ -n &quot;$proxyUrl&quot; ]; then    proxy_off  fi  logs &quot;1panel本地app同步成功，enjoy it!&quot;&#125;main &quot;$@&quot;\n\n创建好后，点击执行，可在报告中查看详情：\n\ndocker 源最近中国大陆无法连接到docker，在面板的容器-配置中，镜像加速使用下面连接：\nhttps://docker.1panel.live/\n\nZabbix 部署1.集群规划\n\n\n进程\nhadoop102 节点\nhadoop103 节点\nhadoop104 节点\n\n\n\nzabbix-agent\n√\n√\n√\n\n\nzabbix-server\n√\n\n\n\n\nMySQL\n√\n\n\n\n\nzabbix-web\n√\n\n\n\n\n2.准备工作2.1 关闭集群如果集群开启，先关闭集群。因为安装Zabbix前，需要重启虚拟机。\n2.2 关闭 3 台节点防火墙分别在hadoop102、103、104上执行：\nsudo systemctl stop firewalld.servicesudo systemctl disable firewalld.service\n\n2.3 关闭 3 台节点上的 SELinux(1) 修改配置文件/etc/selinux/config\nsudo vim /etc/selinux/config\n\n修改为一下内容：\n# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:#     enforcing - SELinux security policy is enforced.#     permissive - SELinux prints warnings instead of enforcing.#     disabled - No SELinux policy is loaded.SELINUX=disabled# SELINUXTYPE= can take one of three values:#     targeted - Targeted processes are protected,#     minimum - Modification of targeted policy. Only selected processes are protected.#     mls - Multi Level Security protection.SELINUXTYPE=targeted\n\n(2) 重启服务器\nsudo reboot\n\n3.配置 3 台节点的 Zabbix yum 源3.1 安装 yum 仓库(1) 安装 zabbix 的软件仓库配置包\n这个包包含了 yum（软件包管理器）的配置文件\n[wwj@hadoop102 ~]$ sudo rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm[wwj@hadoop103 ~]$ sudo rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm[wwj@hadoop104 ~]$ sudo rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm\n\n(2) 安装 Software Collectiopns 仓库\n[wwj@hadoop102 ~]$ sudo yum install -y centos-release-scl[wwj@hadoop103 ~]$ sudo yum install -y centos-release-scl[wwj@hadoop104 ~]$ sudo yum install -y centos-release-scl\n\n3.2 修改 zabbix 仓库配置文件hadoop102、hadoop103、hadoop104三台节点，依次执行如下步骤：\n(1) 查看原始 zabbix.repo 文件\n[wwj@hadoop102 ~]$ sudo cat /etc/yum.repos.d/zabbix.repo\n\n查看内容如下：\n[zabbix]name=Zabbix Official Repository - $basearchbaseurl=http://repo.zabbix.com/zabbix/5.0/rhel/7/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591[zabbix-frontend]name=Zabbix Official Repository frontend - $basearchbaseurl=http://repo.zabbix.com/zabbix/5.0/rhel/7/$basearch/frontendenabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591[zabbix-debuginfo]name=Zabbix Official Repository debuginfo - $basearchbaseurl=http://repo.zabbix.com/zabbix/5.0/rhel/7/$basearch/debuginfo/enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591gpgcheck=1[zabbix-non-supported]name=Zabbix Official Repository non-supported - $basearchbaseurl=http://repo.zabbix.com/non-supported/rhel/7/$basearch/enabled=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIXgpgcheck=1\n\n(2) 执行以下命令完成全局替换，修改为阿里云镜像\n[wwj@hadoop102 ~]$ sudo sed -i &#x27;s/http:\\/\\/repo.zabbix.com/https:\\/\\/mirrors.aliyun.com\\/zabbix/g&#x27; /etc/yum.repos.d/zabbix.repo\n\n(3) 查看修改后的 zabbix.repo 文件\n[wwj@hadoop102 ~]$ sudo cat /etc/yum.repos.d/zabbix.repo\n\n查看内容如下\n[zabbix]name=Zabbix Official Repository - $basearchbaseurl=https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/$basearch/enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591[zabbix-frontend]name=Zabbix Official Repository frontend - $basearchbaseurl=https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/$basearch/frontendenabled=0gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591[zabbix-debuginfo]name=Zabbix Official Repository debuginfo - $basearchbaseurl=https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/$basearch/debuginfo/enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591gpgcheck=1[zabbix-non-supported]name=Zabbix Official Repository non-supported - $basearchbaseurl=https://mirrors.aliyun.com/zabbix/non-supported/rhel/7/$basearch/enabled=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIXgpgcheck=1\n\n(4) 打开/etc/yum.repos.d/zabbix.repo文件，启用 zabbix-web 仓库\n将文件中zabbix-frontend的enabled&#x3D;0改为enabled&#x3D;1\n[zabbix-frontend]name=Zabbix Official Repository frontend - $basearchbaseurl=https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/$basearch/frontendenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-ZABBIX-A14FE591\n\n4.安装 Zabbix在 hadoop102、hadoop103、hadoop104 三台节点分别执行以下安装命令：\n[wwj@hadoop102 ~]$ sudo yum install -y zabbix-server-mysql zabbix-agent zabbix-web-mysql-scl zabbix-apache-conf-scl[wwj@hadoop103 ~]$ sudo yum install -y zabbix-agent[wwj@hadoop104 ~]$ sudo yum install -y zabbix-agent\n\n5.配置 Zabbix5.1 创建 Zabbix 数据库[wwj@hadoop102 ~]$ mysql -uroot -p123456 -e&quot;create database zabbix character set utf8 collate utf8_bin&quot;\n\n5.2 导入 Zabbix 建表语句[wwj@hadoop102 ~]$ zcat /usr/share/doc/zabbix-server-mysql-5.0.42/create.sql.gz | mysql -uroot -p123456 zabbix\n\n5.3 配置 Zabbix_Server（hadoop102）修改 zabbix-server 配置文件\n[wwj@hadoop102 ~]$ sudo vim /etc/zabbix/zabbix_server.confDBHost=hadoop102DBName=zabbixDBUser=rootDBPassword=123456\n\n5.4 配置 Zabbix_Agent（三台节点）修改zabbix-agent配置文件\n[wwj@hadoop102 ~]$ sudo vim /etc/zabbix/zabbix_agentd.conf[wwj@hadoop103 ~]$ sudo vim /etc/zabbix/zabbix_agentd.conf[wwj@hadoop104 ~]$ sudo vim /etc/zabbix/zabbix_agentd.conf\n\n修改以下内容：\nServer=hadoop102#ServerActive=127.0.0.1#Hostname=Zabbix server\n\n5.5 配置 Zabbix_Web 时区修改/etc/opt/rh/rh-php72/php-fpm.d/zabbix.conf文件\n[wwj@hadoop102 ~]$ sudo vim /etc/opt/rh/rh-php72/php-fpm.d/zabbix.conf\n\n修改如下内容：（最后一行：php_value[date.timezone] &#x3D; Asia&#x2F;Shanghai）\n[zabbix]user = apachegroup = apachelisten = /var/opt/rh/rh-php72/run/php-fpm/zabbix.socklisten.acl_users = apachelisten.allowed_clients = 127.0.0.1pm = dynamicpm.max_children = 50pm.start_servers = 5pm.min_spare_servers = 5pm.max_spare_servers = 35pm.max_requests = 200php_value[session.save_handler] = filesphp_value[session.save_path]    = /var/opt/rh/rh-php72/lib/php/session/php_value[max_execution_time] = 300php_value[memory_limit] = 128Mphp_value[post_max_size] = 16Mphp_value[upload_max_filesize] = 2Mphp_value[max_input_time] = 300php_value[max_input_vars] = 10000php_value[date.timezone] = Asia/Shanghai\n\n修改 MySQL8.0 的密码加密规则\nalter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;select user,host,plugin,authentication_string from user;\n\n\n6.启动停止 Zabbix6.1 启动 Zabbizwwj@hadoop102 ~$ sudo systemctl restart zabbix-server zabbix-agent httpd rh-php72-php-fpmwwj@hadoop102 ~$ sudo systemctl enable zabbix-server zabbix-agent httpd rh-php72-php-fpm[wwj@hadoop103 ~]$ sudo systemctl start zabbix-agent[wwj@hadoop103 ~]$ sudo systemctl enable zabbix-agent[wwj@hadoop104 ~]$ sudo systemctl start zabbix-agent[wwj@hadoop104 ~]$ sudo systemctl enable zabbix-agent\n\n6.2 停止 Zabbiz[wwj@hadoop102 ~]$ sudo systemctl stop zabbix-server zabbix-agent httpd rh-php72-php-fpm[wwj@hadoop102 ~]$ sudo systemctl disable zabbix-server zabbix-agent httpd rh-php72-php-fpm[wwj@hadoop103 ~]$ sudo systemctl stop zabbix-agent[wwj@hadoop103 ~]$ sudo systemctl disable zabbix-agent[wwj@hadoop104 ~]$ sudo systemctl stop zabbix-agent[wwj@hadoop104 ~]$ sudo systemctl disable zabbix-agent\n\n6.3 访问 Web 网页打开：http://hadoop102/zabbix/ 即可访问 zabbix-server,点击下一步，对数据库进行配置：\n\n配置 Zabbix server details\n\n完成之后就可以登录 Zabbix 页面了\n6.4 登录 Zabbix(1) 登录账号\n用户名：Admin 密码：zabbix\n(2) 设置界面语言\n\n","categories":["服务器"],"tags":["运维","Linux"]},{"title":"hexo搭建","url":"/2023/09/14/hexo%E6%90%AD%E5%BB%BA/","content":"hexo 搭建博客更改端口：在 /node_modules/hexo-server/index.js 可修改启动端口：port\n下面是 hexo 的项目结构\n.├── _config.yml      // 站点配置文件├── db.json          // 缓存文件├── node_modules     // 安装的插件以及hexo所需的一些nodejs模块├── package.json     // 项目的依赖文件├── scaffolds        // 模版文件├── source           // 源文件，用来存放你的文章 md 文件└── themes           // 主题文件\n\n简约主题：fluid安装路径：hexo-theme-fluid\n文章配置隐藏文章\nhide: true# 文章排序 sticky 数值越大，该文章越靠前sticky: 100# 文章在首页的封面图index_img: /img/example.jpg# 文章页顶部大图banner_img\n\n文章语法Tag 插件标签\n&#123;% note success %&#125;文字 或者 `markdown` 均可&#123;% endnote %&#125;\n\n可选便签：\nprimary\n\n\nsecondary\n\nsecondary\n\n\n\nsuccess\n\n\ndanger\n\n\nwarning\n\n\ninfo\n\n\nlight\n\nlight\n\n\n\n行内标签\n# 在 markdown 中加入如下的代码来使用 Label：&#123;% label primary @text %&#125;# 或者使用 HTML 形式：&lt;span class=&quot;label label-primary&quot;&gt;Label&lt;/span&gt;\n\n可选 Label：\nprimary success info danger warningdefault\n\n\n若使用 &#123;% label primary @text %&#125;，text 不能以 @ 开头\n\n按钮\n&#123;% btn url, text, title %&#125;# url：跳转链接# text：显示的文字# title：鼠标悬停时显示的文字（可选）\n\n按钮\n\n组图\n# 如果想把多张图片按一定布局组合显示，你可以在 markdown 中按如下格式：&#123;% gi total n1-n2-... %&#125;![](url)![](url)![](url)![](url)![](url)&#123;% endgi %&#125;# total：图片总数量，对应中间包含的图片 url 数量 n1-n2-...：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式# 如下图为 &#123;% gi 5 3-2 %&#125; 示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。\n\n\n工作流在根目录创建.github文件夹，在里面新建workflows文件夹，进入后新建autodeploy.yml，路径为：/.github/workflows/autodeploy.yml\n# 当有改动推送到master分支时，启动Actionname: 自动部署on:  push:    branches:      - main #2020年10月后github新建仓库默认分支改为main，注意更改  release:    types:      - publishedjobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: 检查分支        uses: actions/checkout@v2        with:          ref: main #2020年10月后github新建仓库默认分支改为main，注意更改      - name: 安装 Node        uses: actions/setup-node@v1        with:          node-version: &quot;16.x&quot; #action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。      - name: 安装 Hexo        run: |          export TZ=&#x27;Asia/Shanghai&#x27;          npm install hexo-cli -g      - name: 缓存 Hexo        uses: actions/cache@v1        id: cache        with:          path: node_modules          key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;      - name: 安装依赖        if: steps.cache.outputs.cache-hit != &#x27;true&#x27;        run: |          npm install --save      - name: 生成静态文件        run: |          hexo clean          hexo generate      - name: 部署到仓库 #此处master:master 指从本地的master分支提交到远程仓库的master分支，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。        run: |          cd ./public          git init          git config --global user.name &#x27;$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;&#x27;          git config --global user.email &#x27;$&#123;&#123; secrets.GITHUBEMAIL &#125;&#125;&#x27;          git add .          git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot;          git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;.github.io.git&quot; master:main      - name: 部署到阿里云OSS        env:          OSS_AccessKeyID: $&#123;&#123; secrets.ACCESS_KEY_ID &#125;&#125;          OSS_AccessKeySecret: $&#123;&#123; secrets.ACCESS_KEY_SECRET &#125;&#125;          OSS_EndPoint: oss-cn-shanghai.aliyuncs.com          OSS_Bucket: xxxxx        run: |          wget -q http://gosspublic.alicdn.com/ossutil/1.6.10/ossutil64          chmod +x ./ossutil64          ./ossutil64 config -e $OSS_EndPoint -i $OSS_AccessKeyID -k $OSS_AccessKeySecret -L CH          ./ossutil64 rm -r -f oss://$OSS_Bucket/          ./ossutil64 cp -r -f ./public oss://$OSS_Bucket/\n\n可选择上传源码到GitHub仓库，启动工作流，自动部署到另一个仓库为静态网页，或者讲静态网页部署到阿里云 OSS，\n部署需要在仓库中配置密钥：找到要上传的对应的仓库，点击Settings，选择Secrets and variables中的Actions：\n\n下面是我的工作流，上传到 Github，推送到 Gitee 和阿里云 OSS:\n# 当有改动推送到master分支时，启动Actionname: 自动部署on:  push:    branches:      - main #2020年10月后github新建仓库默认分支改为main，注意更改  release:    types:      - publishedjobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: 检查分支        uses: actions/checkout@v2        with:          ref: main #2020年10月后github新建仓库默认分支改为main，注意更改      - name: 安装 Node        uses: actions/setup-node@v1        with:          node-version: &quot;16.x&quot; #action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。      - name: 安装 Hexo        run: |          export TZ=&#x27;Asia/Shanghai&#x27;          npm install hexo-cli -g      - name: 缓存 Hexo        id: cache-npm        uses: actions/cache@v3        env:          cache-name: cache-node-modules        with:          path: node_modules          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;          restore-keys: |            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-            $&#123;&#123; runner.os &#125;&#125;-build-            $&#123;&#123; runner.os &#125;&#125;-      - name: 安装依赖        if: steps.cache.outputs.cache-hit != &#x27;true&#x27;        run: |          npm install --save      - name: 生成静态文件        run: |          hexo clean          hexo generate      - name: 部署到Gitee仓库 #此处master:master 指从本地的master分支提交到远程仓库的master分支，若远程仓库没有对应分支则新建一个。如有其他需要，可以根据自己的需求更改。        run: |          cd ./public          git init          git config --global user.name &#x27;$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;&#x27;          git config --global user.email &#x27;$&#123;&#123; secrets.GITHUBEMAIL &#125;&#125;&#x27;          git add .          git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot;          git push --force --quiet &quot;https://$&#123;&#123; secrets.GITEEUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITEETOKEN &#125;&#125;@gitee.com/$&#123;&#123; secrets.GITEEUSERNAME &#125;&#125;/$&#123;&#123; secrets.GITEEUSERNAME &#125;&#125;.git&quot; master:main #gitee部署写法，需要的自行取消注释      - name: 部署到阿里云OSS        env:          OSS_AccessKeyID: $&#123;&#123; secrets.ACCESS_KEY_ID &#125;&#125;          OSS_AccessKeySecret: $&#123;&#123; secrets.ACCESS_KEY_SECRET &#125;&#125;          OSS_EndPoint: oss-cn-shanghai.aliyuncs.com          OSS_Bucket: phils        run: |          wget -q http://gosspublic.alicdn.com/ossutil/1.6.10/ossutil64          chmod +x ./ossutil64          ./ossutil64 config -e $OSS_EndPoint -i $OSS_AccessKeyID -k $OSS_AccessKeySecret -L CH          ./ossutil64 rm -r -f oss://$OSS_Bucket/          ./ossutil64 cp -r -f ./public oss://$OSS_Bucket/\n\n下面是实现图：\n\n博客嵌入 PPT\n可以通过鼠标和键盘控制\n\n页面: ↑&#x2F;↓&#x2F;←&#x2F;→ Space Home End（空格,home 键,end 键）\n全屏: F\nOverview: -&#x2F;+\n演讲者笔记: N\n网格背景: Enter\n\n\nnodeppt首先可以看看官网给的demo，非常的炫酷。\n\n\n文章加密安装\nnpm install --save hexo-blog-encrypt\n\n在需要加密的文件头加入\n---password: wangweijunabstract: 有东西被加密了, 请输入密码查看.message: 您好, 这里需要密码.wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.---\n","categories":["博客"],"tags":["Hexo","Fluid"]},{"title":"nodejs版本管理器","url":"/2023/10/16/nodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8/","content":"NVM今天介绍的 NodeJs 的版本管理工具——nvm：node 版本管理器，也就是说：一个 nvm 可以管理多个 node 版本（包含 npm 与 npx），可以方便快捷的 安装、切换 不同版本的 node。\nWindows 安装\n进入 GitHub 的nvm-windows，下载：nvm-noinstall.zip\n将 nvm-noinstall.zip 解压在名为nvm的文件夹中。\n添加环境变量，在系统变量中新增NVM_HOME，NVM_SYMLINK:![屏幕截图 2023-10-16 102259](..&#x2F;images&#x2F;屏幕截图 2023-10-16 102259.png)![屏幕截图 2023-10-16 102400](..&#x2F;images&#x2F;屏幕截图 2023-10-16 102400.png)\n在path中，加入这两行\n\n%NVM_HOME%%NVM_SYMLINK%\n\n\n在nvm文件夹中，新建文件settings.txt，将下面模板复制进去，替换成对应的安装目录：\n\nroot: D:\\Environment\\nvmpath: D:\\Environment\\nodejsarch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: http://npm.taobao.org/mirrors/npm/\n\n配置好之后，打开控制台，通过nvm -v查看是否安装成功：\nC:\\Users\\Admin&gt;nvm -v1.1.11\n\n可以使用nvm list，查看存在的 node 版本，我以及安装过了，所有有两个，正常新安装，应该为空：![屏幕截图 2023-10-16 103246](..&#x2F;images&#x2F;屏幕截图 2023-10-16 103246.png)我们演示去安装一个新的版本，通过nvm list available,查看可安装的版本：![屏幕截图 2023-10-16 103509](..&#x2F;images&#x2F;屏幕截图 2023-10-16 103509.png)我们安装一个最新的 20.8.1，使用nvm install 20.8.1:\nC:\\Users\\Admin&gt;nvm install 20.8.1Downloading node.js version 20.8.1 (64-bit)...Extracting node and npm...Completenpm v10.1.0 installed successfully.Installation complete. If you want to use this version, typenvm use 20.8.1\n\n然后使用nvm use 20.8.1，使用 20.8.1，通过node -v，即可查看到当前的版本：\nC:\\Users\\Admin&gt;node -vv20.8.1\n\n如果想要卸载删除某个版本，使用nvm uninstall 版本号\nLinux 安装一键安装curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash# 下面是演示：root@aliyun:/# curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100 15916  100 15916    0     0  50208      0 --:--:-- --:--:-- --:--:-- 50050=&gt; Downloading nvm from git to &#x27;/root/.nvm&#x27;=&gt; Cloning into &#x27;/root/.nvm&#x27;...remote: Enumerating objects: 360, done.remote: Counting objects: 100% (360/360), done.remote: Compressing objects: 100% (306/306), done.remote: Total 360 (delta 41), reused 165 (delta 28), pack-reused 0Receiving objects: 100% (360/360), 220.29 KiB | 3.73 MiB/s, done.Resolving deltas: 100% (41/41), done.* (HEAD detached at FETCH_HEAD)  master=&gt; Compressing and cleaning up git repository=&gt; Appending nvm source string to /root/.bashrc=&gt; Appending bash_completion source string to /root/.bashrc=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion\n\n配置环境将上面的配置内容复制，在命令行粘贴执行：\nexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion# 下面是演示：root@aliyun:/# export NVM_DIR=&quot;$HOME/.nvm&quot;root@aliyun:/# [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvmroot@aliyun:/# [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion\n\n然后执行nvm -v，看到版本号，就说明安装成功了。![屏幕截图 2023-10-16 110936](..&#x2F;images&#x2F;屏幕截图 2023-10-16 110936.png)\n","categories":["工具"],"tags":["nodejs","nvm"]},{"title":"串流教程","url":"/2024/09/15/%E4%B8%B2%E6%B5%81%E6%95%99%E7%A8%8B/","content":"串流教程安装 sunshine 和 moonlight\n第一步：在 Windows 电脑安装 Sunshine\n\n可以访问 Sunshine 官网：LizardByte - Sunshine，进入Releases · LizardByte&#x2F;Sunshine (github.com)下载 nshine-windows-installer.exe，安装之后，在状态栏可以看到 Sunshine，右键打开Open Sunshine，在网页中输入用户名，密码进行注册，注册完成后进行登录，登录成功后进入到后台页面，我们可以设置简体中文：\n\n进入配置页面：\nUPnP：启用、IP 地址族：IPv4+IPv6、局域网加密模式：禁用、公网加密模式：禁用 — 保存，应用，这样我们 Sunshine 就配置好了\nSunshine：作为显示器的串流发射端\n\n第二步：在其他设备安装 Moonlight\n\n在官网可以进行下载：Moonlight Game Streaming，选择不同的版本，进入 Moonlight 后，在设置中可以选择视频分辨率、帧数等设置\n在主页面可以看到自己的电脑，如果没有在添加中，使用 ip 进行添加，点击自己的电脑后，需要输入 PIN 码，在电脑的 Sunshine 中的 PIN 码输入\n","categories":["网络","工具"],"tags":["串流"]},{"title":"stm32单片机","url":"/2025/03/01/stm32%E5%8D%95%E7%89%87%E6%9C%BA/","content":"STM32 入门STM32 概述关于 ARM 内核要了解 STM32，就需要了解ARM，因为 STM32 是基于 ARM 构建的。\nARM首先是一家英国公司，后面卖给日本软银。\n产品：ARM 架构处理器及相关外围组件的电路设计方案。\nARM然后是处理器架构，几乎所有的移动端处理器均采用 ARM 授权方案设计\n而在台式机电脑中常见的两大巨头 AMD、intel 使用的为 x86 架构。\n使用 ARM 架构的芯片：\n\n苹果：A17、M3、M3 pro、M3 max\n高通骁龙系列、联发科天玑系列\nSTM32\n\nARM 处理器架构发展：\n\n\n\n1984\n2004\n\n\n\nARM 1\nARM 11\n\n\n放弃数字命名，用cortex来命令处理器产品\nCortex-A 系列：主打高性能 手机，平板，智能电视等\nCortex-R 系列：主打实时 汽车，工业控制，医疗设备等\nCortex-M 系列：主打嵌入式 传感器、智能家居等\n什么是 STM32ST 公司设计的一系列以 ARM Cortext-M 为核心的32位微控制器\n\n意法半导体(STMicroelectronics，简称 ST)集团于 I987 年成立，是由意大利的 SGS 微电子公司和法国 Thomson:半导体公司合并而成。\n\nST 是世界最大的半导体公司之一\n如今的 32 位控制器中，STM32 大受工程师和市场的青睐，无芯能出其右\n\n而 STM32 主流使用 Cortex-M3 内核，简称：CM3\nSTM32 系列 MCU 命名规则[STM32F 103ZET6]芯片实物图：\n\n命名规范：\n\n","categories":["嵌入式"],"tags":["stm32"]},{"title":"内网穿透","url":"/2024/07/22/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","content":"ZerotierZerotier 是一款开源工具，可以用来构建基于点对点（P2P）连接的虚拟专用网（VPN）。把各种设备加入相同的虚拟网络，就可以在任何有网络的地方实现网络内的设备互访。官网：https://www.zerotier.com/\n首先通过访问：ZeroTier Central，创建一个自己的网络，并记录自己的Network ID\n安装应用访问页面：Download - ZeroTier，进行下载\nWindows：\n\nhttps://download.zerotier.com/dist/ZeroTier%20One.msi\n\nLinux：\ncurl -s https://install.zerotier.com | sudo bash\n\n安装成功后，通过一下命令检验：\nroot@jd ~$ zerotier-cli info200 info b35ec77777 1.14.0 ONLINE\n\n卸载应用# 通过dpkg删除zerotier-one服务sudo dpkg -P zerotier-one# 删除zerotier-one文件夹，该文件夹存储了address地址，删除后再次安装会获得新的address地址sudo rm -rf /var/lib/zerotier-one/\n\n加入网络节点Windows：在状态栏对应用右键，选择加入网络，输入我们的Network ID，在页面ZeroTier Central中进行授权同意-&gt;Auth\nLinux：sudo zerotier-cli join Network ID ，显示200 join OK则在页面进行授权同意\n配置 Moon，加速网络zerotier 默认使用全球的服务节点，高峰时刻不稳定，官方也有说明，可以搭建自己的 moon 服务器作为跳板，加速网络。\n当有云服务器时，将服务器加入网络，进入服务器程序所在目录，默认为：/var/lib/zerotier-one\ncd /var/lib/zerotier-one\n\n生成moon.json配置文件\nsudo zerotier-idtool initmoon identity.public &gt;&gt;moon.json\n\n编辑moon.json配置文件\nsudo vim moon.json\n\n将配置文件中的&quot;stableEndpoints&quot;: []修改成&quot;stableEndpoints&quot;: [&quot;ServerIp/9993&quot;]，将ServerIp替换成公网 Ip\n生成.moon 文件\nsudo zerotier-idtool genmoon moon.json\n\n将生成的 000000xxxxxxxxxx.moon移动到 moons.d目录\nsudo mkdir moods.dsudo cp 000000xxxxxxxxxx.moon moods.d/\n\n\n.moon 配置文件名一般为 10个前导零 + 本机节点ID\n\n重启 zerotier-one 服务\nsudo systemctl restart zerotier-one.service\n\n使用 Moon在其他设备上\n# 查看设备网络sudo zerotier-cli listnetworks# 查看设备节点连接情况sudo zerotier-cli listpeers\n\n可以通过查看设备节点连接情况，看到节点中有我们配置的 Moon 服务器的节点 ID，但是角色还是LEAF\n200 listpeers &lt;ztaddr&gt; &lt;path&gt; &lt;latency&gt; &lt;version&gt; &lt;role&gt;200 listpeers 61777fcf53 - -1 - LEAF\n\n我们以 Moon 的形式将 Moon 服务器节点添加到我们的设备中\n先复制 Moon 服务器的 id，通过 zerotier-cli info 查看\n复制 Moon 服务器的 /var/lib/zerotier-one/moons.d/到其余服务器相同位置，\n如 Windows 系统的 c:\\programdata\\zerotier\\one\\moons.d 或 Linux 系统的 /var/lib/zerotier-one/moons.d/\nLinux：\nsudo zerotier-cli orbit 服务器id 服务器id# 例如：sudo zerotier-cli orbit b35ec77777 b35ec77777#返回结果200 orbit OK// 重启systemctl restart zerotier-one\n\n**Windows:**通过管理员运行 cmd\nzerotier-cli.bat orbit 服务器id 服务器id\n\n在服务管理中重启\n配置完成后，更改路由：\n\n\n说明 1： 192.168.196.0&#x2F;24，局域网网段\n说明 2： 把所有主机的局域网 IP 都加上去，例如我有 3 个\n说明 3： 路由生效存在延迟，多 ping 几次\n说明 4： ping 技巧： 主机优先 ping 公网的内网 IP，然后逐个 ping 其他主机的 IP；每个主机都执行一次，速度就上来了\n说明 5： 把默认的删除掉，不然还会走默认的路由\n\n创建根节点 Planet创建根节点 Planet 需要有一个云服务器，并且拥有公网 Ip\n安装我们使用 docker 安装：ZTNet - Zerotier Web UI Documentation、postgres（数据库）、zerotier\n安装 Docker，Docker Compose 后，创建一个 docker-compose.yml 文件\nservices:  postgres:    image: postgres:15.2-alpine    container_name: postgres    restart: unless-stopped    environment:      POSTGRES_USER: postgres      POSTGRES_PASSWORD: postgres      POSTGRES_DB: ztnet    volumes:      - postgres-data:/var/lib/postgresql/data    networks:      - app-network  zerotier:    image: zyclonite/zerotier:1.14.0    hostname: zerotier    container_name: zerotier    restart: unless-stopped    volumes:      - zerotier:/var/lib/zerotier-one    cap_add:      - NET_ADMIN      - SYS_ADMIN    devices:      - /dev/net/tun:/dev/net/tun    networks:      - app-network    ports:      - &quot;9993:9993/udp&quot;    environment:      - ZT_OVERRIDE_LOCAL_CONF=true      - ZT_ALLOW_MANAGEMENT_FROM=172.31.255.0/29  ztnet:    image: sinamics/ztnet:latest    container_name: ztnet    working_dir: /app    volumes:      - zerotier:/var/lib/zerotier-one    restart: unless-stopped    ports:      - 3000:3000    # - 127.0.0.1:3000:3000  &lt;--- Use / Uncomment this line to restrict access to localhost only    environment:      POSTGRES_HOST: postgres      POSTGRES_PORT: 5432      POSTGRES_USER: postgres      POSTGRES_PASSWORD: postgres      POSTGRES_DB: ztnet      NEXTAUTH_URL: &quot;http://localhost:3000&quot; # !! Important !! Set the NEXTAUTH_URL environment variable to the canonical URL or IP of your site with port 3000      NEXTAUTH_SECRET: &quot;random_secret&quot;      NEXTAUTH_URL_INTERNAL: &quot;http://ztnet:3000&quot; # Internal NextAuth URL for &#x27;ztnet&#x27; container on port 3000. Do not change unless modifying container name.    networks:      - app-network    links:      - postgres    depends_on:      - postgres      - zerotier  ############################################################################  #                                                                          #  # Uncomment the section below to enable HTTPS reverse proxy with Caddy.    #  #                                                                          #  # Steps:                                                                   #  # 1. Replace &lt;YOUR-PUBLIC-HOST-NAME&gt; with your actual public domain name.  #  # 2. Uncomment the caddy_data volume definition in the volumes section.    #  #                                                                          #  ############################################################################  # https-proxy:  #   image: caddy:latest  #   container_name: ztnet-https-proxy  #   restart: unless-stopped  #   depends_on:  #     - ztnet  #   command: caddy reverse-proxy --from &lt;YOUR-PUBLIC-HOST-NAME&gt; --to ztnet:3000  #   volumes:  #     - caddy_data:/data  #   networks:  #     - app-network  #   links:  #     - ztnet  #   ports:  #     - &quot;80:80&quot;  #     - &quot;443:443&quot;volumes:  zerotier:  postgres-data:  # caddy_data:networks:  app-network:    driver: bridge    ipam:      driver: default      config:        - subnet: 172.31.255.0/29\n\n或者直接下载：\nwget -O docker-compose.yml https://raw.githubusercontent.com/sinamics/ztnet/main/docker-compose.yml\n\n更改docker-compose.yml，设置默认服务器 IP\nservices:  ...  ztnet:    ...    environment:\t  ...      NEXTAUTH_URL: &quot;http://公网Ip:3000&quot;\n\n启动 docker：\ndocker compose up -d\n\n放开服务器3000端口，访问 http://公网ip:3000，进行注册，注册的一个用户为管理员\n然后点击设置-》控制器，在最下面创建自定义星球，输入公网 ip，点击创建，点击下载 api/planet,保存好文件\n\n加入根节点这里主要以Windows和Linux演示加入，分别设备下载好 zerotier 客户端，Download - ZeroTier\n将刚才保存的planet文件，分别覆盖到：\n\nWindows：C:\\ProgramData\\ZeroTier\\One 路径下\nLinux：/var/lib/zerotier-one 路径下\n\n重启服务：\n\nwindows：win + R，输入services.msc，找到ZeroTier One-》重启动\nLinux：systemctl restart zerotier-one\n\n使用命令查看根节点是否只有自己的一个：zerotier-cli peers,可以看到只有一个PLANET\n$ zerotier-cli peers200 peers&lt;ztaddr&gt;   &lt;ver&gt;  &lt;role&gt; &lt;lat&gt; &lt;link&gt;   &lt;lastTX&gt; &lt;lastRX&gt; &lt;path&gt;b740eaaaee 1.14.0 PLANET    21 DIRECT   942      15       公网Ip/9993\n\n然后我们加入网络节点，在 Web 管理页面，选择本地控制器-&gt; 创建网络-&gt;复制网络ID\n在设备中加入网络：zerotier-cli join 网络ID\nNatapp将自己开发的机器上的应用提供到公网上进行访问，但是并不想通过注册域名、搭建服务器；由此可以使用 natapp（内网穿透）\n1.注册用户进入官网后进行注册：https://natapp.cn\n2.购买免费隧道\n3.修改隧道\n4.下载 natapp 应用下载对应机型应用：https://natapp.cn/#download，下载好后解压，得到natapp.exe\n5.配置应用进行内网穿透还需要配置本地配置文件config.ini，参考网址：https://natapp.cn/article/config_ini\n#将本文件放置于natapp同级目录 程序将读取 [default] 段#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置#命令行参数 -config= 可以指定任意config.ini文件[default]authtoken=取得authtoken（刚刚才购买的隧道） #对应一条隧道的authtokenclienttoken=                    \t\t#对应客户端的clienttoken,将会忽略authtoken,若无请留空,log=none                        \t\t#log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为noneloglevel=ERROR                  \t\t#日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUGhttp_proxy=                     \t\t#代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空\n\n6.运行应用将配置文件config.ini与natapp.exe放在同一个目录下，双击natapp.exe启动即可\n\n","categories":["工具","网络"],"tags":["Zerotier","内网穿透","Natapp"]},{"title":"前端小工具","url":"/2023/08/04/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%B7%A5%E5%85%B7/","content":"HTMLvideo样式&lt;style&gt;  /*video默认setting按钮*/  video::-internal-media-controls-overflow-button&#123; display: none !important;&#125;    /*更改是否显示播放秒数*/  video::-webkit-media-controls-current-time-display&#123;display: none; !important;&#125;    /*更改是否显示进度条*/  video::-webkit-media-controls-timeline &#123;display: none; !important;&#125;    /*更改是否显示视频总时间*/  video::-webkit-media-controls-time-remaining-display &#123;display: none; !important;&#125;    /*更改是否显示播放暂停按钮 */  video::-webkit-media-controls-play-button &#123;display: none; !important;&#125;    /*更改是否显示下载按钮 */  video::-internal-media-controls-download-button &#123; display:none; !important;&#125;    /*更改是否显示全屏按钮*/  video::-webkit-media-controls-fullscreen-button &#123; display: none; &#125;    /*更改是否显示声音*/  video::-webkit-media-controls-mute-button &#123; display: none;&#125;  video::-webkit-media-controls-toggle-closed-captions-button &#123;display: none;&#125;    /*更改是否显示音量的控制条*/  video::-webkit-media-controls-volume-slider &#123;display: none;&#125;    /*整个控制栏都隐藏掉*/  video::-webkit-media-controls-enclosure&#123; overflow: hidden; &#125;    /*重置audio和video的边框和圆角样式*/  video::-webkit-media-controls-panel&#123; width: calc(100% + 30px); &#125;&lt;/style&gt;\n\n\n\nVueelement-plus组件设置为中文在App.vue中，设置为中文，即可全局都为中文\n&lt;template&gt;  &lt;el-config-provider :locale=&quot;zhCn&quot;&gt;    &lt;router-view/&gt;  &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup&gt;import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;\n\n也可对某个组件单独设置\n&lt;script setup&gt;import zhCn from &#x27;element-plus/es/locale/lang/zh-cn&#x27;zhCn.el.pagination.goto = &#x27;🛩️&#x27;&lt;/script&gt;\n\n\n预览office//docx文档预览组件npm install @vue-office/docx//excel文档预览组件npm install @vue-office/excel//pdf文档预览组件npm install @vue-office/pdf\n\ndocx演示\n&lt;template&gt;  &lt;vue-office-docx :src=&quot;docx&quot; @rendered=&quot;rendered&quot;/&gt;&lt;/template&gt;&lt;script&gt;//引入VueOfficeDocx组件import VueOfficeDocx from &#x27;@vue-office/docx&#x27;export default &#123;  components:&#123;    VueOfficeDocx  &#125;,  data()&#123;    return &#123;      docx: &#x27;http://static.shanhuxueyuan.com/test6.docx&#x27; //设置文档地址    &#125;  &#125;,  methods:&#123;    rendered()&#123;      console.log(&quot;渲染完成&quot;)    &#125;  &#125;&#125;&lt;/script&gt;\n\nexcel文档\n&lt;template&gt;  &lt;vue-office-excel :src=&quot;excel&quot; @rendered=&quot;rendered&quot;/&gt;&lt;/template&gt;&lt;script&gt;//引入VueOfficeExcel组件import VueOfficeExcel from &#x27;@vue-office/excel&#x27;//引入相关样式import &#x27;@vue-office/excel/lib/index.css&#x27;export default &#123;  components:&#123;    VueOfficeExcel  &#125;,  data()&#123;    return &#123;      excel: &#x27;http://static.shanhuxueyuan.com/demo/excel.xlsx&#x27;//设置文档地址    &#125;  &#125;,  methods:&#123;    rendered()&#123;      console.log(&quot;渲染完成&quot;)    &#125;  &#125;&#125;&lt;/script&gt;\n\npdf文档\n&lt;template&gt;  &lt;vue-office-pdf :src=&quot;pdf&quot; @rendered=&quot;rendered&quot;/&gt;&lt;/template&gt;&lt;script&gt;//引入VueOfficePdf组件import VueOfficePdf from &#x27;@vue-office/pdf&#x27;export default &#123;  components:&#123;    VueOfficePdf  &#125;,  data()&#123;    return &#123;      pdf: &#x27;http://static.shanhuxueyuan.com/test.pdf&#x27; //设置文档地址    &#125;  &#125;,  methods:&#123;    rendered()&#123;      console.log(&quot;渲染完成&quot;)    &#125;  &#125;&#125;&lt;/script&gt;\n\n编写预览MarkdownCherry Markwodn Editor\nCherry Markdown Editor 是一款 Javascript Markdown 编辑器，具有开箱即用、轻量简洁、易于扩展等特点. 它可以运行在浏览器或服务端(NodeJs).\n开箱即用\n开发者可以使用非常简单的方式调用并实例化 Cherry Markdown 编辑器，实例化的编辑器默认支持大部分常用的 markdown 语法（如标题、目录、流程图、公式等）。\n易于拓展\n当 Cherry Markdown 编辑器支持的语法不满足开发者需求时，可以快速的进行二次开发或功能扩展。同时，CherryMarkdown 编辑器应该由纯 JavaScript 实现，不应该依赖 angular、vue、react 等框架技术，框架只提供容器环境即可。\n安装\nnpm install cherry-markdown --save\n\n如果需要开启 mermaid 画图、表格自动转图表功能，需要同时添加mermaid 与echarts包。\n目前Cherry推荐的插件版本为echarts@4.6.0、mermaid@9.4.3\n# 安装mermaid依赖开启mermaid画图功能npm i mermaid@9.4.3# 安装echarts依赖开启表格自动转图表功能npm i echarts@4.6.0\n\n\n\nSVG组件为了在vue项目中使用SVG，首先进行安装插件：\npnpm install vite-plugin-svg-icons -D\n\n在vite.config.ts中引入插件：\n// 引入SVG需要用到插件import &#123;createSvgIconsPlugin&#125; from &quot;vite-plugin-svg-icons&quot;;...export default defineConfig(&#123;    plugins: [        vue(),        createSvgIconsPlugin(&#123;            iconDirs: [path.resolve(process.cwd(), &#x27;src/assets/icons&#x27;)],            symbolId: &#x27;icon-[dir]-[name]&#x27;,        &#125;)    ],    ...&#125;)\n\n在main.ts中配置：\n// svg插件需要配置代码import &#x27;virtual:svg-icons-register&#x27;\n\n在页面中使用时：\n&lt;!-- svg：图标外层容器节点，内部需要与use标签结合使用 --&gt;&lt;svg style=&quot;width: 90px; height: 90px;&quot;&gt;    &lt;!-- xlink:href 执行用哪一个图标,格式 #icon-[路径src/assets/icons下的SVG文件名]  --&gt;    &lt;!-- use标签fill属性可以设置图标的颜色 --&gt;    &lt;use xlink:href=&quot;#icon-phone&quot; fill=&quot;red&quot;&gt;&lt;/use&gt;&lt;/svg&gt;\n\n为了方便使用将SVG封装为一个组件，新建一个组件在 src/components/SvgIcon/index.vue，写入：\n&lt;template&gt;  &lt;!-- svg：图标外层容器节点，内部需要与use标签结合使用 --&gt;  &lt;svg :style=&quot;&#123;width,height&#125;&quot;&gt;    &lt;!-- xlink:href 执行用哪一个图标 --&gt;    &lt;!-- use标签fill属性可以设置图标的颜色 --&gt;    &lt;use :xlink:href=&quot;prefix + name&quot; :fill=&quot;color&quot;&gt;&lt;/use&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;index&quot;&gt;defineProps(&#123;  // xlink:href属性值前缀  prefix: &#123;    type: String,    default: &#x27;#icon-&#x27;  &#125;,  // 提供使用的图标名字  name: String,  // 接收父组件传递颜色  color: &#123;    type: String,    default: &#x27;&#x27;  &#125;,  // 接收父组件传递的图标宽度  width: &#123;    type: String,    default: &#x27;16px&#x27;  &#125;,  // 接收父组件传递的图标高度  height: &#123;    type: String,    default: &#x27;16px&#x27;  &#125;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n在其他组件使用时：可传入，name:路径src/assets/icons下SVG图标名称 color:图标颜色 width、height:图标宽高\n&lt;template&gt;\t&lt;svg-icon name=&quot;home&quot; color=&quot;pink&quot; width=&quot;100px&quot; height=&quot;100px&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;import SvgIcon from &#x27;@/components/SvgIcon/index.vue&#x27;&lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["高级语言"],"tags":["Vue","Js"]},{"title":"博客搭建配置","url":"/2023/05/17/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/","content":"Hexo安装前提安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\nGit\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。\n如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n安装 Git\nWindows：下载并安装 git.\nMac：使用 Homebrew, MacPorts 或者下载 安装程序。\nLinux (Ubuntu, Debian)：sudo apt-get install git-core\nLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n\nMac 用户\n如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。\n\n\nWindows 用户\n对于中国大陆地区用户，可以前往 淘宝 Git for Windows 镜像 下载 git 安装包。\n\n安装 Node.jsNode.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。\n其它的安装方法：\n\nWindows：通过 nvm 安装。\nMac：使用 Homebrew 或 MacPorts 安装。\nLinux（DEB&#x2F;RPM-based）：从 NodeSource 安装。\n其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导。\n\n对于 Mac 和 Linux 同样建议使用  nvm，以避免可能会出现的权限问题。\n\nWindows 用户\n使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）\n\n\nFor Mac &#x2F; Linux 用户\n如果在尝试安装 Hexo 的过程中出现 EACCES 权限错误，请遵循 由 npmjs 发布的指导 修复该问题。强烈建议 不要 使用 root、sudo 等方法覆盖权限\n\n\nLinux\n如果您使用 Snap 来安装 Node.js，在 初始化 博客时您可能需要手动在目标文件夹中执行 npm install。\n\n安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n$ npm install -g hexo-cli\n\n初始化 Hexo 项目$ hexo init blog(项目名)\n\ncd blog-demo  //进入blog-demo文件夹npm i\t\t // 安装依赖\n\n初始化项目后，blog有如下结构：\n【node_modules】：依赖包【scaffolds】：生成文章的一些模板【source】：用来存放你的文章【themes】：主题【.npmignore】：发布时忽略的文件（可忽略）【_config.landscape.yml】：主题的配置文件【config.yml】：博客的配置文件【package.json】：项目名称、描述、版本、运行和开发等信息\n启动项目\nhexo server或者hexo s\n\n$ hexo s================================INFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n\n\n\n挂载到GitHub Pages安装 hexo-deployer-git\nnpm install hexo-deployer-git --save\n\n修改 _config.yml 文件\n修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为main代表主分支（注意缩进）。\ndeploy:  type: git  repository: git@github.com:Fomalhaut-Blog/Fomalhaut-Blog.github.io.git  branch: main\n\n修改好配置后，运行如下命令，将代码部署到 GitHub\nhexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  // Git BASH终端hexo clean; hexo generate; hexo deploy  // VSCODE终端\n\n\nhexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。\nhexo generate：生成静态文章，可以用hexo g缩写\nhexo deploy：部署文章，可以用hexo d缩写\n\n如果出现Deploy done，则说明部署成功了。\n\n新建页面或分栏新建页面\nhexo new [layout] &lt;title&gt;\n\nlayout 是文章的布局，默认为post，可以先不写。[post(默认)、draft、page]title 是文章的标题，也是文件的名字，存储在source&#x2F;_posts下\n新建分栏\nhexo new page &lt;title&gt;\n\n\n\n博客配置官方文档\nButterfly - A Simple and Card UI Design theme for Hexo\n安装butterfly主题在你的博客根目录打开Git BASH命令窗口执行npm i hexo-theme-butterfly\nnpm i hexo-theme-butterfly\n\n安装成功后可在【blog&#x2F;node_modules】文件夹下找到hexo-theme-butterfly文件夹\n升级方法：在博客根目录下，运行 npm update hexo-theme-butterfly。升级前请将hexo-theme-butterfly文件夹备份，npm更新会直接覆盖成新的包。\n应用主题\n修改站点配置文件_config.yml，把主题改为butterfly\ntheme: butterfly\n\n如果你没有pug以及stylus的渲染器，请下载安装，这两个渲染器是Butterfly生成基础页面所需的依赖包：\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n\n为了减少升级主题后带来的不便，请使用以下方法（建议，可以不做，高度魔改的一般都不会升级主题了，不然魔改的会被覆盖掉）把主题文件夹中的 _config.yml 复制到 Hexo 根目录里（，同时重新命名为 _config.butterfly.yml。以后只需要在 _config.butterfly.yml进行配置即可生效。Hexo会自动合併主题中的_config.yml和 _config.butterfly.yml里的配置，如果存在同名配置，会使用_config.butterfly.yml的配置，其优先度较高。\n\n\nFront-matterFront-matter 是 markdown 文件最上方以---分隔的区域，用于指定个别档案的变数。\n\nPage Front-matter 用于页面配置\nPost Front-matter 用于文章页配置\n\nPage Front-matter：\n---title:date:updated:type:comments:description:keywords:top_img:mathjax:katex:aside:aplayer:highlight_shrink:---\n\n\n\n\n写法\n解释\n\n\n\ntitle\n【必需】页面标题\n\n\ndate\n【必需】页面创建日期\n\n\ntype\n【必需】标籤、分类和友情链接三个页面需要配置\n\n\nupdated\n【可选】页面更新日期\n\n\ndescription\n【可选】页面描述\n\n\nkeywords\n【可选】页面关键字\n\n\ncomments\n【可选】显示页面评论模块(默认 true)\n\n\ntop_img\n【可选】页面顶部图片\n\n\nmathjax\n【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\n\nkates\n【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\naplayer\n【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)\n\n\nPost Front-matter：\n---title:date:updated:tags:categories:keywords:description:top_img:comments:cover:toc:toc_number:toc_style_simple:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink:aside:---\n\n\n\n\n写法\n解释\n\n\n\ntitle\n【必需】文章标题\n\n\ndate\n【必需】文章创建日期\n\n\nupdated\n【可选】文章更新日期\n\n\ntags\n【可选】文章标籤\n\n\ncategories\n【可选】文章分类\n\n\nkeywords\n【可选】文章关键字\n\n\ndescription\n【可选】文章描述\n\n\ntop_img\n【可选】文章顶部图片\n\n\ncover\n【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)\n\n\ncomments\n【可选】显示文章评论模块(默认 true)\n\n\ntoc\n【可选】显示文章TOC(默认为设置中toc的enable配置)\n\n\ntoc_number\n【可选】显示toc_number(默认为设置中toc的number配置)\n\n\ntoc_style_simple\n【可选】显示 toc 简洁模式\n\n\ncopyright\n【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)\n\n\ncopyright_author\n【可选】文章版权模块的文章作者\n\n\ncopyright_author_href\n【可选】文章版权模块的文章作者链接\n\n\ncopyright_url\n【可选】文章版权模块的文章连结链接\n\n\ncopyright_info\n【可选】文章版权模块的版权声明文字\n\n\nmathjax\n【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\n\nkatex\n【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n\n\naplayer\n【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\n标签页前往你的Hexo博客根目录，打开Git Bash执行如下命令：\nhexo new page tags\n\n在\\source\\会生成一个含有index.md文件的tags文件夹。\n修改\\source\\tags\\index.md，添加type: &quot;tags&quot;。\n---title: tagsdate: 2022-10-28 12:00:00type: &quot;tags&quot;---\n\n\n\n友情链接前往你的Hexo博客根目录，打开cmd命令窗口执行如下命令：\nhexo new page link\n\n在[BlogRoot]\\source\\会生成一个含有index.md文件的link文件夹\n修改[BlogRoot]\\source\\link\\index.md，添加type: &quot;link&quot;\n---title: linkdate: 2022-10-28 12:00:00type: &quot;link&quot;---\n\n前往[BlogRoot]\\source\\_data创建一个link.yml文件（如果沒有 _data 文件夹，请自行创建），并写入如下信息（根据你的需要写）：\n- class_name: 1.技术支持  class_desc: 本网站的搭建由以下开源作者提供技术支持  link_list:     - name: Hexo       link: https://hexo.io/zh-cn/      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg      descr: 快速、简单且强大的网志框架      siteshot: https://source.fomal.cc/siteshot/hexo.io.jpg      - class_name: 2.友情链接  class_desc: 一些好朋友~~  link_list:    - name: Fomalhaut🥝      link: https://fomal.cc/      avatar: /assets/head.jpg      descr: Future is now 🍭🍭🍭      siteshot: https://source.fomal.cc/siteshot/www.fomal.cn.jpg\n\nclass_name和class_desc支持 html 格式，如不需要，也可以留空。\n404页面主題內置了一个简单的404页面，可在设置中开放。\n如需本地预览，请访问 http://localhost:4000/404.html\n# A simple 404 pageerror_404:  enable: true  subtitle: &quot;页面沒有找到&quot;  background: \n\n博客网站配置\ngit\n\n# 清除缓存，生成静态文件，部署到github hexo cl &amp;&amp; hexo g &amp;&amp; hexo d # git bashhexo cl; hexo g; hexo d # vscode\n\nMarkdown语法与外挂标签写法汇总https://www.fomal.cc/posts/5389e93f.html\n&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;\n\n\n\n\n需要复制的\n需要删除的\n\n\n\n_config.yml：站点配置文件\n.git：无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉\n\n\n_config.butterfly.yml：主题配置文件，为了方便主题升级剥离出来的配置文件\nnode_modules：npm install会根据package.json生成\n\n\npackage.json：说明使用哪些依赖包\npublic：hexo g会重新编译生成\n\n\nscaffolds：文章的模板\n.deploy_git：在使用hexo d时也会重新生成\n\n\nsource：自己写的博客源码\ndb.json文件：hexo s快速启动所需的数据库\n\n\nthemes：主题文件夹（魔改都在里面啦）\npackage-lock.json：记录依赖之间的内部依赖关系，可以根据package.json重新生成\n\n\n.gitignore：说明在提交时哪些文件可以忽略\n\n\n\n嵌入B站视频\n&lt;div align=center class=&quot;aspect-ratio&quot;&gt;    &lt;iframe src=&quot;https://player.bilibili.com/player.html?aid=247609487&amp;bvid=BV1vv41177jq&amp;cid=324439110&amp;page=1&amp;high_quality=1&amp;danmaku=0&quot;     scrolling=&quot;no&quot;     border=&quot;0&quot;     frameborder=&quot;no&quot;     framespacing=&quot;0&quot;     high_quality=1    danmaku=1     allowfullscreen=&quot;true&quot;&gt;     &lt;/iframe&gt;&lt;/div&gt;\n\n\n\n\n视频质量\n弹幕（0为默认关闭）\n\n\n\n&amp;high_quality&#x3D;1\n&amp;danmaku&#x3D;0\n\n\nAplayer歌单引入必要的参数\ndata-id &#x3D;&gt;音乐页面链接上的id号\ndata-server &#x3D;&gt; 平台名称。netease：网易；tencent：腾讯；xiami：虾米；kugou：酷狗；baidu：百度\ndata-type&#x3D;&gt;类型。playlist：歌单；song：单曲；专辑：album；关键词：search；歌手：artist\n\n\n\ndata-id\ndata-server\ndata-type\n\n\n\n3778678\nnetease\nplaylist\n\n\n热歌榜\n网易\n歌单\n\n\nGIThub工作流在根目录创建.github，在里面新建文件夹workflows，新建dependblog.yml\nname: publish siteon: # 在什么时候触发工作流  push: # 在从本地main分支被push到GitHub仓库时    branches:      - main  pull_request: # 在main分支合并别人提的pr时    branches:      - mainjobs: # 工作流的具体内容  deploy:    runs-on: ubuntu-latest # 创建一个新的云端虚拟机 使用最新Ubuntu系统    steps:      - uses: actions/checkout@v2 # 先checkout到main分支      - uses: actions/setup-python@v2 # 再安装Python3和相关环境        with:          python-version: 3.x      - run: pip install mkdocs-material # 使用pip包管理工具安装mkdocs-material      - run: mkdocs gh-deploy --force # 使用mkdocs-material部署gh-pages分支\n\n\n\nAlgolia搜索写入索引hexo algolia\n\n\n\nAnzhiyu主题\n\n\n写法\n解释\n\n\n\ntitle\n【必需】文章标题\n\n\ndate\n【必需】文章创建日期\n\n\nupdated\n【可选】文章更新日期\n\n\ntags\n【可选】文章标签\n\n\ncategories\n【可选】文章分类\n\n\nkeywords\n【可选】文章关键字\n\n\ndescription\n【可选】文章描述\n\n\ntop_img\n【可选】文章顶部图片\n\n\ncover\n【可选】文章缩略图(如果没有设置 top_img,文章页顶部将显示缩略图，可设为 false&#x2F;图片地址&#x2F;留空)\n\n\ncomments\n【可选】显示文章评论模块(默认 true)\n\n\ntoc\n【可选】显示文章 TOC(默认为设置中 toc 的 enable 配置)\n\n\ntoc_number\n【可选】显示 toc_number(默认为设置中 toc 的 number 配置)\n\n\ntoc_style_simple\n【可选】显示 toc 简洁模式\n\n\ncopyright\n【可选】显示文章版权模块(默认为设置中 post_copyright 的 enable 配置)\n\n\ncopyright_author\n【可选】文章版权模块的文章作者\n\n\ncopyright_author_href\n【可选】文章版权模块的文章作者链接\n\n\ncopyright_url\n【可选】文章版权模块的文章链接链接\n\n\ncopyright_info\n【可选】文章版权模块的版权声明文字\n\n\nmathjax\n【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)\n\n\nkatex\n【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)\n\n\naplayer\n【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\nswiper_index\n【可选】首页轮播图配置 index 索引，数字越小越靠前\n\n\ntop_group_index\n【可选】首页右侧卡片组配置, 数字越小越靠前\n\n\nbackground\n【可选】文章背景可配置为 16 进制颜色值\n\n\n\n首页轮播图配置: swiper_index, 数字越小越靠前\n首页卡片配置: top_group_index, 数字越小越靠前\npage 中background, 可配置为 16 进制颜色值\n\nQexoHexo的管理界面\n","categories":["博客"],"tags":["主题"]},{"title":"图床","url":"/2023/06/29/%E5%9B%BE%E5%BA%8A/","content":"Github 搭建图床使用 PicGo 连接 github，typora 自动上传图片\n在 PicGo 中进行设置，可以使用不同的 cdn\nhttps://cdn.jsdelivr.net/gh/Wang-weijun/pic_bed@mainhttps://cdn.staticaly.com/gh/Wang-weijun/pic_bed@main\n\n\nnpm 图床\n首先需要注册一个 npm 的账号。访问npm 注册页面 、用户名最好写名字\n完成邮箱验证\n找到我们之前创建的图床仓库，在本地合适的位置把它clone下来。找个空文件夹打开终端输入\n\ngit clone git@github.com:[username]/[AssetsRepo].git#或者git clone https://github.com/[username]/[AssetsRepo].git\n\n\n在 clone 下来的[AssetsRepo]文件夹内打开终端，输入以下指令切换回原生源\n\nnpm config set registry https://registry.npmjs.org\n\n\n添加本地 npm 用户设置\n\n# 仅第一次使用需要添加用户，之后会提示你输入你的npm账号密码以及注册邮箱npm adduser# 非第一次使用直接登录即可，之后会提示你输入你的npm账号密码以及注册邮箱npm login\n\n\n运行 npm 初始化指令，把整个图床仓库打包，按照指示进行配置，注意需要事先确认你的包名没有和别人已发布的包重复，可以在 npm 官网搜索相应包名，搜不到就说明还没被占用。\n\nnpm init\n\n\n最后会输出一段 package.json，请求确认，输入 yes 即可。\n\n然后输入发布指令，我们就可以把包发布到 npm 上了。\n\nnpm publish\n\n\njsdelivr+npm 的图片引用和 jsdelivr+github 很相似，例如我在[AssetsRepo]仓库里存放的/img/index.png\n\n# jsDelivr+github链接https://cdn.jsdelivr.net/gh/[GithubUserName]/[AssetsRepo]/img/index.png# jsDelivr+npm链接https://cdn.jsdelivr.net/npm/[NpmPackageName]/img/index.png\n\njsDelivr+Npm 依然有 100MB 的包大小限制，但是 NPM 有丰富的国内节点。可以挑选一个使用。个人推荐知乎的。没\t有大小限制，而且也很稳定。\n\n【jsd出品，网宿国内节点】https://cdn.jsdelivr.net/npm/:package@:version/:file【unpkg 自建】https://cdn.cbd.int/:package@:version/:file\n\n\n如果每次都要在本地进行npm publish的话，npm 的提交是整个包一起上传的，不存在增量更新，耗时不说，而且还往往需要架梯子才能正常上传。所以我们可以把它交给 github action 来完成。\n\n\n在npm 官网-&gt;头像-&gt;Access Tokens-&gt;Generate New Token,勾选 Automation 选项，Token只会显示这一次，之后如果忘记了就只能重新生成重新配置了。\n\n\n\n在本地的[AssetsRepo]文件夹下新建[AssetsRepo]/.github/workflows/autopublish.yml\nname: Node.js Packageon:  push:    branches:      - mainjobs:  publish-npm:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - uses: actions/setup-node@v1        with:          node-version: &quot;16.x&quot;          registry-url: https://registry.npmjs.org/      - run: npm publish        env:          NODE_AUTH_TOKEN: $&#123;&#123;secrets.npm_token&#125;&#125;\n\n\n在本地的[AssetsRepo]文件夹下打开终端，运行以下指令，上传新增内容至 github，即可触发部署。\n\n# 将更改提交git add .git commit -m &quot;npm publish&quot;# 更新package版本号npm version patch# 推送至github触发actiongit push\n\n\n此处的四行指令顺序严格。每次更新 npm 图床都需要先修改[AssetsRepo]\\package.json里的version,也就是版本号。而npm version patch即为更新 package.json 里的版本号的指令，效果是末尾版本号+1，例如0.0.1=&gt;0.0.2、1.1.3=&gt;1.1.4。免去了打开package.json再修改版本号的麻烦。（大版本更新还是需要手动改的）更新 npm 图床务必要记得更新package.json里的版本号！\n\n又拍云图床（推荐）\n打开又拍云官网、正常注册，并且实名认证。\n选择产品，然后选择云存储，激活后进入控制台\n创建云存储服务、注意服务名称、后续会用到\n新建一个操作员，并且给权限全部打勾。\n\n\n\n然后在PicG0中设置，其中 Bucket 就是又拍云中云存储的服务名称，加速域名为自己设置的\n\n\n","categories":["博客"],"tags":["图床"]},{"title":"在线音乐播放器","url":"/2023/06/04/%E5%9C%A8%E7%BA%BF%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"准备工作如何在服务器上搭建在线音乐播放器 | hash070’s blog\n搭建所用到的服务后端音乐服务接口GitHub链接：\n\n\n前端mmPlayer GitHub链接:\n~~~### 搭建后端服务+ 后端服务克隆后执行安装~~~bash#我这边将这些文件放在了/www/wwwroot/文件夹下#进入/www/wwwroot/文件夹cd /www/wwwroot/#克隆音乐后端服务项目到该文件夹(如果由于网络原因下载失败，也可以直接点击上面的链接去github下载压缩包并解压上传到服务器)git clone https://github.com/Binaryify/NeteaseCloudMusicApi.git#进入克隆下来目录cd NeteaseCloudMusicApi/#执行安装命令npm install#如果提示npm命令不存在，则您应当手动安装nodejs和npm#安装命令(CentOS)：yum install nodejsyum install npm#如果执行npm命令提示链接错误等信息，则您应当尝试卸载并重新安装nodejs和npm#卸载命令(CentOS)yum remove nodejsyum remove npm\n\n\n在宝塔面板的软件商店中下载PM2管理器\n\n\n\n进入PM2管理器小工具界面，填写信息\n\n#启动文件填写/www/wwwroot/NeteaseCloudMusicApi/app.js#运行目录填写/www/wwwroot/NeteaseCloudMusicApi\n\n\n填写完成后点击提交可以看到项目运行成功\n\n\n构建前端服务\n将前端项目使用git clone命令或者自行下载并上传到服务器上\n\n#同样的,进入/www/wwwroot/文件夹cd /www/wwwroot/#克隆项目git clone https://github.com/maomao1996/Vue-mmPlayer.git\n\n\n进入项目目录，安装依赖并打包\n\n#进入项目目录cd Vue-mmPlayer#安装依赖npm install#编译打包npm run build\n\n\n执行编译打包命令之后，在该项目目录中会出现一个dict文件夹，里面就是生成的网站了\n\n\n\n这些文件先放着，去创建一个网站\n\n\n","categories":["服务器"],"tags":["nodejs"]},{"title":"大模型学习到实战","url":"/2024/12/02/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E5%88%B0%E5%AE%9E%E6%88%98/","content":"框架学习CUDA安装在学习大模型中，使用GPU跑大模型至关重要，针对N卡的CUDA驱动安装，打开命令行，输入nvidia-smi，查看支持的最高版本：\n\n\n查看到最高支持为12.7，所以我们安装的版本要 ≤12.7，访问官网：cuDNN Archive | NVIDIA Developer\n我的最高支持12.7，进入https://developer.nvidia.com/cuda-12-0-0-download-archive，选择系统版本下载。\n对驱动进行安装，安装选项进行精简安装，如出现CUDA Visual Studio Integration说明我们电脑没有Visual Studio，我们点击连接进行Visual Studio官网进行下载安装，打开后选择右下角的安装，选择添加工作负载，再点击安装。安装完成后，关闭Visual Studio。\n之后我们在CUDA的安装中，返回上一步，重新检查，通过后进行安装。\n安装完成后，安装cudnn，访问官网：cuDNN | NVIDIA，选择cuDNN 8.x - 1.x，进入后选择Download cuDNN v8.9.7 (December 5th,2023),for CUDA 12.x，下载后为ZIP格式压缩包，解压后的文件夹复制到CUDA的安装目录下。\n测试是否安装成功CUDA自带了测试程序，位于安装目录中，进入demo_suite后，在此处打开命令行，运行：bandwidthTest.exe\n\n接着运行deviceQuery.exe，结果也显示 PASS，说明我们的 CUDN 和 CUDA 已经安装成功了。\nPyTorch安装安装前先确保本机已安装Python或conda，访问Pytorch官网：Start Locally | PyTorch\n版本选择**PyTorch Build: Stable (2.5.1)稳定版，根据自己电脑情况，复制Run this Command:**进行安装：\n\n\n如果是有GPU的电脑并且安装了CUDA驱动，打开命令行，输入：nvcc -V，查看实际版本：\n\n\n所以我们的Compute Platform选择：CUDA12.1，因为我们的版本为12.0，向下兼容。\n测试是否安装成功打开命令行，进入到conda安装了pytorch的对应环境，输入python：\nimport torchprint(torch.__version__) # 查看torch当前版本号print(torch.version.cuda) #编译当前版本的torch使用的cuda版本号print(torch.cuda.is_available()) #查看当前cuda是否可用于当前版本的Torch,如果输出True,则表示GPU可用\n\n","categories":["大模型"],"tags":["Python","Torch"]},{"title":"工具集","url":"/2024/02/17/%E5%B7%A5%E5%85%B7%E9%9B%86/","content":"AnydeskAnydesk是一款远程桌面解决方案，可在多个位置的任意设备上访问文件和文件。它为 Windows、MacOS 和 Android 提供了流畅的远程桌面连接\n","categories":["工具","宝藏软件"],"tags":["远程桌面"]},{"title":"推荐算法","url":"/2023/06/16/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/","content":"协同过滤算法\n\n\n\n物品1\n物品2\n物品3\n物品4\n物品5\n\n\n\nAlice\n5\n3\n4\n4\n？\n\n\n用户1\n3\n1\n2\n3\n3\n\n\n用户2\n4\n3\n4\n3\n5\n\n\n用户3\n3\n5\n1\n5\n4\n\n\n用户4\n1\n3\n5\n2\n1\n\n\n\n基于用户（User）的协同过滤：Alice与用户2相似，所以预测为5。\n基于商品（Item）的协同过滤：物品5与物品3相似，Alice对物品3打了4分，所以预测物品5也为4。\n\n相似度计算余弦相似度衡量用户向量i与j之间的夹角，夹角越小，说明相似度越大，两个用户越相似。\n\n局限性：对于【评分不规范】，存在有些用户喜欢打高分或喜欢打低分，会影响相似度计算结果。\n\n皮尔逊相关系数相对于余弦相似性，皮尔逊相关系数通过用户平均对个独立评分进行修正，减少用户评分偏置的影响。\n其他\n欧氏距离\n曼哈顿距离\n马氏距离\n\nFunk SVD 算法\n传统SVG在缺失问题上的问题\n历史上对缺失值的研究有很多，对于一个没有被打分的物品来说，到底是应该给它补一个 0 值，还是应该给它补一个平均值呢？由于在实际过程中，元素缺失值是非常多的，这就导致了早期的 SVD 不论通过以上哪种方法进行补全在实际的应用之中都是不可以被接受的。\n\n加入偏移项后的 Funk-SVD\n在预测模型中添加三项偏移的模型，被称为 BaisSVD。\n\nBiased Item : (物品偏移), 表示了物品接受的评分和用户没有多大关系，物品本身质量决定了的偏移。\nBiased User : (用户偏移), 有些用户喜欢打高分，有些用户喜欢打低分，用户决定的偏移。\nBiased Mean : (全局平均值偏移),根据网站全局打分设置的偏移，可能和整体用户群和物品质量有相对应的关系。\n\n\n公式说明：\n\n符号含义：$\\gamma$ rates 学习率$\\lambda$ regularization 正则化项b biased 偏移\n\n\n\n","categories":["深度学习"],"tags":["Torch","SVG"]},{"title":"智能云盘","url":"/2023/07/26/%E6%99%BA%E8%83%BD%E4%BA%91%E7%9B%98/","content":"前端Vue前端使用vue3，vite构建，UI使用elementplus\n后端SpringBoot创建多模块的SpringBoot项目，下面是层级结构：\n\ncloud\ncloud-admin\n（cloud-admin）pom.xml （子）\ncloud-common\n（cloud-common）pom.xml （子）\n\n\npom.xml （父）\n\n（父）pom.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.juncloud&lt;/groupId&gt;    &lt;artifactId&gt;juncloud&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;name&gt;juncloud&lt;/name&gt;    &lt;description&gt;智能云盘&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 依赖声明 --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;!-- Spring Boot 依赖 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;2.7.14&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;                &lt;version&gt;2.7.13&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;                &lt;scope&gt;runtime&lt;/scope&gt;                &lt;version&gt;8.0.33&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;                &lt;optional&gt;true&lt;/optional&gt;                &lt;version&gt;1.18.28&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- Redis --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;                &lt;version&gt;2.7.13&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- 加密算法 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;                &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;2.1.0&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- mybatis-plus --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;                &lt;version&gt;3.5.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- 代码生成器 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;                &lt;version&gt;3.5.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;                &lt;artifactId&gt;velocity&lt;/artifactId&gt;                &lt;version&gt;1.7&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- 邮件发送--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;                &lt;version&gt;2.7.13&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--切面--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.aspectj&lt;/groupId&gt;                &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;                &lt;version&gt;1.9.7&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- 阿里JSON解析器 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;                &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;                &lt;version&gt;2.0.35&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--常用工具类 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;                &lt;version&gt;3.12.0&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- io常用工具类 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;commons-io&lt;/groupId&gt;                &lt;artifactId&gt;commons-io&lt;/artifactId&gt;                &lt;version&gt;2.13.0&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;commons-codec&lt;/groupId&gt;                &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;                &lt;version&gt;1.11&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- 自定义 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.juncloud&lt;/groupId&gt;                &lt;artifactId&gt;juncloud-admin&lt;/artifactId&gt;                &lt;version&gt;1.0&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.juncloud&lt;/groupId&gt;                &lt;artifactId&gt;juncloud-common&lt;/artifactId&gt;                &lt;version&gt;1.0&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;modules&gt;        &lt;module&gt;juncloud-admin&lt;/module&gt;        &lt;module&gt;juncloud-common&lt;/module&gt;    &lt;/modules&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;build&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7.14&lt;/version&gt;                &lt;configuration&gt;                    &lt;mainClass&gt;com.juncloud.admin.JuncloudApplication&lt;/mainClass&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n（cloud-admin）pom.xml （子）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;parent&gt;\t\t&lt;groupId&gt;com.juncloud&lt;/groupId&gt;\t\t&lt;artifactId&gt;juncloud&lt;/artifactId&gt;\t\t&lt;version&gt;1.0&lt;/version&gt;\t&lt;/parent&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;packaging&gt;jar&lt;/packaging&gt;\t&lt;artifactId&gt;juncloud-admin&lt;/artifactId&gt;\t&lt;version&gt;1.0&lt;/version&gt;\t&lt;name&gt;juncloud-admin&lt;/name&gt;\t&lt;dependencies&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.mysql&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\t\t\t&lt;scope&gt;runtime&lt;/scope&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;lombok&lt;/artifactId&gt;\t\t\t&lt;optional&gt;true&lt;/optional&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- Redis --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- 加密算法 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- mybatis-plus --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.baomidou&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.juncloud&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;juncloud-common&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\t\t\t\t&lt;version&gt;2.7.14&lt;/version&gt;\t\t\t\t&lt;executions&gt;\t\t\t\t\t&lt;execution&gt;\t\t\t\t\t\t&lt;goals&gt;\t\t\t\t\t\t\t&lt;goal&gt;repackage&lt;/goal&gt;\t\t\t\t\t\t&lt;/goals&gt;\t\t\t\t\t&lt;/execution&gt;\t\t\t\t&lt;/executions&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;\n\n（cloud-common）pom.xml （子）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;parent&gt;\t\t&lt;groupId&gt;com.juncloud&lt;/groupId&gt;\t\t&lt;artifactId&gt;juncloud&lt;/artifactId&gt;\t\t&lt;version&gt;1.0&lt;/version&gt;\t&lt;/parent&gt;\t&lt;groupId&gt;com.juncloud&lt;/groupId&gt;\t&lt;artifactId&gt;juncloud-common&lt;/artifactId&gt;\t&lt;version&gt;1.0&lt;/version&gt;\t&lt;name&gt;juncloud-common&lt;/name&gt;\t&lt;properties&gt;\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\t&lt;/properties&gt;\t&lt;dependencies&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.mysql&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\t\t\t&lt;scope&gt;runtime&lt;/scope&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- mybatis-plus --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.baomidou&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- 代码生成器 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.baomidou&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;velocity&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;lombok&lt;/artifactId&gt;\t\t\t&lt;optional&gt;true&lt;/optional&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- 邮件发送--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!--切面--&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!--常用工具类 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- io常用工具类 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;commons-io&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;commons-io&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;commons-codec&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;commons-codec&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- 加密算法 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;\n\n验证码创建CreateImageCode.java，进行绘制图片\npublic class CreateImageCode &#123;\t// 图片的宽度。\tprivate int width = 160;\t// 图片的高度。\tprivate int height = 40;\t// 验证码字符个数\tprivate int codeCount = 5;\t// 验证码干扰线数\tprivate int lineCount = 150;\t// 验证码\tprivate String code = null;\t// 验证码图片Buffer\tprivate BufferedImage bufferImg = null;\tRandom random = new Random();\t\tpublic CreateImageCode() &#123;\t\tcreatImage();\t&#125;\t\tpublic CreateImageCode(int width, int height) &#123;\t\tthis.width = width;\t\tthis.height = height;\t\tcreatImage();\t&#125;\tpublic CreateImageCode(int width, int height, int codeCount) &#123;\t\tthis.width = width;\t\tthis.height = height;\t\tthis.codeCount = codeCount;\t\tcreatImage();\t&#125;\t\tpublic CreateImageCode(int width, int height, int codeCount, int lineCount) &#123;\t\tthis.width = width;\t\tthis.height = height;\t\tthis.codeCount = codeCount;\t\tthis.lineCount = lineCount;\t\tcreatImage();\t&#125;\t\t// 生成图片\tprivate void creatImage() &#123;\t\tint fontWidth = width / codeCount;// 字体的宽度\t\tint fontHeight = height - 5;// 字体的高度\t\tint codeY = height - 8;\t\t\t\t// 图像buffer\t\tbufferImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\t\tGraphics g = bufferImg.getGraphics();\t\t// 设置背景色\t\tg.setColor(getRandColor(200, 250));\t\tg.fillRect(0, 0, width, height);\t\t// 设置字体//\t\tFont font = getFont(fontHeight);\t\tFont font = new Font(&quot;Fixedsys&quot;, Font.BOLD, fontHeight);\t\tg.setFont(font);\t\t\t\t// 设置干扰线\t\tfor (int i = 0; i &lt; lineCount; i++) &#123;\t\t\tint xs = random.nextInt(width);\t\t\tint ys = random.nextInt(height);\t\t\tint xe = xs + random.nextInt(width);\t\t\tint ye = ys + random.nextInt(height);\t\t\tg.setColor(getRandColor(1, 255));\t\t\tg.drawLine(xs, ys, xe, ye);\t\t&#125;\t\t\t\t// 添加噪点\t\tfloat yawpRate = 0.10f;// 噪声率\t\tint area = (int) (yawpRate * width * height);\t\tfor (int i = 0; i &lt; area; i++) &#123;\t\t\tint x = random.nextInt(width);\t\t\tint y = random.nextInt(height);\t\t\tbufferImg.setRGB(x, y, random.nextInt(255));\t\t&#125;\t\t\t\tString str1 = randomStr(codeCount);// 得到随机字符\t\tthis.code = str1;\t\tfor (int i = 0; i &lt; codeCount; i++) &#123;\t\t\tString strRand = str1.substring(i, i + 1);\t\t\tg.setColor(getRandColor(1, 255));\t\t\t// g.drawString(a, x, y);\t\t\t// a为要画的字，x为字的左下角的x坐标，y为字的左下角的y坐标\t\t\t\t\t\tg.drawString(strRand, i * fontWidth + 3, codeY);\t\t&#125;\t&#125;\t\t// 得到随机字符\tprivate String randomStr(int n) &#123;\t\tString str1 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;;\t\tString str2 = &quot;&quot;;\t\tint len = str1.length() - 1;\t\tdouble r;\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\tr = (Math.random()) * len;\t\t\tstr2 = str2 + str1.charAt((int) r);\t\t&#125;\t\treturn str2;\t&#125;\t\t// 得到随机颜色\tprivate Color getRandColor(int fc, int bc) &#123; // 给定范围获得随机颜色\t\tif (fc &gt; 255) fc = 255;\t\tif (bc &gt; 255) bc = 255;\t\tint r = fc + random.nextInt(bc - fc);\t\tint g = fc + random.nextInt(bc - fc);\t\tint b = fc + random.nextInt(bc - fc);\t\treturn new Color(r, g, b);\t&#125;\tprivate void shearY(Graphics g, int w1, int h1, Color color) &#123;\t\tint period = random.nextInt(40) + 10; // 50;\t\tboolean borderGap = true;\t\tint frames = 20;\t\tint phase = 7;\t\tfor (int i = 0; i &lt; h1; i++) &#123;\t\t\tdouble d = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (6.2831853071795862D * (double) phase) / (double) frames);\t\t\tg.copyArea(i, 0, 1, h1, 0, (int) d);\t\t\tif (borderGap) &#123;\t\t\t\tg.setColor(color);\t\t\t\tg.drawLine(i, (int) d, i, 0);\t\t\t\tg.drawLine(i, (int) d + h1, i, h1);\t\t\t&#125;\t\t&#125;\t&#125;\t\tpublic void write(OutputStream sos) throws IOException &#123;\t\tImageIO.write(bufferImg, &quot;png&quot;, sos);\t\tsos.close();\t&#125;\t\tpublic BufferedImage getBuffImg() &#123;\t\treturn bufferImg;\t&#125;\t\tpublic String getCode() &#123;\t\treturn code.toLowerCase();\t&#125;&#125;\n\n使用时：\n@GetMapping(&quot;/checkCode&quot;)public void checkCode(HttpServletResponse response, HttpSession session, Integer type) throws IOException &#123;    CreateImageCode createImageCode = new CreateImageCode(130, 38, 5, 20);    response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);    response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);    response.setDateHeader(&quot;Expires&quot;, 0);    response.setContentType(&quot;image/jpeg&quot;);    String code = createImageCode.getCode();    if (type == null || type == 0) &#123;        session.setAttribute(Constants.CHECK_CODE_KEY, code);    &#125; else &#123;        session.setAttribute(Constants.CHECK_CODE_KEY_EMAIL, code);    &#125;    createImageCode.write(response.getOutputStream());&#125;\n\n当我们需要验证用户传回的验证码是否正确时：（下面是一个示例）\n@PostMapping(&quot;/sendEmailCode&quot;)@GlobalInterceptor(checkParams = true)public AjaxResult sendEmailCode(HttpSession session,       @VerifyParam(required = true, regex = VeriyfRegexEnum.EMAIL, max = 150) String email,       @VerifyParam(required = true) String checkCode,       @VerifyParam(required = true) Integer type) &#123;    try &#123;        if (!checkCode.equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY_EMAIL))) &#123;            return AjaxResult.error(&quot;图片验证码不正确&quot;);        &#125;        userInfoService.sendEmailCode(email, type);    &#125; finally &#123;        session.removeAttribute(Constants.CHECK_CODE_KEY_EMAIL);    &#125;    return AjaxResult.success(&quot;发送成功&quot;);&#125;\n\naop实现参数校验引入切片依赖\n&lt;!--切面--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt;\n\n新建包annotation，在annotation包中，创建GlobalInterceptor.java\n@Target(&#123;ElementType.METHOD&#125;) // 作用在方法上@Retention(RetentionPolicy.RUNTIME) // 生命周期@Documented // 生成文档@Mappingpublic @interface GlobalInterceptor &#123;\t/**\t * 是否需要登录\t * @return\t */\tboolean checkLogin() default false;\t\t/**\t * 校验参数\t * @return\t */\tboolean checkParams() default false;\t\t/**\t * 校验频次\t */&#125;\n\n新建包aspect，在aspect包中，新建GlobalOperationAspect.java\n\n\n使用只需要在需要校验的接口添加@GlobalInterceptor即可，如下示例：\n@PostMapping(&quot;/sendEmailCode&quot;)@GlobalInterceptor(checkParams = true)public AjaxResult sendEmailCode(HttpSession session, String email, String checkCode, Integer type) &#123;    try &#123;        if (!checkCode.equalsIgnoreCase((String) session.getAttribute(Constants.CHECK_CODE_KEY_EMAIL))) &#123;            return AjaxResult.error(&quot;图片验证码不正确&quot;);        &#125;        emailCodeService.sendEmailCode(email, type);    &#125; finally &#123;        session.removeAttribute(Constants.CHECK_CODE_KEY_EMAIL);    &#125;    return AjaxResult.success(&quot;发送成功&quot;);&#125;\n\n文件上传\n分片上传\n\n@PostMapping(&quot;/uploadFile&quot;)\t@GlobalInterceptor(checkParams = true)\tpublic AjaxResult uploadFile(HttpSession session,\t\t\t\t\t\t\t\t Integer fileId,\t\t\t\t\t\t\t\t MultipartFile file,\t\t\t\t\t\t\t\t @VerifyParam(required = true) String fileName,\t\t\t\t\t\t\t\t @VerifyParam(required = true) String filePid,\t\t\t\t\t\t\t\t @VerifyParam(required = true) String fileMd5,\t\t\t\t\t\t\t\t @VerifyParam(required = true) Integer chunkIndex,\t\t\t\t\t\t\t\t @VerifyParam(required = true) Integer chunks)&#123;\t\tSessionWebUserDto webUserDto = getUserInfoFromSession(session);\t\tUploadResultDto resultDto = fileInfoService.uploadFile(webUserDto, fileId, file, fileName, filePid, fileMd5, chunkIndex, chunks);\t\treturn AjaxResult.success(resultDto);\t&#125;\n\n\n\n服务器部署前端nginxnginx配置\nserver&#123;    listen 80;    server_name junyyds.top;    index index.php index.html index.htm default.php default.htm default.html;    root /workspace/JunCloud/juncloud-ui/dist;    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则    #error_page 404/404.html;    #SSL-END    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改    #error_page 404 /404.html;    #error_page 502 /502.html;    #ERROR-PAGE-END    #PHP-INFO-START  PHP引用配置，可以注释或修改    include enable-php-00.conf;    #PHP-INFO-END    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效    include /www/server/panel/vhost/rewrite/junyyds.top.conf;    #REWRITE-END    #禁止访问的文件或目录    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.env|\\.svn|\\.project|LICENSE|README.md)    &#123;        return 404;    &#125;    #一键申请SSL证书验证目录相关设置    location ~ \\.well-known&#123;        allow all;    &#125;    #禁止在证书验证目录放入敏感文件    if ( $uri ~ &quot;^/\\.well-known/.*\\.(php|jsp|py|js|css|lua|ts|go|zip|tar\\.gz|rar|7z|sql|bak)$&quot; ) &#123;        return 403;    &#125;        location / &#123;        index  /data/dist/index.html;        try_files $uri $uri/ /index.html;    &#125;        location /api &#123;        proxy_pass http://localhost:9090/api;        proxy_set_header x-forwarded-for $remote_addr;    &#125;    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$    &#123;        expires      30d;        error_log /dev/null;        access_log /dev/null;    &#125;    location ~ .*\\.(js|css)?$    &#123;        expires      12h;        error_log /dev/null;        access_log /dev/null;    &#125;    access_log  /www/wwwlogs/junyyds.top.log;    error_log  /www/wwwlogs/junyyds.top.error.log;&#125;\n","categories":["项目"],"tags":["SpringBoot","Vue"]},{"title":"服务器","url":"/2023/06/04/%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"Linux相关命令基础知识\nLinux系统的文件结构\n\n/bin        二进制文件，系统常规命令/boot       系统启动分区，系统启动时读取的文件/dev        设备文件/etc        大多数配置文件/home       普通用户的家目录/lib        32位函数库/lib64      64位库/media      手动临时挂载点/mnt        手动临时挂载点/opt        第三方软件安装位置/proc       进程信息及硬件信息/root       临时设备的默认挂载点/sbin       系统管理命令/srv        数据/var        数据/sys        内核相关信息/tmp        临时文件/usr        用户相关设定\n\n\nLinux系统命令行的含义\n\n示例：root@app00:~# root    //用户名，root为超级用户@       //分隔符app00   //主机名称~     //当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下）#     //表示当前用户是超级用户，普通用户为$，例如：（&quot;yao@app00:/root$&quot; ，表示使用用户&quot;yao&quot;访问/root文件夹）\n\n\n命令组成\n\n示例：命令 参数名 参数值\n\n基础操作\n重启系统\n\n(1)立刻关机shutdown -h now 或者 poweroff(2)两分钟后关机shutdown -h 2\n\n\n关闭系统\n\n(1)立刻重启shutdown -r now 或者 reboot(2)两分钟后重启shutdown -r 2 \n\n\n帮助命令（help）\n\nifconfig  --help     //查看 ifconfig 命令的用法\n\n\n命令说明书（man）\n\nman shutdown         //打开命令说明后，可按&quot;q&quot;键退出\n\n\n切换用户（su）\n\nsu yao               //切换为用户&quot;yao&quot;,输入后回车需要输入该用户的密码exit                 //退出当前用户\n\n目录操作\n切换目录（cd）\ncd /                 //切换到根目录cd /bin              //切换到根目录下的bin目录cd ../               //切换到上一级目录 或者使用命令：cd ..cd ~                 //切换到home目录cd -                 //切换到上次访问的目录cd xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错cd /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全\n\n查看目录（ls）\nls                   //查看当前目录下的所有目录和文件ls -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）ls -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令&quot;ll&quot;效果一样ls /bin              //查看指定目录下的所有目录和文件 \n\n创建目录（mkdir）\nmkdir tools          //在当前目录下创建一个名为tools的目录mkdir /bin/tools     //在指定目录下创建一个名为tools的目录\n\n删除目录与文件（rm）\nrm tools          //删除一个名为tools的目录\n\n修改目录（mv）\nmv 当前目录名 新目录名        //修改目录名，同样适用与文件操作mv /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面mv -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹\n\n拷贝目录（cp）\ncp /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面cp -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹\n\n搜索目录（find）\nfind /bin -name &#x27;a*&#x27;        //查找/bin目录下的所有以a开头的文件或者目录\n\n查看当前目录（pwd）\npwd                         //显示当前位置路径\n\n文件操作\n新增文件（touch）\ntouch  a.txt  //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间\n\n删除文件（rm）\nrm 文件名              //删除当前目录下的文件rm -f 文件名           //删除当前目录的的文件（不询问）\n\n编辑文件（vi、vim）\n\n\n   vi 文件名              //打开需要编辑的文件--进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）命令模式-刚进入文件就是命令模式，通过方向键控制光标位置，-使用命令&quot;dd&quot;删除当前整行-使用命令&quot;/字段&quot;进行查找-按&quot;i&quot;在光标所在字符前开始插入-按&quot;a&quot;在光标所在字符后开始插入-按&quot;o&quot;在光标所在行的下面另起一新行插入-按&quot;：&quot;进入底行模式插入模式-此时可以对文件内容进行编辑，左下角会显示 &quot;-- 插入 --&quot;&quot;-按&quot;ESC&quot;进入底行模式底行模式-退出编辑：      :q-强制退出：      :q!-保存并退出：    :wq## 操作步骤示例 ##1.保存文件：按&quot;ESC&quot; -&gt; 输入&quot;:&quot; -&gt; 输入&quot;wq&quot;,回车     //保存并退出编辑2.取消操作：按&quot;ESC&quot; -&gt; 输入&quot;:&quot; -&gt; 输入&quot;q!&quot;,回车     //撤销本次修改并退出编辑## 补充 ##vim +10 filename.txt                   //打开文件并跳到第10行vim -R /etc/passwd                     //以只读模式打开文件\n\n\n查看文件\ncat a.txt          //查看文件最后一屏内容less a.txt         //PgUp向上翻页，PgDn向下翻页，&quot;q&quot;退出查看more a.txt         //显示百分比，回车查看下一行，空格查看下一页，&quot;q&quot;退出查看tail -100 a.txt    //查看文件的后100行，&quot;Ctrl+C&quot;退出查看\n\n文件权限。。。\n打包与解压\n说明\n   .zip、.rar        //windows系统中压缩文件的扩展名   .tar              //Linux中打包文件的扩展名   .gz               //Linux中压缩文件的扩展名   .tar.gz           //Linux中打包并压缩文件的扩展名2.  打包文件   ~~~bash   tar -zcvf 打包压缩后的文件名 要打包的文件   参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;   示例：   tar -zcvf a.tar file1 file2,...      //多个文件压缩打包\n解压文件\ntar -zxvf a.tar                      //解包至当前目录tar -zxvf a.tar -C /usr------        //指定解压的位置unzip test.zip             //解压*.zip文件 unzip -l test.zip          //查看*.zip文件的内容\n\n其他常用命令🏎️🛵🛴🚲🏍️\n系统管理\n防火墙操作\nservice iptables status      //查看iptables服务的状态service iptables start       //开启iptables服务service iptables stop        //停止iptables服务service iptables restart     //重启iptables服务chkconfig iptables off       //关闭iptables服务的开机自启动chkconfig iptables on        //开启iptables服务的开机自启动##centos7 防火墙操作systemctl status firewalld.service     //查看防火墙状态systemctl stop firewalld.service       //关闭运行的防火墙systemctl disable firewalld.service    //永久禁止防火墙服务\n\n修改主机名（CentOS 7）\nhostnamectl set-hostname 主机名\n查看网络\nifconfig\n\n修改IP\n修改网络配置文件，文件地址：/etc/sysconfig/network-scripts/ifcfg-eth0------------------------------------------------主要修改以下配置：  TYPE=Ethernet               //网络类型BOOTPROTO=static            //静态IPDEVICE=ens00                //网卡名IPADDR=192.168.1.100        //设置的IPNETMASK=255.255.255.0       //子网掩码GATEWAY=192.168.1.1         //网关DNS1=192.168.1.1            //DNSDNS2=8.8.8.8                //备用DNSONBOOT=yes                  //系统启动时启动此设置-------------------------------------------------修改保存以后使用命令重启网卡：service network restart\n配置映射\n修改文件： vi /etc/hosts在文件最后添加映射地址，示例如下：192.168.1.101  node1192.168.1.102  node2192.168.1.103  node3配置好以后保存退出，输入命令：ping node1 ，可见实际 ping 的是 192.168.1.101。\n\n查看进程\n\n\n   ps -ef         //查看所有正在运行的进程ps -ef | grep xxxx\n   ps -ef : 查看本机所有的进程； \n   grep xxxx代表过滤找到条件xxxx的进程7. 结束进程\n   kill pid       //杀死该pid的进程kill -9 pid    //强制杀死该进程   \n\n查看链接\nping IP        //查看与此IP地址的连接情况netstat -an    //查看当前系统端口netstat -an | grep 8080     //查看指定端口\n快速清屏\nctrl+l        //清屏，往上翻可以查看历史操作\n远程主机\n\n\nssh IP       //远程主机，需要输入用户名和密码\n\nUbuntu初始化初始化配置# 设置root密码sudo passwd root# 设定静态IPsudo nano /etc/netplan/50-cloud-init.yaml在文件中找到下面这行代码：dhcp4: true将其替换为以下内容：dhcp4: falseaddresses: [IP地址/子网掩码]gateway4: 网关地址nameservers:  addresses: [DNS服务器地址]例如：dhcp4: falseaddresses: [192.168.0.100/24]gateway4: 192.168.0.1nameservers:  addresses: [8.8.8.8]保存并退出，运行以下命令来应用配置并重启网络服务：sudo netplan applysudo systemctl restart networking\n\n远程访问主机\nsudo apt updatesudo apt install openssh-server\n\n安装完成后，请确保 OpenSSH 服务器已启动。通过运行以下命令来检查它的状态：\nsudo systemctl status ssh\n\n如果 OpenSSH 服务器尚未启动，通过运行以下命令来启动它：\nsudo systemctl start ssh\n\n设定 OpenSSH 服务器随系统启动而自动启动，运行以下命令：\nsudo systemctl enable ssh\n\n换源（Ubuntu 24.04 LTS版本之前）\n首先，打开终端并运行以下命令来备份源列表文件：\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n\n然后，运行以下命令来打开源列表文件：\nsudo gedit /etc/apt/sources.list\n\n在文件中，删除原来的内容，并粘贴以下内容：\ndeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy main restricteddeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-updates main restricteddeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy universedeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-updates universedeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy multiversedeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-updates multiversedeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-backports main restricted universe multiversedeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-security main restricteddeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-security universedeb http://mirrors.cloud.aliyuncs.com/ubuntu jammy-security multiverse\n\n保存文件并退出。\n最后，运行以下命令来更新源列表：\nsudo apt update\n\n也可以通过运行以下命令来恢复备份的源列表文件：\nsudo mv /etc/apt/sources.list.bak /etc/apt/sources.listsudo apt update\n\n换源（Ubuntu 24.04 LTS）\n24.04LTS 后，apt源source.list的位置替换到了/etc/apt/sources.list.d/ubuntu.sources中\n1.备份源文件\nsudo cp /etc/apt/sources.list.d/ubuntu.sources  /etc/apt/sources.list.d/ubuntu.sources.bak\n\n\n编辑源地址\n\nsudo vim /etc/apt/sources.list.d/ubuntu.sources\n\n\n填入阿里云镜像\n\n# 阿里云Types: debURIs: http://mirrors.aliyun.com/ubuntu/Suites: noble noble-updates noble-securityComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg\n\n\n更新源列表\n\nsudo apt-get update\n\n\n更新系统软件包，输入以下命令：\n\nsudo apt-get upgrade\n\n其他几份国内源如下：\n清华源\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释Types: debURIs: http://mirrors.tuna.tsinghua.edu.cn/ubuntu/Suites: noble noble-updates noble-securityComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg\n\n中科大源\nTypes: debURIs: http://mirrors.ustc.edu.cn/ubuntu/Suites: noble noble-updates noble-securityComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg\n\n网易163源\nTypes: debURIs: http://mirrors.163.com/ubuntu/Suites: noble noble-updates noble-securityComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg\n\n\n\n设置主机名称\n默认主机的 hostname 都是随机生成，不方便识别，这里以 ubuntu-study 为实例作为主机名进行设置。\nsudo hostnamectl set-hostname ubuntu-study # 设置主机名sudo hostnamectl # 查看主机名\n\n\n设置完成之后，需要退出终端重新登录就可以看到自定义主机名。\n\n终端配色终端配色\n为了设置终端颜色，需要对 ~/.bashrc 文件中的 PS1 变量进行定制，值得注意的是这个修改仅对当前用户生效。\necho &quot;# 终端配色export export PS1=&#x27;\\[\\033[01;33m\\]\\u@\\h\\[\\033[01;31m\\] \\W\\$\\[\\033[00m\\] &#x27;&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc\n\n配置完成后，终端配色如下\n\n添加必要系统工具\n安装 vim 编辑器、网络请求 wget、curl以及压缩与解压缩软件等。\nsudo apt-get install -y \\  vim \\  wget \\  curl \\  cmake \\  g++ \\  tree \\  git \\  zip \\  unzip\n\n设置时区\n将服务器的时区设置为中国地区。\nsudo timedatectl set-timezone Asia/Shanghaisudo timedatectl set-local-rtc 0sudo timedatectl set-ntp 1\n\n配置默认的编辑器\nUbuntu 系统默认的文件编辑器是 nano 而不是 Vim，那么怎么设置成 Vim 呢？\n执行下面的命令选择将 Vim 设置为服务器默认的编辑器。\nsudo update-alternatives --config editor\n\n常用工具vm-tools当使用vm虚拟机使用ubuntu时，需要安装vm-tools\n# vm的工具sudo apt -y install open-vm-tools# 安装下面的，可以让我们在主机与虚拟机之间复制粘贴sudo apt -y install open-vm-tools-desktop\n\n软件中心sudo apt install plasma-discover\n\n\n\n安装与卸载.deb文件安装\n\n使用默认的软件中心\n\n在命令行中使用dpkg安装.deb文件\n# 如果你想对 deb 文件使用 apt 命令，像这样使用它:sudo apt install path_to_deb_file# 如果你想对将要安装的 deb 软件包使用 dpkg 命令:sudo dpkg -i path_to_deb_file# 如果你在安装 deb 软件包的过程中得到一个依赖项的错误，你可以使用下面的命令来修复依赖项的问题：sudo apt install -f\n\n卸载\n\n使用apt命令移除deb软件包\nsudo apt remove program_name# 如果不知道安装程序的`program_name`sudo apt list --installed | grep xxx\n\n使用dpkg命令移除deb软件包\n# 你可以使用 dpkg 来找到已安装程序的名称：dpkg -l | grep edge\n\nii  microsoft-edge-stable                      116.0.1938.81-1                         amd64        The web browser from Microsoft\n\n在上面的命令输出中的 ii 意味着软件包已经被正确地安装。现在，你有了程序名称，你可以使用 dpkg 命令来移除它：\ndpkg -r program_name\n\n\nCentOS初始化下面以CentOS7 为例，进行初始化相关配置:\n换源# 首先对默认的软件源进行备份mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup# 进入 yum 源文件夹cd /etc/yum.repos.d/# 这里以CentOS7为例wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # 如果wget命令不生效，说明还没有安装wget工具，输入yum -y install wget 回车进行安装，或者使用curl -O http://mirrors.aliyun.com/repo/Centos-7.repo # 清理并重建缓存sudo yum clean allsudo yum makecache# 验证更新sudo yum update\n\n常用软件安装\n如果使用的最小化安装，常用的工具我们需要手动进行安装\n\nyum install -y vim wget curl epel-release gcc net-tools ntpdate psmisc unzip# Tab补全yum install bash-completion\n\n关闭防火墙(可选)systemctl stop firewalldsystemctl disable firewalld\n\nWindows与Linux传输文件使用scp命令\nscp C://Windows文件.txt root@192.168.10.131:/home/Linux文件位置\n\n\n\n环境搭建1Panel面版我们可以通过安装可视化运维1Panel面版，方便常见的操作\n下面前往官网地址：在线安装 - 1Panel 文档 在安装部署选择自己的系统\nJDK安装\n下载 JDK 或将提前下载好的安装文件上传至 /opt/software\n前往Java Downloads | Oracle，选择jdk-8u451-linux-i586.tar.gz 进行下载\n\n解压\nmkdir /opt/moduletar -zxvf jdk-8u451-linux-i586.tar.gz -C /opt/module\n\n修改 /etc/profile，设置环境变量\n# 此处JAVA_HOME为你下载的版本，在/opt/module 目录下export JAVA_HOME=/opt/module/jdk1.8.0_451export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib\n\n刷新环境\nsource /etc/profile\n\n验证环境\njava -version# 如果报错：-bash: /opt/module/jdk1.8.0_451/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录 sudo yum install glibc.i686 # 安装完成后再次测试\n\nMaven安装前往官网下载 Apache Maven安装包，官方下载地址：https://maven.apache.org/download.cgi\n\n解压下载的 Maven 安装包\n# 我将安装包放到了 /opt/software 目录下，执行解压，解压到 /opt/moduletar -zxvf apache-maven-3.9.9-bin.tar.gz -C /opt/module注意：apache-maven-3.6.3-bin.tar.gz是我下载的安装包名称，请修改为你下载的安装包名称。\n\n设置Maven 国内镜像地址（这里采用阿里云）\n找到Maven文件夹下的conf文件夹（我目录为：&#x2F;opt&#x2F;module&#x2F;apache-maven-3.9.9&#x2F;conf）编辑settings.xml文件，添加如下代码\n&lt;mirror&gt;     &lt;id&gt;alimaven&lt;/id&gt;     &lt;name&gt;aliyun maven&lt;/name&gt;     &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;\n\n设置 Maven 本地仓库文件目录（主要用于保存下载的jar文件）\n首先确定jar保存在哪里（我保存的目录为：&#x2F;opt&#x2F;module&#x2F;apache-maven-3.9.9&#x2F;LocalJAR  ）可以通过mkdir 命令创建文件目录，建议保存在Maven目录下），编辑settings.xml配置文件，添加如下代码：\n&lt;localRepository&gt;/opt/module/apache-maven-3.9.9/LocalJAR&lt;/localRepository&gt;\n\n指定JDK版本（设置Maven创建的工程的JDK版本）\n添加如下代码：\n&lt;profile&gt;  &lt;id&gt;jdk-1.8&lt;/id&gt;  &lt;activation&gt;    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;    &lt;jdk&gt;1.8&lt;/jdk&gt;  &lt;/activation&gt;  &lt;properties&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;  &lt;/properties&gt;&lt;/profile&gt;\n\n最终删除注释整个配置如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;&gt;\t&lt;localRepository&gt;/opt/module/apache-maven-3.9.9/LocalJAR&lt;/localRepository&gt;\t&lt;pluginGroups&gt;\t&lt;/pluginGroups&gt;\t&lt;proxies&gt;\t&lt;/proxies&gt;\t&lt;servers&gt;\t&lt;/servers&gt;\t&lt;mirrors&gt;\t\t&lt;mirror&gt;\t\t\t&lt;id&gt;alimaven&lt;/id&gt;\t\t\t&lt;name&gt;aliyun maven&lt;/name&gt;\t\t\t&lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\t\t\t&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\t\t&lt;/mirror&gt;\t&lt;/mirrors&gt;\t&lt;profiles&gt;\t\t&lt;profile&gt;\t\t\t&lt;id&gt;jdk-1.8&lt;/id&gt;\t\t\t&lt;activation&gt;\t\t\t\t&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\t\t\t\t&lt;jdk&gt;1.8&lt;/jdk&gt;\t\t\t&lt;/activation&gt;\t\t\t&lt;properties&gt;\t\t\t\t&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\t\t\t\t&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\t\t\t\t&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;\t\t\t&lt;/properties&gt;\t\t&lt;/profile&gt;\t&lt;/profiles&gt;&lt;/settings&gt;\n\n配置Maven环境变量\n打开环境变量配置文件命令：vim /etc/profile，添加如下代码在最后：\nexport MAVEN_HOME=/opt/module/apache-maven-3.9.9\t\t（这是我的maven路径，请查看你们具体路径）export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin\n\n重新加载配置文件\nsource /etc/profile\n\n查看是否安装成功\nmvn -v\n\n项目构建java项目达成jar包\nmvn clean package\n\n运行jar包\njava -jar demoa.jar\n\n后台运行\nnohup java -jar demo.jar &gt;temp.txt &amp;\n\n可通过jobs查看后台任务\nVue项目vue3使用Router的history模式，nginx其他页面报错：\nlocation / &#123;    index  /data/dist/index.html;    try_files $uri $uri/ /index.html;  &#125;\n\ndocker一键部署\nJava项目\n\n将打完包jar包的文件（例如：tem-1.0.jar）放在服务器目标目录下，新建两个文件：Dockerfile、start.sh，格式如下：\nDockerfile\n# 基于指定版本的Java镜像FROM openjdk:8# 添加Java应用的JAR包到容器中ADD tem-1.0.jar /app.jar# 暴露应用端口EXPOSE 8080# 运行jar包ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;,&quot;--spring.profiles.active=prod&quot;]\n\nstart.sh\ndocker stop temdocker rm temdocker build -t tem .docker run -d -p 8080:8080 -v /etc/localtime:/etc/localtime:ro -e TZ=Asia/Shanghai --network=host --name tem temdocker cp /usr/share/fonts/ tem:/usr/share/\n\n保证目标目录下存放了：要运行的项目jar包、Dockerfile、start.sh，添加start.sh可执行权限\nchmod u+x start.sh\n\n运行脚本即可一键将java项目打包docker镜像并运行：\n./start.sh\n\n\n前端工程项目\n\n准备好前端工程已生成好的dist文件夹，一般进行压缩上传dist.zip、default.confnginx配置文件、Dockerfile、start.sh\ndefault.conf：针对后端接口的nginx配置\nupstream backend &#123;\tserver 127.0.0.1:8080; #后端项目的api访问地址&#125;client_max_body_size 600M;proxy_connect_timeout 300s;proxy_read_timeout 300s;server &#123;    listen       9090;    listen  [::]:9090;    server_name  localhost;    location / &#123;        root   /usr/share/nginx/html;        try_files $uri $uri/ /index.html;        index  index.html index.htm;    &#125;\t   location ^~/api &#123;\t\tproxy_set_header Host $http_host;\t\tproxy_set_header X-Real-IP $remote_addr;\t\tproxy_set_header REMOTE-HOST $remote_addr;\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t\tproxy_pass http://127.0.0.1:8080/;   &#125;       error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;&#125;\n\nDockerfile\n# 指定nginx版本FROM nginx:1.26# 添加作者说明MAINTAINER wwj# 删除镜像中的default.conf文件RUN rm /etc/nginx/conf.d/default.conf# 将项目的default.conf复制到/etc/nginx/conf.d/ADD default.conf /etc/nginx/conf.d/# 将项目的dist文件夹下的所有文件复制到镜像/usr/share/nginx/html/目录下COPY dist/ /usr/share/nginx/html/\n\nstart.sh\nrm -rf distunzip dist.zipdocker stop tem-frontdocker rm tem-frontdocker build -t tem-front .docker run -d -p 9090:9090 -v /etc/localtime:/etc/localtime:ro -e TZ=Asia/Shanghai --network=host  --name tem-front tem-front\n\n若依框架实战RuoYi-Vue: 🎉前后端分离权限管理系统(gitee.com)\n搭建好Mysql、redis，将文件中的SQL导入数据库，在application.yml中配置好数据据ip地址\n将后端打包为jar包：\nmvn clean package\n\n或者使用IDEA的Maven\n\n打包成功后，将jar包复制到服务器，使用：\njava -jar ruoyi-vue.jar\n\n前端使用生成模式打包\nnpm run build:prod\n\n将打包后的dist放到服务器\nnginx配置在ngiex进行配置修改：\nserver    &#123;        listen 80;        server_name ry-vue;        index index.html index.htm index.php;        root /workspace/ui/dist;\t\tlocation /prod-api/ &#123;            proxy_set_header Host $http_host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header REMOTE-HOST $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http://ip:8080/;        &#125;    &#125;\n\n./nginx -s -reload   #重启nginx\n\n\n配置nginx让他负载均衡转发\n\nupstream ruoyi&#123;    server 192.168.109.102:8080 weight=5; #weight为权重，权重越高，请求的服务更多    server 192.168.109.103:8080 weight=3;&#125;server &#123;    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / &#123;        root   /workspace/dist;        index  index.html index.htm;    &#125;    location /prod-api/ &#123;        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header REMOTE-HOST $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://ruoyi/;    &#125;\n\n\n静态资源404\n\n在nginx配置后端接口，加上^~\nlocation ^~ /api/ &#123;\tproxy_pass http://localhost:9090/api/;&#125;\n\n在Windows中安装nginx从官网进行下载：nginx，下载后放到一个没有空格，没有中文的目录下：\n\n在此处，进入cmd：输入命令 nginx.exe，即可启动，如果没有报错，及启动正常，\n关闭nginx，关闭当前的命令行窗口，nginx不会停止，关闭有两种方式：\n\n在cmd中输入：nginx.exe -s stop 即可关闭\n在任务管理器中进行关闭：\n\n\n服务器配置代理需要准备3个文件：\n\n先下载对应版本的clash clash-linux-amd64-v1.17.0.gz\n\n在windows中打开clash，打开配置文件所在的文件夹，将配置文件复制出来改名为config.yml\n\n\n\n\n\n在上一级目录中，复制Country.mmdb\n\n\n将准备好的三个文件放到新建文件夹clash中，上传到服务器 /opt中，进入/opt/clash\n\n# 解压文件gunzip clash-linux-amd64-v1.17.0.gz# 重命名为clash 赋予权限mv clash-linux-amd64-v1.17.0 clashchmod +x clash执行 ./clash --help 进行测试，如果执行失败，说明下载错了版本，需重新下载对应版本./clash --help\n\n将clash设为守护进程\n键入cd /etc/systemd/system然后vim clash.service 文件内容如下，直接复制粘贴即可(按i进入插入模式，然后shift+Insert粘贴)，然后退出保存(ESC + :wq)\n\n[Unit]Description=clash-core[Service]Type=simpleExecStart=/opt/clash/clash -f /opt/clash/config.yml -d /opt/clash/[Install]WantedBy=multi-user.target\n\n在终端中启用clash#可将下面两行放入~&#x2F;.bashrc中，否则仅对当次终端有效。\n针对当前用户vim ~/.bashrc针对所有用户vim /etc/profileexport http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot;修改后可以使用命令使其立即生效source ~/.bashrc\n\n#可将下面两行放入~/.bashrc中，否则仅对当次终端有效。export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot;#查看环境变量export#启动clashsystemctl daemon-reloadsystemctl start clash#把clash设为开机自启systemctl enable clash.service#检查是否开机自启systemctl is-enabled clash.service\n\n测试\ncurl -i google.com\n\n关闭clash\n#终止clash服务systemctl stop clash#关闭开机自启systemctl disable clash#删除设置的环境变量unset http_proxyunset https_proxy\n\n\n\n搭建VsCode Web安装code-server，可以从GitHub网址进行选择https://github.com/coder/code-server，如果是linux， amd的可以直接点击下面的链接进行下载：code-server-4.16.1-linux-amd64.tar.gz\n在服务器宝塔安装Node.js版本管理器\n将下载的压缩包复制到路径/www/wwwroot/下，重名为code_server，添加node项目，启动选择的命令选择自定义\n/www/wwwroot/code_server/bin/code-server --port 9999 --host 0.0.0.0 --auth password\n\n\nJupyter安装 Anaconda下载Anaconda最新安装程序 https://www.anaconda.com/products/i\nwget https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh\n\n运行安装程序:\nsh Anaconda3-2021.05-Linux-x86_64.sh\n\n安装过程中敲回车和输入yes同意许可即可\n安装完成重新登录即可\n搭建环境\n安装jupyter包\n\nconda install jupyter \n\n\n生成默认配置文件\n\njupyter notebook --generate-config --allow-root\n\n\n随后我们往配置文件写入一些内容\n\n# 设置可以访问的ip, 默认是localhost, 将其改为 &#x27;*&#x27;c.NotebookApp.ip = &#x27;*&#x27;# 笔记本的默认打开目录, 自己设置c.NotebookApp.notebook_dir = &#x27;/home/jupyter/documents/jupyter_notebook&#x27;# 笔记本启动后是否打开浏览器, 设为 False即可c.NotebookApp.open_browser = False# 默认访问端口, 可自己修改c.NotebookApp.port = 9999# jupyterlab是否显示quit按钮,我设为false以免自己不小心按到把服务停了c.NotebookApp.quit_button = true# 如果使用root用户运行,将下列值改为True即可, 运行时也可加参数将其改为Truec.NotebookApp.allow_root = False\n\n\n设置密码\n\njupyter notebook password\n\n\n修改好配置文件之后, 运行如下命令启动笔记本\n\njupyter notebook\n\n后台运行nohup jupyter notebook --no-browser --ip=0.0.0.0 --allow-root &amp;\n\n用&amp;让命令后台运行, 并把标准输出写入jupyter.log中\nnohup表示no hang up, 就是不挂起, 这个命令执行后即使终端退出, Jupyter也不会停止运行.\n关闭后台运行的Jupyter\n找到Jupyter进程PID(关闭在前面后台执行的进程的步骤，首先找到其进程PID)\n\nps -ef | grep xxxx\n\nps -ef : 查看本机所有的进程；grep xxxx代表过滤找到条件xxxx的进程\n\nkill掉Jupyter进程\n\nkill -9  PID\n\nkill -9 具体的进程的PID\nMinio对象存储搭建可以通过直接在Linux安装，或者通过Docker安装（推荐）\n在docker中安装拉取并运行mino，将网页控制台与Api接口的端口的9000，9001映射出来，其中的MINIO_ROOT_USER与MINIO_ROOT_PASSWORD为网页登录的用户名与密码。将主机的 /home/data 目录映射到容器的 /data 目录，存储的文件保存到本机的/home/data中，主机的 /home/config 目录映射到容器的 /root/.minio 目录。自处minio/minio:RELEASE.2025-04-22T22-12-26Z 为最新版带有管理端版本的Minio，最新版为社区版，不带管理端的版本为minio/minio\n# 拉取镜像docker pull minio/minio:RELEASE.2025-04-22T22-12-26Z# 启动服务docker run -d -p 9000:9000 -p 9001:9001 \\--name minio \\--restart=always \\-v /data/minio:/data \\-e &quot;MINIO_ROOT_USER=minioadmin&quot; \\-e &quot;MINIO_ROOT_PASSWORD=minioadmin&quot; \\-v /home/config:/root/.minio \\minio/minio:RELEASE.2025-04-22T22-12-26Z server /data --console-address &quot;:9001&quot;\n\n启动：ip:9000，进入控制台Web，输入刚才设置的用户名与密码\n\n创建新的密钥，也就是创建一个用户，分配为管理员，方便下面进行读写：\n\n在SpringBoot中使用配置依赖\n&lt;!-- minio --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.minio&lt;/groupId&gt;    &lt;artifactId&gt;minio&lt;/artifactId&gt;    &lt;version&gt;8.3.7&lt;/version&gt;&lt;/dependency&gt;\n\n在application.yml中配置\nminio:  # 访问的url  endpoint: http://192.168.10.100  # API的端口  port: 9001  # 密钥  accessKey:   secretKey:   secure: false  bucket-name: picture # 桶名  image-size: 10455760    # 图片文件最大为10M  file-size: 1073741824   # 文件最大为1G\n\n需在包config下新建类\nimport io.minio.MinioClient;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @version: java version 1.8 * @Author: WWJ * @description: * @date: 2023-02-21 22:20 */@Data@Configuration@ConfigurationProperties(prefix = &quot;minio&quot;)public class MyMinioProperties &#123;    private String endpoint;    private Integer port;    private String accessKey;    private String secretKey;    private boolean secure;    private String bucketName;    private long imageSize;    private long fileSize;    @Bean    public MinioClient minioClient() &#123;        MinioClient minioClient = MinioClient.builder()                .credentials(accessKey, secretKey)                .endpoint(endpoint, port, secure)                .build();        return minioClient;    &#125;&#125;\n\n使用文件处理的工具类\npackage com.rongmei.mushroomProject.utils;import com.rongmei.mushroomProject.config.MyMinioProperties;import io.minio.*;import io.minio.errors.ErrorResponseException;import io.minio.errors.InsufficientDataException;import io.minio.errors.InvalidResponseException;import io.minio.errors.XmlParserException;import io.minio.http.Method;import io.minio.messages.Bucket;import io.minio.messages.Item;import org.apache.commons.io.FilenameUtils;import org.springframework.stereotype.Component;import org.springframework.util.FastByteArrayOutputStream;import org.springframework.web.multipart.MultipartFile;import javax.annotation.Resource;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.security.NoSuchAlgorithmException;import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * @version: java version 1.8 * @Author: WWJ * @description: * @date: 2023-02-21 22:33 */@Componentpublic class MinioUtil &#123;    @Resource    private MyMinioProperties prop;    @Resource    private MinioClient minioClient;    /**     * 查看存储bucket是否存在     *     * @return boolean     */    public Boolean bucketExists(String bucketName) &#123;        Boolean found;        try &#123;            found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;        return found;    &#125;    /**     * 创建存储bucket     *     * @return Boolean     */    public Boolean makeBucket(String bucketName) &#123;        try &#123;            minioClient.makeBucket(MakeBucketArgs.builder()                    .bucket(bucketName)                    .build());        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;        return true;    &#125;    /**     * 删除存储bucket     *     * @return Boolean     */    public Boolean removeBucket(String bucketName) &#123;        try &#123;            minioClient.removeBucket(RemoveBucketArgs.builder()                    .bucket(bucketName)                    .build());        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;        return true;    &#125;    /**     * 获取全部bucket     */    public List&lt;Bucket&gt; getAllBuckets() &#123;        try &#123;            List&lt;Bucket&gt; buckets = minioClient.listBuckets();            return buckets;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 文件上传     *     * @param file 文件     * @return Boolean     */    public String upload(MultipartFile file) &#123;        if (file.isEmpty()) &#123;            throw new RuntimeException();        &#125;        String originalFilename = file.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);        String ext = &quot;.&quot; + FilenameUtils.getExtension(originalFilename);        String fileName = uuid + ext;        try &#123;            PutObjectArgs objectArgs = PutObjectArgs.builder().bucket(prop.getBucketName()).object(fileName)                    .stream(file.getInputStream(), file.getSize(), -1).contentType(file.getContentType()).build();            //文件名称相同会覆盖            minioClient.putObject(objectArgs);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;        return fileName;    &#125;    /**     * 预览图片     *     * @param fileName     * @return     */    public String preview(String fileName) &#123;        // 查看文件地址        GetPresignedObjectUrlArgs build = new GetPresignedObjectUrlArgs().builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build();        try &#123;            String url = minioClient.getPresignedObjectUrl(build);            return url;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 文件下载     *     * @param fileName 文件名称     * @param res      response     * @return Boolean     */    public void download(String fileName, HttpServletResponse res) &#123;        GetObjectArgs objectArgs = GetObjectArgs.builder().bucket(prop.getBucketName())                .object(fileName).build();        try (GetObjectResponse response = minioClient.getObject(objectArgs)) &#123;            byte[] buf = new byte[1024];            int len;            try (FastByteArrayOutputStream os = new FastByteArrayOutputStream()) &#123;                while ((len = response.read(buf)) != -1) &#123;                    os.write(buf, 0, len);                &#125;                os.flush();                byte[] bytes = os.toByteArray();                res.setCharacterEncoding(&quot;utf-8&quot;);                // 设置强制下载不打开                // res.setContentType(&quot;application/force-download&quot;);                res.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);                try (ServletOutputStream stream = res.getOutputStream()) &#123;                    stream.write(bytes);                    stream.flush();                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 查看文件对象     *     * @return 存储bucket内文件对象信息     */    public List&lt;Item&gt; listObjects() &#123;        Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(                ListObjectsArgs.builder().bucket(prop.getBucketName()).build());        List&lt;Item&gt; items = new ArrayList&lt;&gt;();        try &#123;            for (Result&lt;Item&gt; result : results) &#123;                items.add(result.get());            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;        return items;    &#125;    /**     * 获取路径下文件列表     *     * @param prefix     文件名称     * @param recursive  是否递归查找，如果是false,就模拟文件夹结构查找     * @return 二进制流     */    public Iterable&lt;Result&lt;Item&gt;&gt; listObjects(String prefix, boolean recursive) &#123;        return minioClient.listObjects(ListObjectsArgs.builder().bucket(prop.getBucketName()).prefix(prefix).recursive(recursive).build());    &#125;    /**     * 删除     *     * @param fileName     * @return     * @throws Exception     */    public boolean remove(String fileName) &#123;        try &#123;            minioClient.removeObject(RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build());        &#125; catch (Exception e) &#123;            return false;        &#125;        return true;    &#125;&#125;\n\n在controller层即可调用工具类\n上传对象\n\n// 获取桶内所有图片URL    @GetMapping(&quot;/find&quot;)    public List&lt;ObjectDTO&gt; findAll(@RequestParam(defaultValue = &quot;&quot;) String filename) throws IOException, InvalidKeyException, InvalidResponseException, InsufficientDataException, NoSuchAlgorithmException, ServerException, InternalException, XmlParserException, ErrorResponseException &#123;        ArrayList&lt;ObjectDTO&gt; objectDTOS = new ArrayList&lt;&gt;();        Iterable&lt;Result&lt;Item&gt;&gt; results = minioUtil.listObjects(filename, true);        for (Result&lt;Item&gt; result: results) &#123;            String fileName = result.get().objectName();            String address = minioUtil.preview(fileName);            String url = StringUtils.substringBefore(address, &quot;?&quot;);            ObjectDTO objectDTO = new ObjectDTO(fileName, url);            objectDTOS.add(objectDTO);        &#125;        return objectDTOS;    &#125;\n","categories":["服务器"],"tags":["Linux","对象存储"]},{"title":"深度学习","url":"/2023/05/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","content":"流程\n数据处理\n读入数据\n划分数据集\n生成批次数据\n训练样本集乱序\n校验数据有效性\n\n\n模型设计\n网络结构\n损失函数\n\n\n训练配置\n优化算法\n随机梯度下降（SGD）：随机梯度下降算法，每次训练少量数据，抽样偏差导致参数收敛过程中震荡。\n动量（Momentum）：引入物理“动量”的概念，累积速度，减少震荡，使参数更新的方向更稳定。\nAdaGrad： 根据不同参数距离最优解的远近，动态调整学习率。学习率逐渐下降，依据各参数变化大小调整学习率。\nAdam： 由于动量和自适应学习率两个优化思路是正交的，因此可以将两个思路结合起来，这就是当前广泛应用的算法。\n\n\n设置学习率\n\n\n\npycharmconda 环境\n新建环境\n\nconda create -n yourEnv python=3.10\n\n\n–name：也可以缩写为 【-n】，【yourEnv】是新创建的虚拟环境的名字，创建完，可以装 anaconda 的目录下找到 envs&#x2F;yourEnv 目录\npython&#x3D;2.7：是 python 的版本号。也可以指定为【python&#x3D;3.6】，若未指定，默认为是装 anaconda 时 python 的版本.\n\n\n激活环境\n\nactivate yourEnv\n\n\nwindows 用户环境变量中添加（改成自己的路径）：\n\nD:\\Anaconda3D:\\Anaconda3\\ScriptsD:\\Anaconda3\\Library\\bin\n\n\n\n\n查看活跃的环境\n\nconda info --envs\n\n输出中带有【*】号的的就是当前所处的环境\n当&#x3D;&#x3D;创建环境&#x3D;&#x3D;时，出现**NoWritablePkgsDirError: No writeable pkgs directories configured.**报错\nconda config --add pkgs_dirs D:\\Environment\\Anaconda3\\pkgsconda config --add envs_dirs D:\\Environment\\Anaconda3\\envs\n\nconda 其他命令conda list: 看这个环境下安装的包和版本conda install numpy scikit-learn: 安装numpy sklearn包conda env remove -n yourEnv: 删除你的环境conda env list: 查看所有的环境\n\n常见报错img.imshow（xxx）不显示图片\n在 pycharm 中设置图片不在 pycharm 中显示（关闭 Show plots in tool window）\n\nimport pylabpylab.show()\n\n当控制台报\nOMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to continue to execute, but that may cause crashes or silently produce incorrect results. For more information, please see http://www.intel.com/software/products/support/.\n\n使用\nimport osos.environ[&#x27;KMP_DUPLICATE_LIB_OK&#x27;] = &#x27;True&#x27;\n\n动手学深度学习下载教材\n幻灯片版\nhttps://github.com/d2l-ai/d2l-zh-pytorch-slides.gitgit clone https://github.com/d2l-ai/d2l-zh-pytorch-slides.git\n\n名词解释有监督学习无监督学习线性回归与逻辑回归\n线性回归是一种用于预测和拟合函数的方法。它用于回归任务，例如用来拟合一条直线。\n\n\n应用：线性回归常用于连续变量的预测，例如房价预测、股票价格预测等。它可以用来拟合一条直线，描述自变量和因变量之间的关系。\n\n\n逻辑回归是一种用于分类和预测函数的方法。它用于分类任务，可以进行二分类或多分类。它是在给定自变量和超参数后，得到因变量的期望，基于这个期望来处理预测分类问题。\n\n\n应用：逻辑回归常用于分类问题，例如垃圾邮件分类、疾病诊断等。它可以用来预测一个事件发生的概率，并根据这个概率进行分类。\n\n支持向量机 SVM线性可分支持向量机\n$w&#x3D;(w_1,w_2\\cdots w_n)$\n$x&#x3D;(x_1,x_2\\cdots x_n)$\nb &#x3D; -10\n$w ×x+b&#x3D;0$\n线性支持向量机\n非线性支持向量机\nSoftmax 回归\n区别\n\n\n均方损失\nSoftmax 和交叉熵损失\n交叉熵常用来衡量两个概率的区别\n\n\n总结：\n\nSoftmax 回归是一个多分类模型\n使用 Softmax 操作子得到每个类的预测置信度\n使用交叉熵来衡量预测和标号的区别作为损失函数\n\n从零开始实现$softmax(X){ij}&#x3D;\\frac{exp(X{ij})}{∑kexp(X{ik})}$\ndef softmax(X):    X_exp = torch.exp(X)    partition = X_exp.sum(1, keepdim=True)    return X_exp / partition # 应用广播机制\n\n\n实现结果\n\n\n损失函数L2 Loss（均方损失）\n\n$l(y,y’)&#x3D;\\frac{1}{2}(y-y’)^2$\n\nL1 Loss\n\n$l(y,y’)&#x3D;|y-y’|$\n\n图像分类数据集import torchfrom torch.utils import datafrom d2l import torch as d2ldef get_dataloader_workers():    &quot;&quot;&quot;使用4个进程来读取数据。&quot;&quot;&quot;    return 4train_iter = data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers())timer = d2l.Timer()for X, y in train_iter:    continue# 打印读取数据时间print(f&#x27;&#123;timer.stop():.2f&#125; sec&#x27;)\n\n感知机二分类问题\n\n给定输入 x，权重 w，和偏移 b，感知机输出：\n$\\omicron&#x3D;\\sigma(&lt;w,x&gt;+b)$ $\\sigma(x)&#x3D;\\begin{cases} 1，if \\quad x&gt;0 \\ -1， otherwise  \\end{cases}$\n\n二分类：-1 或 1\n\nVs.回归输出实数\nVs.Softmax 回归输出概率\n\n\n\n\n收敛定理\n\n数据在半径r内\n余量$\\rho$分类两类\ny($x^T$w+b) $\\geqslant$ $\\rho$\n\n\n\n 对于$||W||^2+b^2\\leqslant1$\n\n感知机保证在$\\frac {r^2+1}{\\rho^2}$步后收敛\n\nXOR 问题\n感知机不能拟合 XOR 函数，它只能产生线性分割面\n多层感知机\n\nX，Y 先进入蓝色进行判断：（1，3）为+，（2，4）为－\n\nX，Y 再进入黄色进行判断：（1，2）为+，（3，4）为-\n\nproduct 对前面的结果做乘积，相同为+ ，相异为-\n\n\n总结\n\n多层感知器使用隐藏层和激活函数来得到非线性模型\n常用激活函数是 sigmoid，Tanh，ReLU\n使用 softmax 来处理多类分类\n超参数为隐藏层数，和各个隐藏层大小\n\n\n代码\n\nimport torchfrom torch import nnfrom d2l import torch as d2limport pylabimport osos.environ[&#x27;KMP_DUPLICATE_LIB_OK&#x27;] = &#x27;True&#x27;# 批量大小batch_size = 64train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)# 超参数num_inputs, num_outputs, num_hiddens = 784, 10, 256W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens, requires_grad=True) * 0.01)b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True))W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs, requires_grad=True) * 0.01)b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True))params = [W1, b1, W2, b2]def relu(X):    a = torch.zeros_like(X)    return torch.max(X, a)def net(X):    X = X.reshape((-1, num_inputs))    H = relu(X @ W1 + b1)    return (H @ W2 + b2)loss = nn.CrossEntropyLoss()num_epochs, lr = 10, 0.1updater = torch.optim.SGD(params, lr=lr)d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, updater)d2l.predict_ch3(net, test_iter)pylab.show()\n\n\n结果\n\n\n模型选择\n训练误差：模型在训练数据上的误差\n\n泛化误差：模型在新数据上的误差\n\n验证数据集：评估模型好坏的数据集（不要和测试数据集混在一起）\n\n测试数据集：只使用一次（例如竞赛排行榜的数据集，只使用一次）\n\n\nK-折交叉验证将含有N 个样本的数据集，分成K 份，每份含有 $\\frac{N}{K}$个样本。选择其中一份作为验证集，另外K − 1份作为训练集，验证集集就有K种情况。\n\n在没有足够多数据时使用\n使用i块作为验证数据集，其余作为训练集\n\n\n最后 K 个验证集误差求平均\n\n\n常用：K &#x3D; 5 或 10（程序跑 5 次或 10 次）\n\n总结\n训练数据集：训练模型参数\n验证数据集：选择模型超参数\n非大数据集上通常使用 K-折交叉验证\n\n过拟合和欠拟合\n\n\n\n$\\frac{数据}{模型容量}$\n简单\n复杂\n\n\n\n低\n正常\n欠拟合\n\n\n高\n过拟合\n正常\n\n\n模型容量的影响\n\n数据复杂度\n\n样本个数\n每个样本的元素个数\n时间、空间结构\n多样性\n\n总结\n\n模型容量需要匹配数据复杂度，否则可能导致欠拟合和过拟合\n统计机器学习提供数学工具来衡量模型复杂度\n实际中一般靠观察训练误差和验证误差\n\n\n结果\n\n正常\n\n欠拟合\n\n过拟合\n\n卷积神经网络语言识别pip install SpeechRecognition\n","categories":["深度学习"],"tags":["Torch"]},{"title":"深度学习工具","url":"/2023/05/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/","content":"自创数据集（img）在当前目录下新建dataset，并在文件夹中，将图片分类在各自文件夹中，文件夹名为标签名\n\nimport osimport random# 选取60%作为训练数据集train_radio = 0.6text_radio = 1 - train_radioroot_data = r&#x27;dataset&#x27;train_list, test_list = [], []data_list = []class_flag = -1for a, b, c in os.walk(root_data):    print(a)    for i in range(len(c)):        data_list.append(os.path.join(a, c[i]))    for i in range(0, int(len(c) * train_radio)):        train_data = os.path.join(a, c[i]) + &#x27;\\t&#x27; + str(class_flag) + &#x27;\\n&#x27;        train_list.append(train_data)    for i in range(int(len(c) * train_radio), len(c)):        test_data = os.path.join(a, c[i]) + &#x27;\\t&#x27; + str(class_flag) + &#x27;\\n&#x27;        test_list.append(test_data)    class_flag += 1print(train_list)# 将列表中元素顺序随机打乱random.shuffle(train_list)random.shuffle(test_list)with open(&#x27;train.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    for train_img in train_list:        f.write(str(train_img))with open(&#x27;text.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    for test_img in test_list:        f.write(test_img)\n\n会在当前目录下，生成train.txt、test.txt，在会随机给不同的类分一个数字作为标签\n\n前面的图片路径为输入的x、后面的数字为标签y\n转换为 DataLoader将自己的数据集转换为 torch 可接受的 DataLoader，CreateDateloader.py\nimport torchfrom PIL import Imageimport torchvision.transforms as transformsfrom PIL import ImageFileImageFile.LOAD_TRUNCATED_IMAGES = Truefrom torch.utils.data import Dataset# 数据归一化与标准化# 图像标准化transform_BZ= transforms.Normalize(    mean=[0.5, 0.5, 0.5],# 取决于数据集    std=[0.5, 0.5, 0.5])class LoadData(Dataset):    def __init__(self, txt_path, train_flag=True):        self.imgs_info = self.get_images(txt_path)        self.train_flag = train_flag        self.train_tf = transforms.Compose([                transforms.Resize(224),                transforms.RandomHorizontalFlip(),                transforms.RandomVerticalFlip(),                transforms.ToTensor(),                transform_BZ            ])        self.val_tf = transforms.Compose([                transforms.Resize(224),                transforms.ToTensor(),                transform_BZ            ])    def get_images(self, txt_path):        with open(txt_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:            imgs_info = f.readlines()            imgs_info = list(map(lambda x:x.strip().split(&#x27;\\t&#x27;), imgs_info))        return imgs_info    def padding_black(self, img):        w, h  = img.size        scale = 224. / max(w, h)        img_fg = img.resize([int(x) for x in [w * scale, h * scale]])        size_fg = img_fg.size        size_bg = 224        img_bg = Image.new(&quot;RGB&quot;, (size_bg, size_bg))        img_bg.paste(img_fg, ((size_bg - size_fg[0]) // 2,                              (size_bg - size_fg[1]) // 2))        img = img_bg        return img    def __getitem__(self, index):        img_path, label = self.imgs_info[index]        img = Image.open(img_path)        img = img.convert(&#x27;RGB&#x27;)        img = self.padding_black(img)        if self.train_flag:            img = self.train_tf(img)        else:            img = self.val_tf(img)        label = int(label)        return img, label    def __len__(self):        return len(self.imgs_info)if __name__ == &quot;__main__&quot;:    train_dataset = LoadData(&quot;train.txt&quot;, True)    print(&quot;数据个数：&quot;, len(train_dataset))    train_loader = torch.utils.data.DataLoader(dataset=train_dataset,                                               batch_size=10,                                               shuffle=True)    for image, label in train_loader:        print(image.shape)        print(image)        # img = transform_BZ(image)        # print(img)        print(label)    # test_dataset = Data_Loader(&quot;test.txt&quot;, False)    # print(&quot;数据个数：&quot;, len(test_dataset))    # test_loader = torch.utils.data.DataLoader(dataset=test_dataset,    #                                            batch_size=10,    #                                            shuffle=True)    # for image, label in test_loader:    #     print(image.shape)    #     print(label)\n\n运行的结果为数据个数，以及每张图片的张量\n\n开始定义模型\nimport torchfrom torch import nnfrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision.transforms import ToTensor, Lambda, Composeimport matplotlib.pyplot as pltfrom CreateDataloader import LoadData# 采用torchvision里面的datasets里面的FashionMNIST数据集，该数据集在第一次用时需要下载，# 数据集分为训练集（用于模型训练）和测试集（验证模型性能）# 下面是训练集# training_data = datasets.FashionMNIST(  # FashionMNIST#     root=&quot;data&quot;,#     train=True,#     download=True,#     transform=ToTensor(),   # 数据预处理# )## # 下面是测试集，同样需要下载# test_data = datasets.FashionMNIST(#     root=&quot;data&quot;,#     train=False,#     download=True,#     transform=ToTensor(),# )## 定义网络模型class NeuralNetwork(nn.Module):    def __init__(self):        super(NeuralNetwork, self).__init__()        # 碾平，将数据碾平为一维        self.flatten = nn.Flatten()        # 定义linear_relu_stack，由以下众多层构成        self.linear_relu_stack = nn.Sequential(            # 全连接层            nn.Linear(3*224*224, 512),            # ReLU激活函数            nn.ReLU(),            # 全连接层            nn.Linear(512, 512),            nn.ReLU(),            nn.Linear(512, 6),            nn.ReLU()        )    # x为传入数据    def forward(self, x):        # x先经过碾平变为1维        x = self.flatten(x)        # 随后x经过linear_relu_stack        logits = self.linear_relu_stack(x)        # 输出logits        return logits# 定义训练函数，需要def train(dataloader, model, loss_fn, optimizer):    size = len(dataloader.dataset)    # 从数据加载器中读取batch（一次读取多少张，即批次数），X(图片数据)，y（图片真实标签）。    for batch, (X, y) in enumerate(dataloader):        # 将数据存到显卡        X, y = X.cuda(), y.cuda()        # 得到预测的结果pred        pred = model(X)        # 计算预测的误差        # print(pred,y)        loss = loss_fn(pred, y)        # 反向传播，更新模型参数        optimizer.zero_grad()        loss.backward()        optimizer.step()        # 每训练100次，输出一次当前信息        if batch % 100 == 0:            loss, current = loss.item(), batch * len(X)            print(f&quot;loss: &#123;loss:&gt;7f&#125;  [&#123;current:&gt;5d&#125;/&#123;size:&gt;5d&#125;]&quot;)def test(dataloader, model):    size = len(dataloader.dataset)    print(&quot;size = &quot;,size)    # 将模型转为验证模式    model.eval()    # 初始化test_loss 和 correct， 用来统计每次的误差    test_loss, correct = 0, 0    # 测试时模型参数不用更新，所以no_gard()    # 非训练， 推理期用到    with torch.no_grad():        # 加载数据加载器，得到里面的X（图片数据）和y(真实标签）        for X, y in dataloader:            # 将数据转到GPU            X, y = X.cuda(), y.cuda()            # 将图片传入到模型当中就，得到预测的值pred            pred = model(X)            # 计算预测值pred和真实值y的差距            test_loss += loss_fn(pred, y).item()            # 统计预测正确的个数            correct += (pred.argmax(1) == y).type(torch.float).sum().item()    test_loss /= size    correct /= size    print(&quot;correct = &quot;,correct)    print(f&quot;Test Error: \\n Accuracy: &#123;(100*correct):&gt;0.1f&#125;%, Avg loss: &#123;test_loss:&gt;8f&#125; \\n&quot;)if __name__==&#x27;__main__&#x27;:    batch_size = 16    # # 给训练集和测试集分别创建一个数据集加载器    train_data = LoadData(&quot;train.txt&quot;, True)    valid_data = LoadData(&quot;test.txt&quot;, False)    # num_workers：cpu用来加载数据的子进程数  pin_memory：是否将数据保存在pin memory区，pin memory中的数据转到GPU会快一些    train_dataloader = DataLoader(dataset=train_data, num_workers=4, pin_memory=True, batch_size=batch_size, shuffle=True)    test_dataloader = DataLoader(dataset=valid_data, num_workers=4, pin_memory=True, batch_size=batch_size)    for X, y in test_dataloader:        print(&quot;Shape of X [N, C, H, W]: &quot;, X.shape)        print(&quot;Shape of y: &quot;, y.shape, y.dtype)        break    # 如果显卡可用，则用显卡进行训练    device = &quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;    print(&quot;Using &#123;&#125; device&quot;.format(device))    # 调用刚定义的模型，将模型转到GPU（如果可用）    model = NeuralNetwork().to(device)    print(model)    # 定义损失函数，计算相差多少，交叉熵，    loss_fn = nn.CrossEntropyLoss()    # 定义优化器，用来训练时候优化模型参数，随机梯度下降法    optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)  # 初始学习率    # 一共训练5次    epochs = 5    for t in range(epochs):        print(f&quot;Epoch &#123;t+1&#125;\\n-------------------------------&quot;)        train(train_dataloader, model, loss_fn, optimizer)        test(test_dataloader, model)    print(&quot;Done!&quot;)    # 保存训练好的模型    # torch.save(model.state_dict(), &quot;model.pth&quot;)    # print(&quot;Saved PyTorch Model State to model.pth&quot;)    # 读取训练好的模型，加载训练好的参数    model = NeuralNetwork()    model.load_state_dict(torch.load(&quot;model.pth&quot;))    # # 定义所有类别    # classes = [    #     &quot;T-shirt/top&quot;,    #     &quot;Trouser&quot;,    #     &quot;Pullover&quot;,    #     &quot;Dress&quot;,    #     &quot;Coat&quot;,    #     &quot;Sandal&quot;,    #     &quot;Shirt&quot;,    #     &quot;Sneaker&quot;,    #     &quot;Bag&quot;,    #     &quot;Ankle boot&quot;,    # ]    #    # # 模型进入验证阶段    # model.eval()    #    # x, y = test_data[0][0], test_data[0][1]    # with torch.no_grad():    #     pred = model(x)    #     predicted, actual = classes[pred[0].argmax(0)], classes[y]    #     print(f&#x27;Predicted: &quot;&#123;predicted&#125;&quot;, Actual: &quot;&#123;actual&#125;&quot;&#x27;)\n\n常用设置设置 pycharm 不在 SciView 中显示图片：\nFile -&gt; Settings -&gt; Tools -&gt; Python Scientific -&gt; 去掉 Show plots in tool window 勾选\n","categories":["深度学习"],"tags":["Python","Torch"]},{"title":"硅谷小智","url":"/2025/04/22/%E7%A1%85%E8%B0%B7%E5%B0%8F%E6%99%BA/","content":"硅谷小智（医疗版）一、LangChain4j入门1、简介LangChain4j 的目标是简化将大模型（LLM - Large Language Model）集成到 Java 应用程序中的过程。\n1.1、历史背景2022年11月30日OpenAI发布了Chat GPT (GPT-3.5)早在2022年10月，Harrison Chase发布了基于Python的LangChain。随后同时包含了Python版和JavaScript (LangChain.js)版的LangChain也发布了。2023年11月，Quarkus 发布了LangChain4j 的0.1版本，2025年2月发布了1.0-Beta1 版本，4月发布了1.0-Beta3版本官网：LangChain4j\n1.2、主要功能与大型语言模型和向量数据库的便捷交互通过统一的应用程序编程接口(API)，可以轻松访问所有主要的商业和开源大型语言模型以及向量数据库，使你能够构建聊天机器人、智能助手等应用。专为 Java 打造借助Spring Boot集成，能够将大模型集成到 Java 应用程序中。大型语言模型与 Java 之间实现了双向集成：你可以从Java中调用大型语言模型，同时也允许大型语言模型反过来调用你的Java代码智能代理、工具、检索增强生成（RAG）为常见的大语言模型操作提供了广泛的工具，涵盖从底层的提示词模板创建、聊天记忆管理和输出解析，到智能代理和检索增强生成等高级模式。\n1.3、应用示例\n你想要实现一个自定义的由人工智能驱动的聊天机器人，它可以访问你的数据，并按照你期望的方式运行：\n客户支持聊天机器人，它可以：\n礼貌地回答客户问题\n\n\n处理&#x2F;更改&#x2F;取消订单\n教育助手，它可以：\n教授各种学科\n\n\n解释不清楚的部分\n评估用户的理解&#x2F;知识水平\n\n\n\n\n你想要处理大量的非结构化数据（文件、网页等），并从中提取结构化信息。例如：\n从客户评价和支持聊天记录中提取有效评价\n从竞争对手的网站上提取有趣的信息\n从求职者的简历中提取有效信息\n\n\n你想要生成信息，例如：\n为你的每个客户量身定制的电子邮件\n为你的应用程序&#x2F;网站生成内容：\n博客文章\n故事\n\n\n\n\n你想要转换信息，例如：\n总结\n校对和改写\n翻译\n\n\n\n2、创建SpringBoot项目2.1、创建一个Maven项目名称：java-ai-langchain4j\n&lt;groupId&gt;com.wwj&lt;/groupId&gt;    &lt;artifactId&gt;java-ai-langchain4j&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n2.2、添加SpringBoot相关依赖pom.xml 配置如下：\n&lt;properties&gt;       &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;       &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;       &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;       &lt;spring-boot.version&gt;3.2.6&lt;/spring-boot.version&gt;       &lt;knife4j.version&gt;4.3.0&lt;/knife4j.version&gt;       &lt;langchain4j.version&gt;1.0.0-beta3&lt;/langchain4j.version&gt;       &lt;mybatis-plus.version&gt;3.5.11&lt;/mybatis-plus.version&gt;   &lt;/properties&gt;   &lt;dependencies&gt;       &lt;!-- web应用程序核心依赖 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- 编写和运行测试用例 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;           &lt;scope&gt;test&lt;/scope&gt;       &lt;/dependency&gt;       &lt;!-- 前后端分离中的后端接口测试工具 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;           &lt;artifactId&gt;knife4j-openapi3-jakarta-spring-boot-starter&lt;/artifactId&gt;           &lt;version&gt;$&#123;knife4j.version&#125;&lt;/version&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;   &lt;dependencyManagement&gt;       &lt;dependencies&gt;           &lt;!--引入SpringBoot依赖管理清单--&gt;           &lt;dependency&gt;               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;               &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;               &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;               &lt;type&gt;pom&lt;/type&gt;               &lt;scope&gt;import&lt;/scope&gt;           &lt;/dependency&gt;       &lt;/dependencies&gt;   &lt;/dependencyManagement&gt;\n\n2.3、创建配置文件在resourcese下创建配置文件 application.yml\n# Web服务端口号server:  port: 8080\n\n2.4、创建启动类package com.wwj.java.ai.langchain4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class XiaozhiApp &#123;\tpublic static void main(String[] args) &#123;\t\tSpringApplication.run(XiaozhiApp.class, args);\t&#125;&#125;\n\n2.5、启动启动类访问 http://localhost:8080/doc.html 查看程序能否成功运行\n3、接入大模型参考文档：https://docs.langchain4j.dev/get-started\n3.1、LangChain4j 库结构LangChain4j 具有模块化设计，包括： \n\nlangchain4j-core 模块，它定义了核心抽象概念（如聊天语言模型和嵌入存储）及其 API。 \n主 langchain4j 模块，包含有用的工具，如文档加载器、聊天记忆实现，以及诸如人工智能服务等 高层功能。\n大量的 langchain4j-{集成} 模块，每个模块都将各种大语言模型提供商和嵌入存储集成到  LangChain4j 中。你可以独立使用 langchain4j-{集成} 模块。如需更多功能，只需导入主 langchain4j  依赖项即可。\n\n3.2、添加LangChain4j相关依赖&lt;properties&gt;    &lt;langchain4j.version&gt;1.0.0-beta3&lt;/langchain4j.version&gt; &lt;/properties&gt; &lt;dependencies&gt;    &lt;!-- 基于open-ai的langchain4j接口：ChatGPT、deepseek都是open-ai标准下的大模型 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;        &lt;artifactId&gt;langchain4j-open-ai&lt;/artifactId&gt;    &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;!--引入langchain4j依赖管理清单--&gt;        &lt;dependency&gt;            &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;            &lt;artifactId&gt;langchain4j-bom&lt;/artifactId&gt;            &lt;version&gt;$&#123;langchain4j.version&#125;&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt; &lt;/dependencyManagement&gt;\n\n3.3、创建测试用例接入任何一个大模型都需要先去申请 ApiKey\n如果你暂时没有密钥，也可以使用LangChain4j 提供的演示密钥，这个密钥是免费的，有使用配额限制， 且仅限于 gpt-4o-mini 模型。\npackage com.wwj.java.ai.langchain4j;import dev.langchain4j.model.openai.OpenAiChatModel;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class LLMTest &#123;\t@Test\tpublic void testGPT() &#123;\t\tOpenAiChatModel model = OpenAiChatModel.builder()\t\t\t\t.baseUrl(&quot;http://langchain4j.dev/demo/openai/v1&quot;)\t\t\t\t.apiKey(&quot;demo&quot;)\t\t\t\t.modelName(&quot;gpt-4o-mini&quot;)\t\t\t\t.build();\t\tString answer = model.chat(&quot;你好，你都会做些什么&quot;);\t\tSystem.out.println(answer);\t&#125;&#125;\n\n4、SpringBoot整合参考文档：https://docs.langchain4j.dev/tutorials/spring-boot-integration\n4.1、替换依赖将 langchain4j-open-ai 替换成  langchain4j-open-ai-spring-boot-starter\n&lt;dependency&gt;            &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;            &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;\n\n4.2、在application.yml中配置模型参数langchain4j:  open-ai:    chat-model:      base-url: http://langchain4j.dev/demo/openai/v1      api-key: demo      model-name: gpt-4o-mini      # 应用程序发送给大模型的请求日志与响应日志      log-requests: true      log-responses: true\n\n4.3、创建测试用例@Autowiredprivate OpenAiChatModel openAiChatModel;\t@Testpublic void testSpringBoot() &#123;    String answer = openAiChatModel.chat(&quot;我是谁？&quot;);    System.out.println(answer);&#125;\n\n\n\n二、接入其他大模型1、都有哪些大模型\n大语言模型排行榜：SuperCLUE中文大模型测评基准——评测榜单\nSuperCLUE 是由国内 CLUE 学术社区于 2023 年 5 月推出的中文通用大模型综合性评测基准。\n\n评测目的：全面评估中文大模型在语义理解、逻辑推理、代码生成等 10 项基础能力，以及涵盖数 学、物理、社科等 50 多学科的专业能力，旨在回答在通用大模型发展背景下，中文大模型的效果情 况，包括不同任务效果、与国际代表性模型的差距、与人类的效果对比等问题。\n\n特色优势：针对中文特性任务，如成语、诗歌、字形等设立专项评测，使评测更符合中文语言特 点。通过 3700 多道客观题和匿名对战机制，动态追踪国内外主流模型，如 GPT-4、文心一言、通义 千问等的表现差异，保证评测的客观性和时效性。\n\n行业影响：作为中文领域权威测评社区，其评测结果被学界和产业界广泛引用，例如商汤 “日日新  5.0” 和百度文心大模型均通过 SuperCLUE 验证技术突破，推动了中文 NLP 技术生态的迭代，为中文 大模型的发展和优化提供了重要的参考依据，促进了中文大模型技术的不断进步和应用。\n\nLangChain4j支持接入的大模型：Comparison Table of all supported Language Models | LangChain4j\n\n\n2、接入DeepSeek1.1、获取开发参数\n访问官网：DeepSeek | 深度求索  注册账号，获取base_url和api_key，充值\n\n1.2、配置开发参数为了apikay的安全，建议将其配置在服务器的环境变量中。变量名自定义即可，例如  DEEP_SEEK_API_KEY\n1.3、配置模型参数DeepSeek API文档：https://api-docs.deepseek.com/zh-cn/ \n在 LangChain4j 中，DeepSeek 和 GPT 一样也使用了 OpenAI 的接口标准，因此也使用OpenAiChatModel进 行接入\n#DeepSeek langchain4j.open-ai.chat-model.base-url=https://api.deepseek.com langchain4j.open-ai.chat-model.api-key=$&#123;DEEP_SEEK_API_KEY&#125; #DeepSeek-V3 langchain4j.open-ai.chat-model.model-name=deepseek-chat #DeepSeek-R1 推理模型#langchain4j.open-ai.chat-model.model-name=deepseek-reasoner\n\n1.4、测试直接使用前面的测试用例即可\n3、ollama本地部署3.1、为什么要本地部署Ollama 是一个本地部署大模型的工具。使用 Ollama 进行本地部署有以下多方面的原因：\n\n数据隐私与安全：对于金融、医疗、法律等涉及大量敏感数据的行业，数据安全至关重要。\n离线可用性：在网络不稳定或无法联网的环境中，本地部署的 Ollama 模型仍可正常运行。\n降低成本：云服务通常按使用量收费，长期使用下来费用较高。而 Ollama 本地部署，只需一次性投 入硬件成本，对于需要频繁使用大语言模型且对成本敏感的用户或企业来说，能有效节约成本。\n部署流程简单：只需通过简单的命令 “ollama run &lt; 模型名&gt;”，就可以自动下载并运行所需的模型。\n灵活扩展与定制：可对模型微调，以适配垂直领域需求。\n\n3.2、在ollama上部署DeepSeek官网： https://ollama.com/\n（1）下载并安装ollama： OllamaSetup.exe\n（2）查看模型列表，选择要部署的模型，模型列表： Ollama Search\n（3）执行命令： ollama run deepseek-r1:1.5 运行大模型。如果是第一次运行则会先下载大模型\n3.3、常用命令Available Commands:  serve       Start ollama  create      Create a model from a Modelfile  show        Show information for a model  run         Run a model  stop        Stop a running model  pull        Pull a model from a registry  push        Push a model to a registry  list        List models  ps          List running models  cp          Copy a model  rm          Remove a model  help        Help about any command\n\n3.4、引入依赖参考文档：https://docs.langchain4j.dev/integrations/language-models/ollama#get-started\n&lt;!-- 接入ollama --&gt;&lt;dependency&gt;    &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;    &lt;artifactId&gt;langchain4j-ollama-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;\n\n3.5、配置模型参数#ollama langchain4j.ollama.chat-model.base-url=http://localhost:11434 langchain4j.ollama.chat-model.model-name=deepseek-r1:1.5b langchain4j.ollama.chat-model.log-requests=true langchain4j.ollama.chat-model.log-responses=true\n\n3.6、创建测试用例/** * ollama接入*/@Autowiredprivate OllamaChatModel ollamaChatModel;@Testpublic void testOllama() &#123;    String answer = ollamaChatModel.chat(&quot;你是谁？&quot;);    System.out.println(answer);&#125;\n\n4、接入阿里百炼平台4.1、什么是阿里百炼\n阿里云百炼是 2023 年 10 月推出的。它集成了阿里的通义系列大模型和第三方大模型，涵盖文本、 图像、音视频等不同模态。\n功能优势：集成超百款大模型 API，模型选择丰富；5-10 分钟就能低代码快速构建智能体，应用构 建高效；提供全链路模型训练、评估工具及全套应用开发工具，模型服务多元；在线部署可按需扩 缩容，新用户有千万 token 免费送，业务落地成本低。\n支持接入的模型列表：https://help.aliyun.com/zh/model-studio/models\n模型广场：https://bailian.console.aliyun.com/?productCode=p_efm#/model-market\n\n4.2、申请免费体验（1）点击进入免费体验页面：百炼控制台\n（2）登录选择API-Key，创建并复制自己的API-Key\n4.3、添加依赖LangChain4j参考文档：https://docs.langchain4j.dev/integrations/language-models/dashscope#plain-java\n&lt;dependencies&gt;&lt;!-- 接入阿里云百炼平台 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;            &lt;artifactId&gt;langchain4j-community-dashscope-spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;     &lt;dependencies&gt;     &lt;!--引入百炼依赖管理清单--&gt;            &lt;dependency&gt;                &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;                &lt;artifactId&gt;langchain4j-community-bom&lt;/artifactId&gt;                &lt;version&gt;$&#123;langchain4j.version&#125;&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;\n\n4.4、配置模型参数langchain4j:  #阿里百练平台  community:    dashscope:      chat-model:        api-key: sk-46c3383686324d6298a1e6549bf815b2        model-name: qwen-max\n\n4.5、测试通义千问@Autowiredprivate QwenChatModel qwenChatModel;@Testpublic void testQwen() &#123;    String answer = qwenChatModel.chat(&quot;你是谁？&quot;);    System.out.println(answer);&#125;\n\n4.6、测试通义万象生成图片测试\n@Testpublic void testQwen() &#123;\tWanxImageModel wanxImageModel = WanxImageModel.builder()\t\t\t.modelName(&quot;wanx2.1-t2i-turbo&quot;)\t\t\t.apiKey(&quot;sk-xxxxxxxxxxx&quot;)\t\t\t.build();\tResponse&lt;Image&gt; response = wanxImageModel.generate(&quot;奇幻森林精灵：在一片弥漫着轻柔薄雾的古老森林深处，阳光透过茂密枝叶洒下金色光斑。一位身材娇小、长着透明薄翼的精灵少女站在一朵硕大的蘑菇上。她有着海藻般的绿色长发，发间点缀着蓝色的小花，皮肤泛着珍珠般的微光。身上穿着由翠绿树叶和白色藤蔓编织而成的连衣裙，手中捧着一颗散发着柔和光芒的水晶球，周围环绕着五彩斑斓的蝴蝶，脚下是铺满苔藓的地面，蘑菇和蕨类植物丛生，营造出神秘而梦幻的氛围。&quot;);\tURI url = response.content().url();\tSystem.out.println(url);&#125;\n\n\n\n三、人工智能服务 AIService1、什么是AIServiceAIService使用面向接口和动态代理的方式完成程序的编写，更灵活的实现高级功能。\n1.1、链 Chain（旧版）链的概念源自 Python 中的 LangChain。其理念是针对每个常见的用例都设置一条链，比如聊天机器人、 检索增强生成（RAG）等。链将多个底层组件组合起来，并协调它们之间的交互。链存在的主要问题是不 灵活，我们不进行深入的研究。\n1.2、人工智能服务 AIService在LangChain4j中我们使用AIService完成复杂操作。底层组件将由AIService进行组装。\nAIService可处理最常见的操作：\n\n为大语言模型格式化输入内容\n解析大语言模型的输出结果\n\n它们还支持更高级的功能：\n\n聊天记忆 Chat memory\n工具 Tools\n检索增强生成 RAG\n\n2、创建AIService2.1、引入依赖&lt;!--langchain4j高级功能--&gt; &lt;dependency&gt;     &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;     &lt;artifactId&gt;langchain4j-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;\n\n2.2、创建接口package com.wwj.java.ai.langchain4j.assistant;public interface Assistant &#123;\tString chat(String userMessage);&#125;\n\n2.3、测试用例@SpringBootTestpublic class AIServiceTest &#123;\t@Autowired\tprivate QwenChatModel qwenChatModel;\t\t@Test\tpublic void testChat() &#123;\t\tAssistant assistant = AiServices.create(Assistant.class, qwenChatModel);\t\tString answer = assistant.chat(&quot;你是谁？&quot;);\t\tSystem.out.println(answer);\t&#125;&#125;\n\n2.4、@AiService也可以在 Assistant 接口上添加 @AiService 注解\nimport dev.langchain4j.service.spring.AiService;import static dev.langchain4j.service.spring.AiServiceWiringMode.EXPLICIT;//因为我们在配置文件中同时配置了多个大语言模型，所以需要在这里明确指定（EXPLICIT）模型的beanName@AiService(wiringMode = EXPLICIT, chatModel = &quot;qwenChatModel&quot;)public interface Assistant &#123;\tString chat(String userMessage);&#125;\n\n测试用例中，我们可以直接注入Assistant对象\n@Autowiredprivate Assistant assistant;@Testpublic void testAssistant() &#123;    String answer = assistant.chat(&quot;你是谁？&quot;);    System.out.println(answer);&#125;\n\n2.5、工作原理AiServices会组装Assistant接口以及其他组件，并使用反射机制创建一个实现Assistant接口的代理对象。 这个代理对象会处理输入和输出的所有转换工作。在这个例子中，chat方法的输入是一个字符串，但是大 模型需要一个 **UserMessage **对象。所以，代理对象将这个字符串转换为 UserMessage ，并调用聊天语 言模型。chat方法的输出类型也是字符串，但是大模型返回的是  AiMessage 对象，代理对象会将其转换 为字符串。 简单理解就是：代理对象的作用是输入转换和输出转换\n\n简单理解就是：代理对象的作用是输入转换和输出转换\n\n四、聊天记忆 Chat memory1、测试对话是否有记忆@SpringBootTestpublic class ChatMemoryTest &#123;\t\t@Autowired\tprivate Assistant assistant;\t@Test\tpublic void testChatMemory() &#123;\t\t// 创建一个会话\t\tString answer1 = assistant.chat(&quot;我是坏坏&quot;);\t\tSystem.out.println(answer1);\t\tString answer2 = assistant.chat(&quot;我是谁？&quot;);\t\tSystem.out.println(answer2);\t&#125;&#125;\n\n\nanswer1：你好，坏坏！有什么我可以帮助你的吗？或者你想聊些什么呢？\nanswer2：您好！您是使用这个平台的用户，但我无法直接知道您的具体身份信息，因为我重视并保护用户的隐私。如果您想分享更多信息关于您自己，我很乐意进一步交流！或者，如果您有其他想要了解的问题或需要帮助的地方，请告诉我。\n\n很显然，目前的接入方式，大模型是没有记忆的。\n2、聊天记忆的简单实现可以使用下面的方式实现对话记忆。\n@Autowiredprivate QwenChatModel qwenChatModel;@Testpublic void testChatMemory2() &#123;    // 第一轮对话    UserMessage userMessage1 = UserMessage.userMessage(&quot;我是坏坏&quot;);    ChatResponse chatResponse1 = qwenChatModel.chat(userMessage1);    AiMessage aiMessage1 = chatResponse1.aiMessage();    System.out.println(aiMessage1.text());    // 第二轮对话    UserMessage userMessage2 = UserMessage.userMessage(&quot;你知道我是谁吗？&quot;);    ChatResponse chatResponse2 = qwenChatModel.chat(Arrays.asList(userMessage1, aiMessage1, userMessage2));    AiMessage aiMessage2 = chatResponse2.aiMessage();    System.out.println(aiMessage2.text());&#125;\n\n\n第一轮：你好，坏坏！有什么我可以帮助你的吗？或者你想聊些什么呢？\n第二轮：你好！根据你提供的信息“我是坏坏”，我了解到你的昵称或名字是“坏坏”。不过，除非你之前和我有过交流并且提供了更多的个人信息，否则我无法知道更多关于你的具体信息。如果你愿意分享更多信息，我会很高兴更好地了解你并提供帮助。有什么特别的事情想要聊聊吗？\n\n3、使用ChatMemory实现聊天记忆使用AIService可以封装多轮对话的复杂性，使聊天记忆功能的实现变得简单\n@Testpublic void testChatMemory3() &#123;    //创建chatMemory    MessageWindowChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10);    //创建AIService    Assistant assistant = AiServices        .builder(Assistant.class)        .chatLanguageModel(qwenChatModel)        .chatMemory(chatMemory)        .build();    //调用service的接口    String answer1 = assistant.chat(&quot;我是环环&quot;);    System.out.println(answer1);    String answer2 = assistant.chat(&quot;我是谁&quot;);    System.out.println(answer2);&#125;\n\n4、使用AIService实现聊天记忆4.1、创建记忆对话智能体当AIService由多个组件（大模型，聊天记忆，等）组成的时候，我们就可以称他为智能体了\n我们先创建一个具有记忆功能的智能体接口：MemoryChatAssistant\npackage com.wwj.java.ai.langchain4j.assistant;import dev.langchain4j.service.spring.AiService;import static dev.langchain4j.service.spring.AiServiceWiringMode.EXPLICIT;@AiService(\t\twiringMode = EXPLICIT,\t\tchatModel = &quot;qwenChatModel&quot;,\t\tchatMemory = &quot;chatMemory&quot;)public interface MemoryChatAssistant &#123;\tString chat(String message);&#125;\n\n4.2、配置ChatMemory在智能体MemoryChatAssistant接口中的chatMemory进行配置，作为Bean注入\npackage com.wwj.java.ai.langchain4j.config;import dev.langchain4j.memory.ChatMemory;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MemoryChatAssistantConfig &#123;\t\t@Bean\tpublic ChatMemory chatMemory() &#123;\t\treturn MessageWindowChatMemory.withMaxMessages(10);\t&#125;&#125;\n\n4.3、测试@Autowiredprivate MemoryChatAssistant memoryChatAssistant;@Testpublic void testChatMemory4() &#123;    //调用service的接口    String answer1 = memoryChatAssistant.chat(&quot;我是环环&quot;);    System.out.println(answer1);    String answer2 = memoryChatAssistant.chat(&quot;我是谁&quot;);    System.out.println(answer2);&#125;\n\n5、隔离聊天记忆为每个用户的新聊天或者不同的用户区分聊天记忆\n5.1、创建记忆隔离对话智能体package com.wwj.java.ai.langchain4j.assistant;import dev.langchain4j.service.MemoryId;import dev.langchain4j.service.UserMessage;import dev.langchain4j.service.spring.AiService;import static dev.langchain4j.service.spring.AiServiceWiringMode.EXPLICIT;@AiService(    wiringMode = EXPLICIT,    chatModel = &quot;qwenChatModel&quot;,    chatMemoryProvider = &quot;chatMemoryProvider&quot;)public interface SeparateChatAssistant &#123;    String chat(@MemoryId int memoryId, @UserMessage String userMessage);&#125;\n\n5.2、配置ChatMemoryProviderpackage com.wwj.java.ai.langchain4j.config;import dev.langchain4j.memory.chat.ChatMemoryProvider;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ChatMemoryProviderConfig &#123;\t@Bean\tpublic ChatMemoryProvider chatMemoryProvider() &#123;\t\treturn memoryId -&gt; MessageWindowChatMemory.builder().id(memoryId).maxMessages(10).build();\t&#125;&#125;\n\n5.3、测试对话助手用两个不同的memoryId测试聊天记忆的隔离效果\n@Autowiredprivate SeparateChatAssistant separateChatAssistant;@Testpublic void testChatMemory5() &#123;    String answer1 = separateChatAssistant.chat(1,&quot;我是环环&quot;);    System.out.println(answer1);    String answer2 = separateChatAssistant.chat(1,&quot;我是谁&quot;);    System.out.println(answer2);    String answer3 = separateChatAssistant.chat(2,&quot;我是谁&quot;);    System.out.println(answer3);&#125;\n\n结果如下，只有Id为 1 与 2记忆分开\n\nanswer1：你好，环环！很高兴见到你。有什么我可以帮助你的吗？如果你有任何问题或需要讨论的话题，随时告诉我。\nanswer2：你刚才告诉我你是环环。如果你是用这个名字来指代自己，那么你就是环环。如果这是一个昵称或者有其他含义，请告诉我更多信息，这样我可以更好地帮助你。\nanswer3：您是使用这个平台的用户，但我无法直接知道您的具体身份信息，因为我重视并保护用户的隐私。如果您想告诉我更多关于您的信息，我很乐意了解！或者，如果您有任何问题或需要帮助的地方，请随时告诉我。\n\n五、持久化聊天记忆 Persistence默认情况下，聊天记忆存储在内存中。如果需要持久化存储，可以实现一个自定义的聊天记忆存储类， 以便将聊天消息存储在你选择的任何持久化存储介质中。\n1、存储介质的选择大模型中聊天记忆的存储选择哪种数据库，需要综合考虑数据特点、应用场景和性能要求等因素，以下 是一些常见的选择及其特点：\n\nMySQL\n特点：关系型数据库。支持事务处理，确保数据的一致性和完整性，适用于结构化数据的存储 和查询。\n适用场景：如果聊天记忆数据结构较为规整，例如包含固定的字段如对话 ID、用户 ID、时间 戳、消息内容等，且需要进行复杂的查询和统计分析，如按用户统计对话次数、按时间范围查 询特定对话等，MySQL 是不错的选择。\n\n\nRedis \n特点：内存数据库，读写速度极高。它适用于存储热点数据，并且支持多种数据结构，如字符 串、哈希表、列表等，方便对不同类型的聊天记忆数据进行处理。 \n适用场景：对于实时性要求极高的聊天应用，如在线客服系统或即时通讯工具，Redis 可以快 速存储和获取最新的聊天记录，以提供流畅的聊天体验。\n\n\nMongoDB \n特点：文档型数据库，数据以 JSON - like 的文档形式存储，具有高度的灵活性和可扩展性。它 不需要预先定义严格的表结构，适合存储半结构化或非结构化的数据。 \n适用场景：当聊天记忆中包含多样化的信息，如文本消息、图片、语音等多媒体数据，或者消 息格式可能会频繁变化时，MongoDB 能很好地适应这种灵活性。例如，一些社交应用中用户可 能会发送各种格式的消息，使用 MongoDB 可以方便地存储和管理这些不同类型的数据。\n\n\nCassandra\n特点：是一种分布式的 NoSQL 数据库，具有高可扩展性和高可用性，能够处理大规模的分布 式数据存储和读写请求。适合存储海量的、时间序列相关的数据。 \n适用场景：对于大型的聊天应用，尤其是用户量众多、聊天数据量巨大且需要分布式存储和处 理的场景，Cassandra 能够有效地应对高并发的读写操作。例如，一些面向全球用户的社交媒 体平台，其聊天数据需要在多个节点上进行分布式存储和管理，Cassandra 可以提供强大的支 持。\n\n\n\n2、MongoDB2.1、简介MongoDB 是一个基于文档的 NoSQL 数据库，由 MongoDB Inc. 开发。\nNoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数 据库的数据库管理系统的统称。\nMongoDB 的设计理念是为了应对大数据量、高性能和灵活性需求。 \nMongoDB使用集合（Collections）来组织文档（Documents），每个文档都是由键值对组成的。\n\n数据库（Database）：存储数据的容器，类似于关系型数据库中的数据库。 \n集合（Collection）：数据库中的一个集合，类似于关系型数据库中的表。 \n文档（Document）：集合中的一个数据记录，类似于关系型数据库中的行（row），以 BSON 格式 存储。\n\nMongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成，文档类似于 JSON 对象，字段值 可以包含其他文档，数组及文档数组：\n\n2.2、安装MongoDB服务器： mongodb-windows-x86_64-8.0.6-signed.msi： https://www.mongodb.com/try/download/community \n命令行客户端 ： mongosh-2.5.0-win32-x64.zip： https://www.mongodb.com/try/download/shell \n图形客户端： mongodb-compass-1.39.3-win32-x64.exe： https://www.mongodb.com/try/download/compass\n2.3、使用mongosh启动 MongoDB Shell： \n在命令行中输入 mongosh 命令，启动 MongoDB Shell，如果 MongoDB 服务器运行在本地默认端口 （27017），则可以直接连接\nmongosh\n\n连接到 MongoDB 服务器： 如果 MongoDB 服务器运行在非默认端口或者远程服务器上，可以使用以下命令连接：\nmongosh --host &lt;hostname&gt;:&lt;port&gt;\n\n其中 &lt;hostname&gt; 是 MongoDB 服务器的主机名或 IP 地址，&lt;port&gt;是 MongoDB 服务器的端口号。\n执行基本操作： \t\n连接成功后，可以执行各种 MongoDB 数据库操作。例如：\n\n查看当前数据库：db \n显示数据库列表：show dbs\n切换到指定数据库：use &lt;database_name&gt;\n执行查询操作： db.&lt;collection_name&gt;.find()\n插入文档： db.&lt;collection_name&gt;.insertOne(&#123;  ...  &#125;)\n更新文档：db.&lt;collection_name&gt;.updateOne(&#123; ... &#125;)\n删除文档：db.&lt;collection_name&gt;.deleteOne(&#123;  ...  &#125;)\n退出 MongoDB Shell：quit() 或者 exit\n\n CRUD\n# 插入文档db.mycollection.insertOne(&#123; name: &quot;Alice&quot;, age: 30 &#125;) # 查询文档db.mycollection.find() # 更新文档db.mycollection.updateOne(&#123; name: &quot;Alice&quot; &#125;, &#123; $set: &#123; age: 31 &#125; &#125;) # 删除文档db.mycollection.deleteOne(&#123; name: &quot;Alice&quot; &#125;) # 退出 MongoDB Shell test&gt;quit()\n\n2.4、使用mongodb-compass可以通过mongodb-compass可视化工具直接操作mongoDB的集合。\n2.5、整合SpringBoot引入MongoDB依赖：\n&lt;!-- Spring Boot Starter Data MongoDB --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;\n\n添加远程连接配置：\n#MongoDB连接配置spring:  data:    mongodb:            uri: mongodb://localhost:27017/chat_memory_db\n\n如果新增了用户与密码使用如下：\nspring:  data:    mongodb:      uri: mongodb://mongo:123456@10.11.12.13:27017/chat_memory_db?authSource=admin\n\n2.6、CRUD测试创建实体类：映射MongoDB中的文档（相当与MySQL的表）\npackage com.wwj.java.ai.langchain4j.bean;@Data@AllArgsConstructor@NoArgsConstructor@Document(&quot;chat_messages&quot;)public class ChatMessages &#123;\t//唯一标识，映射到 MongoDB 文档的 _id 字段\t@Id\tprivate ObjectId messageId;\t//private Long messageId;\t\tprivate String content; //存储当前聊天记录列表的json字符串&#125;\n\n创建测试类：\npackage com.wwj.java.ai.langchain4j;import com.wwj.java.ai.langchain4j.bean.ChatMessages;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;@SpringBootTestpublic class MongoCrudTest &#123;    @Autowired    private MongoTemplate mongoTemplate;    /**\t * 插入文档\t */    //    @Test    //    public void testInsert() &#123;    //        mongoTemplate.insert(new ChatMessages(1L, &quot;聊天记录&quot;));    //    &#125;    /**\t * 插入文档\t */    @Test    public void testInsert2() &#123;        ChatMessages chatMessages = new ChatMessages();        chatMessages.setContent(&quot;聊天记录列表&quot;);        mongoTemplate.insert(chatMessages);    &#125;    /**\t * 根据id查询文档\t */    @Test    public void testFindById() &#123;        ChatMessages chatMessages = mongoTemplate.findById(&quot;680e4cfc53eeba4ef57db43f&quot;,                                                           ChatMessages.class);        System.out.println(chatMessages);    &#125;    /**\t * 修改文档\t */    @Test    public void testUpdate() &#123;        Criteria criteria = Criteria.where(&quot;_id&quot;).is(&quot;680e4cfc53eeba4ef57db43f&quot;);        Query query = new Query(criteria);        Update update = new Update();        update.set(&quot;content&quot;, &quot;新的聊天记录列表&quot;);        // 修改或新增        mongoTemplate.upsert(query, update, ChatMessages.class);    &#125;    /**\t * 删除文档\t */    @Test    public void testDelete() &#123;        Criteria criteria = Criteria.where(&quot;_id&quot;).is(&quot;680e4cfc53eeba4ef57db43f&quot;);        Query query = new Query(criteria);        mongoTemplate.remove(query, ChatMessages.class);    &#125;&#125;\n\n3、持久化聊天3.1、优化实体类package com.wwj.java.ai.langchain4j.bean;@Data@AllArgsConstructor@NoArgsConstructor@Document(&quot;chat_messages&quot;)public class ChatMessages &#123;\t//唯一标识，映射到 MongoDB 文档的 _id 字段\t@Id\tprivate ObjectId id;\t\tprivate int messageId;\t\t//存储当前聊天记录列表的json字符串\tprivate String content;&#125;\n\n3.2、创建持久化类创建一个类实现ChatMemoryStore接口\npackage com.wwj.java.ai.langchain4j.store;import com.wwj.java.ai.langchain4j.bean.ChatMessages;import dev.langchain4j.data.message.ChatMessage;import dev.langchain4j.data.message.ChatMessageDeserializer;import dev.langchain4j.data.message.ChatMessageSerializer;import dev.langchain4j.store.memory.chat.ChatMemoryStore;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.mongodb.core.MongoTemplate;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.core.query.Update;import org.springframework.stereotype.Component;import java.util.LinkedList;import java.util.List;@Componentpublic class MongoChatMemoryStore implements ChatMemoryStore &#123;\t@Autowired\tprivate MongoTemplate mongoTemplate;\t\t@Override\tpublic List&lt;ChatMessage&gt; getMessages(Object memoryId) &#123;\t\tCriteria criteria = Criteria.where(&quot;memoryId&quot;).is(memoryId);\t\tQuery query = new Query(criteria);\t\tChatMessages chatMessages = mongoTemplate.findOne(query, ChatMessages.class);\t\tif (chatMessages == null) return new LinkedList&lt;&gt;();\t\treturn ChatMessageDeserializer.messagesFromJson(chatMessages.getContent());\t&#125;\t\t@Override\tpublic void updateMessages(Object memoryId, List&lt;ChatMessage&gt; list) &#123;\t\tCriteria criteria = Criteria.where(&quot;memoryId&quot;).is(memoryId);\t\tQuery query = new Query(criteria);\t\tUpdate update = new Update();\t\tupdate.set(&quot;content&quot;, ChatMessageSerializer.messagesToJson(list));\t\t// 修改或新增\t\tmongoTemplate.upsert(query, update, ChatMessages.class);\t\t&#125;\t\t@Override\tpublic void deleteMessages(Object memoryId) &#123;\t\tCriteria criteria = Criteria.where(&quot;memoryId&quot;).is(memoryId);\t\tQuery query = new Query(criteria);\t\tmongoTemplate.remove(query, ChatMessages.class);\t&#125;&#125;\n\n在SeparateChatAssistantConfig中，添加MongoChatMemoryStore对象的配置\npackage com.wwj.java.ai.langchain4j.config;import com.wwj.java.ai.langchain4j.store.MongoChatMemoryStore;import dev.langchain4j.memory.chat.ChatMemoryProvider;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ChatMemoryProviderConfig &#123;\t\t// 注入持久化对象\t@Autowired\tprivate MongoChatMemoryStore mongoChatMemoryStore;\t\t@Bean\tpublic ChatMemoryProvider chatMemoryProvider() &#123;\t\treturn memoryId -&gt; MessageWindowChatMemory\t\t\t\t.builder()\t\t\t\t.id(memoryId)\t\t\t\t.maxMessages(10)//\t\t\t\t.chatMemoryStore(new InMemoryChatMemoryStore())\t\t\t\t.chatMemoryStore(mongoChatMemoryStore)\t\t\t\t.build();\t&#125;&#125;\n\n4、测试发现MongoDB中已经存储了会话记录\n[  &#123;    &quot;_id&quot;: &#123;&quot;$oid&quot;: &quot;680f2346b055f44aa7fbcd22&quot;&#125;,    &quot;content&quot;: &quot;[&#123;\\&quot;contents\\&quot;:[&#123;\\&quot;text\\&quot;:\\&quot;我是张三\\&quot;,\\&quot;type\\&quot;:\\&quot;TEXT\\&quot;&#125;],\\&quot;type\\&quot;:\\&quot;USER\\&quot;&#125;,&#123;\\&quot;text\\&quot;:\\&quot;你好，张三！很高兴见到你。有什么我可以帮助你的吗？\\&quot;,\\&quot;type\\&quot;:\\&quot;AI\\&quot;&#125;,&#123;\\&quot;contents\\&quot;:[&#123;\\&quot;text\\&quot;:\\&quot;我是谁？\\&quot;,\\&quot;type\\&quot;:\\&quot;TEXT\\&quot;&#125;],\\&quot;type\\&quot;:\\&quot;USER\\&quot;&#125;,&#123;\\&quot;text\\&quot;:\\&quot;你刚才告诉我你是张三。如果你是在问其他身份相关的信息，或者有其他问题需要帮助，请告诉我更多的细节哦！\\&quot;,\\&quot;type\\&quot;:\\&quot;AI\\&quot;&#125;]&quot;,    &quot;memoryId&quot;: 1  &#125;,  &#123;    &quot;_id&quot;: &#123;&quot;$oid&quot;: &quot;680f234cb055f44aa7fbcd2f&quot;&#125;,    &quot;content&quot;: &quot;[&#123;\\&quot;contents\\&quot;:[&#123;\\&quot;text\\&quot;:\\&quot;我是谁？\\&quot;,\\&quot;type\\&quot;:\\&quot;TEXT\\&quot;&#125;],\\&quot;type\\&quot;:\\&quot;USER\\&quot;&#125;,&#123;\\&quot;text\\&quot;:\\&quot;您好！在这里，我看到的是一个使用此平台提问的用户。不过，您的具体身份信息我并不知晓，因为我被设计为尊重每一位用户的隐私。如果您是在寻找自我介绍的帮助，或者有其他相关问题想要讨论，请告诉我更多细节，我会尽力提供帮助！\\&quot;,\\&quot;type\\&quot;:\\&quot;AI\\&quot;&#125;]&quot;,    &quot;memoryId&quot;: 2  &#125;]\n\n六、提示词 Prompt1、系统提示词@SystemMessage 设定角色，塑造AI助手的专业身份，明确助手的能力范围\n1.1、配置@SystemMessage在SeparateChatAssistant类的chat方法上添加@SystemMessage注解\n@SystemMessage(&quot;你是我的好朋友，请用东北话回答问题。&quot;)//系统消息提示词String chat(@MemoryId int memoryId, @UserMessage String userMessage);\n\n @SystemMessage 的内容将在后台转换为  SystemMessage 对象，并与UserMessage一起发送给大语言模型（LLM）。\nSystemMessaged的内容只会发送给大模型一次。 \n如果你修改了SystemMessage的内容，新的SystemMessage会被发送给大模型，之前的聊天记忆会失效。\n1.2、测试package com.wwj.java.ai.langchain4j;import com.wwj.java.ai.langchain4j.assistant.SeparateChatAssistant;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class PromptTest &#123;    @Autowired    private SeparateChatAssistant separateChatAssistant;    @Test    public void testSystemMessage() &#123;        String answer = separateChatAssistant.chat(3, &quot;今天几号&quot;);        System.out.println(answer);    &#125;&#125;\n\n\n哎呀，你这问我我还真不知道，你得自个儿瞅一眼手机或者日历啥的。我这儿也没法实时给你报时啊！哈哈。\n\n如果要显示今天的日期，我们需要在提示词中添加当前日期的占位符\n @SystemMessage(&quot;你是我的好朋友，请用东北话回答问题。今天是&#123;&#123;current_date&#125;&#125;&quot;)//系统消息提示词String chat(@MemoryId int memoryId, @UserMessage String userMessage);\n\n\n哎呀，今儿个是2025年4月28号，你这记性咋跟金鱼似的呢！\n\n1.3、从资源中加载提示模板@SystemMessage 注解还可以从资源中加载提示模板：\n@SystemMessage(fromResource = &quot;my-prompt-template.txt&quot;) String chat(@MemoryId int memoryId, @UserMessage String userMessage);\n\nmy-prompt-template.txt （文件放在 resources中）\n\n你是我的好朋友，请用东北话回答问题，回答问题的时候适当添加表情符号。\n\n表示当前日期\n\n\n你是我的好朋友，请用上海话回答问题，回答问题的时候适当添加表情符号。\n今天是 。\n\n2、用户提示词模板@UserMessage：获取用户输入提示词；用户提示词会在每次对话时携带\n2.1、配置@UserMessage在MemoryChatAssistant 的 chat 方法中添加注解\n// &#123;&#123;it&#125;&#125;表示这里唯一的参数的占位符@UserMessage(&quot;你是我的好朋友，请用上海话回答问题，并且添加一些表情符号。 &#123;&#123;it&#125;&#125;&quot;)String chat(String message);\n\n2.2、测试@Autowiredprivate MemoryChatAssistant memoryChatAssistant;@Testpublic void testUserMessage() &#123;    String answer = memoryChatAssistant.chat(&quot;我是环环&quot;);    System.out.println(answer);&#125;\n\n\n嗨，环环！侬好呀～ 🌟 有啥事儿要问我伐？我一直拉海啊，准备帮侬～ 😊\n\n3、指定参数名称3.1、配置@V@V 明确指定传递的参数名称\n@UserMessage(&quot;你是我的好朋友，请用上海话回答问题，并且添加一些表情符号。&#123;&#123;message&#125;&#125;&quot;) String chat(@V(&quot;message&quot;) String userMessage);\n\n3.2、多个参数的情况如果有两个或两个以上的参数，我们必须要用@V，在 SeparateChatAssistant 中定义方法 chat2\n@UserMessage(&quot;你是我的好朋友，请用粤语回答问题。&#123;&#123;message&#125;&#125;&quot;)String chat2(@MemoryId int memoryId, @V(&quot;message&quot;) String userMessage);\n\n测试： @UserMessage 中的内容每次都会被和用户问题组织在一起发送给大模型\n@Testpublic void testV() &#123;    String answer1 = separateChatAssistant.chat2(10, &quot;我是环环&quot;);    System.out.println(answer1);    String answer2 = separateChatAssistant.chat2(10, &quot;我是谁&quot;);    System.out.println(answer2);&#125;\n\n3.3、@SystemMessage和@V也可以将 @SystemMessage 和 @V 结合使用\n在SeparateChatAssistant 中添加方法chat3\n@SystemMessage(fromResource = &quot;my-prompt-template3.txt&quot;)String chat3(    @MemoryId int memoryId,     @UserMessage String userMessage,     @V(&quot;username&quot;) String username,     @V(&quot;age&quot;) int age);\n\n创建提示词模板my-prompt-template3.txt，添加占位符\n\n你是我的好朋友，我是，我的年龄是，请用东北话回答问题，回答问题的时候适当添加表情 符号。\n 今天是 。\n\n测试：\n@Testpublic void testUserInfo() &#123;    String answer = separateChatAssistant.chat3(1, &quot;我是谁，我多大了&quot;, &quot;翠花&quot;, 18);    System.out.println(answer);&#125;\n\n\n\n七、项目实战-创建硅谷小智这部分我们实现硅谷小智的基本聊天功能，包含聊天记忆、聊天记忆持久化、提示词\n1、创建硅谷小智创建XiaozhiAgent\npackage com.wwj.java.ai.langchain4j.assistant;import dev.langchain4j.service.MemoryId;import dev.langchain4j.service.SystemMessage;import dev.langchain4j.service.UserMessage;import dev.langchain4j.service.spring.AiService;import static dev.langchain4j.service.spring.AiServiceWiringMode.EXPLICIT;@AiService(    wiringMode = EXPLICIT,    chatModel = &quot;qwenChatModel&quot;,    chatMemoryProvider = &quot;chatMemoryProviderXiaozhi&quot;)public interface XiaozhiAgent &#123;    @SystemMessage(fromResource = &quot;zhaozhi-prompt-template.txt&quot;)    String chat(@MemoryId Long memoryId, @UserMessage String userMessage);&#125;\n\n2、提示词模板zhaozhi-prompt-template.txt\n你的名字是“硅谷小智”，你是一家名为“北京协和医院”的智能客服。你是一个训练有素的医疗顾问和医疗伴诊助手。你态度友好、礼貌且言辞简洁。1、请仅在用户发起第一次会话时，和用户打个招呼，并介绍你是谁。2、作为一个训练有素的医疗顾问：请基于当前临床实践和研究，针对患者提出的特定健康问题，提供详细、准确且实用的医疗建议。请同时考虑可能的病因、诊断流程、治疗方案以及预防措施，并给出在不同情境下的应对策略。对于药物治疗，请特别指明适用的药品名称、剂量和疗程。如果需要进一步的检查或就医，也请明确指示。3、作为医疗伴诊助手，你可以回答用户就医流程中的相关问题，主要包含以下功能：AI分导诊：根据患者的病情和就医需求，智能推荐最合适的科室。AI挂号助手：实现智能查询是否有挂号号源服务；实现智能预约挂号服务；实现智能取消挂号服务。4、你必须遵守的规则如下：在获取挂号预约详情或取消挂号预约之前，你必须确保自己知晓用户的姓名（必选）、身份证号（必选）、预约科室（必选）、预约日期（必选，格式举例：2025-04-14）、预约时间（必选，格式：上午 或 下午）、预约医生（可选）。当被问到其他领域的咨询时，要表示歉意并说明你无法在这方面提供帮助。5、请在回答的结果中适当包含一些轻松可爱的图标和表情。6、今天是 &#123;&#123;current_date&#125;&#125;。\n\n3、配置小智助手配置持久化和记忆隔离\npackage com.wwj.java.ai.langchain4j.config;import com.wwj.java.ai.langchain4j.store.MongoChatMemoryStore;import dev.langchain4j.memory.chat.ChatMemoryProvider;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class chatMemoryProviderXiaozhiConfig &#123;    @Autowired    private MongoChatMemoryStore mongoChatMemoryStore;    @Bean    public ChatMemoryProvider chatMemoryProviderXiaozhi() &#123;        return memoryId -&gt;            MessageWindowChatMemory.builder()            .id(memoryId)            .maxMessages(20)            .chatMemoryStore(mongoChatMemoryStore)            .build();    &#125;&#125;\n\n4、封装对话对象package com.wwj.java.ai.langchain4j.bean;import lombok.Data;@Datapublic class ChatForm &#123;    private Long memoryId;//对话id    private String message;//用户问题&#125;\n\n5、添加Controller方法package com.wwj.java.ai.langchain4j.controller;import com.wwj.java.ai.langchain4j.assistant.XiaozhiAgent;import com.wwj.java.ai.langchain4j.bean.ChatForm;import io.swagger.v3.oas.annotations.Operation;import io.swagger.v3.oas.annotations.tags.Tag;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Tag(name = &quot;硅谷小智&quot;)@RestController@RequestMapping(&quot;/xiaozhi&quot;)public class XiaozhiController &#123;    @Autowired    private XiaozhiAgent xiaozhiAgent;    @Operation(summary = &quot;对话&quot;)    @PostMapping(&quot;/chat&quot;)    public String chat(@RequestBody ChatForm chatForm) &#123;        return xiaozhiAgent.chat(chatForm.getMemoryId(), chatForm.getMessage());    &#125;&#125;\n\n6、待优化信息查询：提示词中还应该提供医院信息（如位置信息，营业时间等）、科室信息（都有哪些科室）、医生信息（都有哪些医生）\n业务实现：预约、取消预约、查询是否预约等\n信息查询可以使用RAG检索增强生成\n业务实现需要通过 Function Calling 函数调用\n八、 Function Calling 函数调用Function Calling 函数调用 也叫   Tools 工具\n1、入门案例例如，大语言模型本身并不擅长数学运算。如果应用场景中偶尔会涉及到数学计算，我们可以为他提供 一个 “数学工具”。当我们提出问题时，大语言模型会判断是否使用某个工具。\n1.1、创建工具类用 @Tool 注解的方法： \n\n既可以是静态的，也可以是非静态的； \n可以具有任何可见性（公有、私有等）。\n\n","categories":["项目"],"tags":["Java","LangChain4j","RAG"]},{"title":"脚本库","url":"/2023/12/26/%E8%84%9A%E6%9C%AC%E5%BA%93/","content":"Windows - bat 脚本自动提交 git 文件新建一个txt文件，进行编辑，编辑后，更改后缀为bat\nchcp 65001：为了防止使用 UTF-8 编码出现中文乱码\n我要提交的文件在 E 盘，而bat 脚本在桌面，所以首先e:，进入 E 盘，再cd到对应的文件夹，提交信息使用系统时间\nchcp 65001rem 设置提交信息set commit_msg=%date%e:cd E:\\笔记\\hexo-fluidgit add .git commit -m &quot;%commit_msg%&quot;git pushecho 已完成!pause\n\n演示的结果图：\n\nLinux 脚本集群分发脚本可以同步多个服务器中的文件，在服务器任何地方使用脚本都可以同步文件\n1.创建文件\n为了让系统中的任何位置都能执行这个脚本，例如我们在当前用户wwj根目录创建一个文件夹bin（位置：&#x2F;home&#x2F;wwj&#x2F;bin）\n将/home/wwj/bin加入全局环境变量：（root 用户使用需要指定到脚本具体位置：&#x2F;home&#x2F;wwj&#x2F;bin&#x2F;xsync）\nsudo vim /etc/profile\n\n在文件的末尾添加以下行：\nexport PATH=$PATH:/home/wwj/bin\n\n保存并关闭文件,为了使改动立即生效，需要执行以下命令：source /etc/profile,查看是否已经添加成功：\nwwj@JD bin$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/wwj/bin\n\n在/home/wwj/bin中创建文件xsync，填入以下内容，需要替换host中的hadoop102-104为自己需要同步的服务器\n#!/bin/bash#1. 判断参数个数if [ $# -lt 1 ]then    echo Not Enough Arguement!    exit;fi#2. 遍历集群所有机器for host in hadoop102 hadoop103 hadoop104do    echo ====================  $host  ====================    #3. 遍历所有目录，挨个发送    for file in $@    do        #4. 判断文件是否存在        if [ -e $file ]            then                #5. 获取父目录                pdir=$(cd -P $(dirname $file); pwd)                #6. 获取当前文件的名称                fname=$(basename $file)                ssh $host &quot;mkdir -p $pdir&quot;                rsync -av $pdir/$fname $host:$pdir            else                echo $file does not exists!        fi    donedone\n\n为脚本赋予可执行权限：chmod 777 xsync, 执行命令xsync 文件地址,例如：\nwwj@JD ~$ xsync bin/\n\n首次使用时，需要输入目标服务器的密码，我们可以使用 ssh 免密登录：（演示服务器 A -&gt; 服务器 B）\n在服务器 A生成 ssh 密钥对：ssh-keygen -t rsa\nwwj@JD /$ cd ~/.ssh/wwj@JD .ssh$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/wwj/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/wwj/.ssh/id_rsaYour public key has been saved in /home/wwj/.ssh/id_rsa.pubThe key fingerprint is:SHA256:QigxmgXju6yJuFzOSqjR8MhDfbNsM+iKN4eJHchQotE wwj@JDThe key&#x27;s randomart image is:+---[RSA 3072]----+|oo+              ||+=Eo .           ||+=. . .          ||o o. .           ||++ . o. S        ||**o + o.         ||+Oo* *           ||Xo% o o          ||O*o*             |+----[SHA256]-----+\n\n分享 ssh 公钥到服务器 B上，使用命令：ssh-copy-id 服务器B\n之后访问服务器 B则不需要输入密码，使用xsync脚本分发时则不需要密码\n","categories":["脚本"],"tags":["bat"]}]